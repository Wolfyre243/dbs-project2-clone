/**
 * Client
 **/

import * as runtime from "./runtime/library.js";
import $Types = runtime.Types; // general types
import $Public = runtime.Types.Public;
import $Utils = runtime.Types.Utils;
import $Extensions = runtime.Types.Extensions;
import $Result = runtime.Types.Result;

export type PrismaPromise<T> = $Public.PrismaPromise<T>;

/**
 * Model users
 *
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>;
/**
 * Model status
 *
 */
export type status = $Result.DefaultSelection<Prisma.$statusPayload>;
/**
 * Model audio
 *
 */
export type audio = $Result.DefaultSelection<Prisma.$audioPayload>;
/**
 * Model exhibitAudioRelation
 *
 */
export type exhibitAudioRelation =
  $Result.DefaultSelection<Prisma.$exhibitAudioRelationPayload>;
/**
 * Model exhibit
 *
 */
export type exhibit = $Result.DefaultSelection<Prisma.$exhibitPayload>;
/**
 * Model auditLog
 *
 */
export type auditLog = $Result.DefaultSelection<Prisma.$auditLogPayload>;
/**
 * Model phoneNumber
 *
 */
export type phoneNumber = $Result.DefaultSelection<Prisma.$phoneNumberPayload>;
/**
 * Model email
 *
 */
export type email = $Result.DefaultSelection<Prisma.$emailPayload>;
/**
 * Model userRole
 *
 */
export type userRole = $Result.DefaultSelection<Prisma.$userRolePayload>;
/**
 * Model role
 *
 */
export type role = $Result.DefaultSelection<Prisma.$rolePayload>;
/**
 * Model qrCode
 *
 */
export type qrCode = $Result.DefaultSelection<Prisma.$qrCodePayload>;
/**
 * Model image
 *
 */
export type image = $Result.DefaultSelection<Prisma.$imagePayload>;
/**
 * Model event
 *
 */
export type event = $Result.DefaultSelection<Prisma.$eventPayload>;
/**
 * Model session
 *
 */
export type session = $Result.DefaultSelection<Prisma.$sessionPayload>;
/**
 * Model userProfile
 *
 */
export type userProfile = $Result.DefaultSelection<Prisma.$userProfilePayload>;
/**
 * Model language
 *
 */
export type language = $Result.DefaultSelection<Prisma.$languagePayload>;
/**
 * Model subtitle
 *
 */
export type subtitle = $Result.DefaultSelection<Prisma.$subtitlePayload>;
/**
 * Model exhibitSubtitle
 *
 */
export type exhibitSubtitle =
  $Result.DefaultSelection<Prisma.$exhibitSubtitlePayload>;

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.users.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = "log" extends keyof ClientOptions
    ? ClientOptions["log"] extends Array<Prisma.LogLevel | Prisma.LogDefinition>
      ? Prisma.GetEvents<ClientOptions["log"]>
      : never
    : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>["other"] };

  /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.users.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(
    optionsArg?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>,
  );
  $on<V extends U>(
    eventType: V,
    callback: (
      event: V extends "query" ? Prisma.QueryEvent : Prisma.LogEvent,
    ) => void,
  ): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void;

  /**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(
    query: string,
    ...values: any[]
  ): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(
    query: string,
    ...values: any[]
  ): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(
    arg: [...P],
    options?: { isolationLevel?: Prisma.TransactionIsolationLevel },
  ): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>;

  $transaction<R>(
    fn: (
      prisma: Omit<PrismaClient, runtime.ITXClientDenyList>,
    ) => $Utils.JsPromise<R>,
    options?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    },
  ): $Utils.JsPromise<R>;

  $extends: $Extensions.ExtendsHook<
    "extends",
    Prisma.TypeMapCb<ClientOptions>,
    ExtArgs,
    $Utils.Call<
      Prisma.TypeMapCb<ClientOptions>,
      {
        extArgs: ExtArgs;
      }
    >
  >;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Users
   * const users = await prisma.users.findMany()
   * ```
   */
  get users(): Prisma.usersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.status`: Exposes CRUD operations for the **status** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Statuses
   * const statuses = await prisma.status.findMany()
   * ```
   */
  get status(): Prisma.statusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.audio`: Exposes CRUD operations for the **audio** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Audio
   * const audio = await prisma.audio.findMany()
   * ```
   */
  get audio(): Prisma.audioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exhibitAudioRelation`: Exposes CRUD operations for the **exhibitAudioRelation** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ExhibitAudioRelations
   * const exhibitAudioRelations = await prisma.exhibitAudioRelation.findMany()
   * ```
   */
  get exhibitAudioRelation(): Prisma.exhibitAudioRelationDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.exhibit`: Exposes CRUD operations for the **exhibit** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Exhibits
   * const exhibits = await prisma.exhibit.findMany()
   * ```
   */
  get exhibit(): Prisma.exhibitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **auditLog** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more AuditLogs
   * const auditLogs = await prisma.auditLog.findMany()
   * ```
   */
  get auditLog(): Prisma.auditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.phoneNumber`: Exposes CRUD operations for the **phoneNumber** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more PhoneNumbers
   * const phoneNumbers = await prisma.phoneNumber.findMany()
   * ```
   */
  get phoneNumber(): Prisma.phoneNumberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.email`: Exposes CRUD operations for the **email** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Emails
   * const emails = await prisma.email.findMany()
   * ```
   */
  get email(): Prisma.emailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userRole`: Exposes CRUD operations for the **userRole** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more UserRoles
   * const userRoles = await prisma.userRole.findMany()
   * ```
   */
  get userRole(): Prisma.userRoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **role** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Roles
   * const roles = await prisma.role.findMany()
   * ```
   */
  get role(): Prisma.roleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.qrCode`: Exposes CRUD operations for the **qrCode** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more QrCodes
   * const qrCodes = await prisma.qrCode.findMany()
   * ```
   */
  get qrCode(): Prisma.qrCodeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.image`: Exposes CRUD operations for the **image** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Images
   * const images = await prisma.image.findMany()
   * ```
   */
  get image(): Prisma.imageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **event** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Events
   * const events = await prisma.event.findMany()
   * ```
   */
  get event(): Prisma.eventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **session** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Sessions
   * const sessions = await prisma.session.findMany()
   * ```
   */
  get session(): Prisma.sessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userProfile`: Exposes CRUD operations for the **userProfile** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more UserProfiles
   * const userProfiles = await prisma.userProfile.findMany()
   * ```
   */
  get userProfile(): Prisma.userProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.language`: Exposes CRUD operations for the **language** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Languages
   * const languages = await prisma.language.findMany()
   * ```
   */
  get language(): Prisma.languageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subtitle`: Exposes CRUD operations for the **subtitle** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Subtitles
   * const subtitles = await prisma.subtitle.findMany()
   * ```
   */
  get subtitle(): Prisma.subtitleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exhibitSubtitle`: Exposes CRUD operations for the **exhibitSubtitle** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ExhibitSubtitles
   * const exhibitSubtitles = await prisma.exhibitSubtitle.findMany()
   * ```
   */
  get exhibitSubtitle(): Prisma.exhibitSubtitleDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF;

  export type PrismaPromise<T> = $Public.PrismaPromise<T>;

  /**
   * Validator
   */
  export import validator = runtime.Public.validator;

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError;
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError;
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError;
  export import PrismaClientValidationError = runtime.PrismaClientValidationError;

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag;
  export import empty = runtime.empty;
  export import join = runtime.join;
  export import raw = runtime.raw;
  export import Sql = runtime.Sql;

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal;

  export type DecimalJsLike = runtime.DecimalJsLike;

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics;
  export type Metric<T> = runtime.Metric<T>;
  export type MetricHistogram = runtime.MetricHistogram;
  export type MetricHistogramBucket = runtime.MetricHistogramBucket;

  /**
   * Extensions
   */
  export import Extension = $Extensions.UserArgs;
  export import getExtensionContext = runtime.Extensions.getExtensionContext;
  export import Args = $Public.Args;
  export import Payload = $Public.Payload;
  export import Result = $Public.Result;
  export import Exact = $Public.Exact;

  /**
   * Prisma Client JS version: 6.11.1
   * Query Engine version: f40f79ec31188888a2e33acda0ecc8fd10a853a9
   */
  export type PrismaVersion = {
    client: string;
  };

  export const prismaVersion: PrismaVersion;

  /**
   * Utility Types
   */

  export import JsonObject = runtime.JsonObject;
  export import JsonArray = runtime.JsonArray;
  export import JsonValue = runtime.JsonValue;
  export import InputJsonObject = runtime.InputJsonObject;
  export import InputJsonArray = runtime.InputJsonArray;
  export import InputJsonValue = runtime.InputJsonValue;

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
     * Type of `Prisma.DbNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class DbNull {
      private DbNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.JsonNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class JsonNull {
      private JsonNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.AnyNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class AnyNull {
      private AnyNull: never;
      private constructor();
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull;

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull;

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull;

  type SelectAndInclude = {
    select: any;
    include: any;
  };

  type SelectAndOmit = {
    select: any;
    omit: any;
  };

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> =
    T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<
    T extends (...args: any) => $Utils.JsPromise<any>,
  > = PromiseType<ReturnType<T>>;

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
  };

  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K;
  }[keyof T];

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K;
  };

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>;

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & (T extends SelectAndInclude
    ? "Please either choose `select` or `include`."
    : T extends SelectAndOmit
      ? "Please either choose `select` or `omit`."
      : {});

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & K;

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = T extends object
    ? U extends object
      ? (Without<T, U> & U) | (Without<U, T> & T)
      : U
    : T;

  /**
   * Is T a Record?
   */
  type IsObject<T extends any> =
    T extends Array<any>
      ? False
      : T extends Date
        ? False
        : T extends Uint8Array
          ? False
          : T extends BigInt
            ? False
            : T extends object
              ? True
              : False;

  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T;

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O>; // With K possibilities
    }[K];

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>;

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<
    __Either<O, K>
  >;

  type _Either<O extends object, K extends Key, strict extends Boolean> = {
    1: EitherStrict<O, K>;
    0: EitherLoose<O, K>;
  }[strict];

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1,
  > = O extends unknown ? _Either<O, K, strict> : never;

  export type Union = any;

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K];
  } & {};

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never;

  export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<
    Overwrite<
      U,
      {
        [K in keyof U]-?: At<U, K>;
      }
    >
  >;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O
    ? O[K]
    : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown
    ? AtStrict<O, K>
    : never;
  export type At<
    O extends object,
    K extends Key,
    strict extends Boolean = 1,
  > = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function
    ? A
    : {
        [K in keyof A]: A[K];
      } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
      ?
          | (K extends keyof O ? { [P in K]: O[P] } & O : O)
          | ({ [P in keyof O as P extends K ? P : never]-?: O[P] } & O)
      : never
  >;

  type _Strict<U, _U = U> = U extends unknown
    ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>>
    : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False;

  // /**
  // 1
  // */
  export type True = 1;

  /**
  0
  */
  export type False = 0;

  export type Not<B extends Boolean> = {
    0: 1;
    1: 0;
  }[B];

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
      ? 1
      : 0;

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >;

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0;
      1: 1;
    };
    1: {
      0: 1;
      1: 1;
    };
  }[B1][B2];

  export type Keys<U extends Union> = U extends unknown ? keyof U : never;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object
    ? {
        [P in keyof T]: P extends keyof O ? O[P] : never;
      }
    : never;

  type FieldPaths<
    T,
    U = Omit<T, "_avg" | "_sum" | "_count" | "_min" | "_max">,
  > = IsObject<T> extends True ? U : T;

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<"OR", K>, Extends<"AND", K>>,
      Extends<"NOT", K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<
            UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never
          >
        : never
      : {} extends FieldPaths<T[K]>
        ? never
        : K;
  }[keyof T];

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never;
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>;
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T;

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<
    T,
    K extends Enumerable<keyof T> | keyof T,
  > = Prisma__Pick<T, MaybeTupleToUnion<K>>;

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}`
    ? never
    : T;

  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>;

  type FieldRefInputType<Model, FieldType> = Model extends never
    ? never
    : FieldRef<Model, FieldType>;

  export const ModelName: {
    users: "users";
    status: "status";
    audio: "audio";
    exhibitAudioRelation: "exhibitAudioRelation";
    exhibit: "exhibit";
    auditLog: "auditLog";
    phoneNumber: "phoneNumber";
    email: "email";
    userRole: "userRole";
    role: "role";
    qrCode: "qrCode";
    image: "image";
    event: "event";
    session: "session";
    userProfile: "userProfile";
    language: "language";
    subtitle: "subtitle";
    exhibitSubtitle: "exhibitSubtitle";
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName];

  export type Datasources = {
    db?: Datasource;
  };

  interface TypeMapCb<ClientOptions = {}>
    extends $Utils.Fn<
      { extArgs: $Extensions.InternalArgs },
      $Utils.Record<string, any>
    > {
    returns: Prisma.TypeMap<
      this["params"]["extArgs"],
      ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}
    >;
  }

  export type TypeMap<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > = {
    globalOmitOptions: {
      omit: GlobalOmitOptions;
    };
    meta: {
      modelProps:
        | "users"
        | "status"
        | "audio"
        | "exhibitAudioRelation"
        | "exhibit"
        | "auditLog"
        | "phoneNumber"
        | "email"
        | "userRole"
        | "role"
        | "qrCode"
        | "image"
        | "event"
        | "session"
        | "userProfile"
        | "language"
        | "subtitle"
        | "exhibitSubtitle";
      txIsolationLevel: Prisma.TransactionIsolationLevel;
    };
    model: {
      users: {
        payload: Prisma.$usersPayload<ExtArgs>;
        fields: Prisma.usersFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$usersPayload>;
          };
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$usersPayload>;
          };
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[];
          };
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$usersPayload>;
          };
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.usersCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[];
          };
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$usersPayload>;
          };
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$usersPayload>;
          };
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.usersUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[];
          };
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$usersPayload>;
          };
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateUsers>;
          };
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>;
            result: $Utils.Optional<UsersGroupByOutputType>[];
          };
          count: {
            args: Prisma.usersCountArgs<ExtArgs>;
            result: $Utils.Optional<UsersCountAggregateOutputType> | number;
          };
        };
      };
      status: {
        payload: Prisma.$statusPayload<ExtArgs>;
        fields: Prisma.statusFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.statusFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$statusPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.statusFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$statusPayload>;
          };
          findFirst: {
            args: Prisma.statusFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$statusPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.statusFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$statusPayload>;
          };
          findMany: {
            args: Prisma.statusFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$statusPayload>[];
          };
          create: {
            args: Prisma.statusCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$statusPayload>;
          };
          createMany: {
            args: Prisma.statusCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.statusCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$statusPayload>[];
          };
          delete: {
            args: Prisma.statusDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$statusPayload>;
          };
          update: {
            args: Prisma.statusUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$statusPayload>;
          };
          deleteMany: {
            args: Prisma.statusDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.statusUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.statusUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$statusPayload>[];
          };
          upsert: {
            args: Prisma.statusUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$statusPayload>;
          };
          aggregate: {
            args: Prisma.StatusAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateStatus>;
          };
          groupBy: {
            args: Prisma.statusGroupByArgs<ExtArgs>;
            result: $Utils.Optional<StatusGroupByOutputType>[];
          };
          count: {
            args: Prisma.statusCountArgs<ExtArgs>;
            result: $Utils.Optional<StatusCountAggregateOutputType> | number;
          };
        };
      };
      audio: {
        payload: Prisma.$audioPayload<ExtArgs>;
        fields: Prisma.audioFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.audioFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$audioPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.audioFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$audioPayload>;
          };
          findFirst: {
            args: Prisma.audioFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$audioPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.audioFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$audioPayload>;
          };
          findMany: {
            args: Prisma.audioFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$audioPayload>[];
          };
          create: {
            args: Prisma.audioCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$audioPayload>;
          };
          createMany: {
            args: Prisma.audioCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.audioCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$audioPayload>[];
          };
          delete: {
            args: Prisma.audioDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$audioPayload>;
          };
          update: {
            args: Prisma.audioUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$audioPayload>;
          };
          deleteMany: {
            args: Prisma.audioDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.audioUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.audioUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$audioPayload>[];
          };
          upsert: {
            args: Prisma.audioUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$audioPayload>;
          };
          aggregate: {
            args: Prisma.AudioAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAudio>;
          };
          groupBy: {
            args: Prisma.audioGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AudioGroupByOutputType>[];
          };
          count: {
            args: Prisma.audioCountArgs<ExtArgs>;
            result: $Utils.Optional<AudioCountAggregateOutputType> | number;
          };
        };
      };
      exhibitAudioRelation: {
        payload: Prisma.$exhibitAudioRelationPayload<ExtArgs>;
        fields: Prisma.exhibitAudioRelationFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.exhibitAudioRelationFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$exhibitAudioRelationPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.exhibitAudioRelationFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$exhibitAudioRelationPayload>;
          };
          findFirst: {
            args: Prisma.exhibitAudioRelationFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$exhibitAudioRelationPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.exhibitAudioRelationFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$exhibitAudioRelationPayload>;
          };
          findMany: {
            args: Prisma.exhibitAudioRelationFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$exhibitAudioRelationPayload>[];
          };
          create: {
            args: Prisma.exhibitAudioRelationCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$exhibitAudioRelationPayload>;
          };
          createMany: {
            args: Prisma.exhibitAudioRelationCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.exhibitAudioRelationCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$exhibitAudioRelationPayload>[];
          };
          delete: {
            args: Prisma.exhibitAudioRelationDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$exhibitAudioRelationPayload>;
          };
          update: {
            args: Prisma.exhibitAudioRelationUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$exhibitAudioRelationPayload>;
          };
          deleteMany: {
            args: Prisma.exhibitAudioRelationDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.exhibitAudioRelationUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.exhibitAudioRelationUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$exhibitAudioRelationPayload>[];
          };
          upsert: {
            args: Prisma.exhibitAudioRelationUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$exhibitAudioRelationPayload>;
          };
          aggregate: {
            args: Prisma.ExhibitAudioRelationAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateExhibitAudioRelation>;
          };
          groupBy: {
            args: Prisma.exhibitAudioRelationGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ExhibitAudioRelationGroupByOutputType>[];
          };
          count: {
            args: Prisma.exhibitAudioRelationCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<ExhibitAudioRelationCountAggregateOutputType>
              | number;
          };
        };
      };
      exhibit: {
        payload: Prisma.$exhibitPayload<ExtArgs>;
        fields: Prisma.exhibitFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.exhibitFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$exhibitPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.exhibitFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$exhibitPayload>;
          };
          findFirst: {
            args: Prisma.exhibitFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$exhibitPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.exhibitFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$exhibitPayload>;
          };
          findMany: {
            args: Prisma.exhibitFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$exhibitPayload>[];
          };
          create: {
            args: Prisma.exhibitCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$exhibitPayload>;
          };
          createMany: {
            args: Prisma.exhibitCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.exhibitCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$exhibitPayload>[];
          };
          delete: {
            args: Prisma.exhibitDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$exhibitPayload>;
          };
          update: {
            args: Prisma.exhibitUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$exhibitPayload>;
          };
          deleteMany: {
            args: Prisma.exhibitDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.exhibitUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.exhibitUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$exhibitPayload>[];
          };
          upsert: {
            args: Prisma.exhibitUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$exhibitPayload>;
          };
          aggregate: {
            args: Prisma.ExhibitAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateExhibit>;
          };
          groupBy: {
            args: Prisma.exhibitGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ExhibitGroupByOutputType>[];
          };
          count: {
            args: Prisma.exhibitCountArgs<ExtArgs>;
            result: $Utils.Optional<ExhibitCountAggregateOutputType> | number;
          };
        };
      };
      auditLog: {
        payload: Prisma.$auditLogPayload<ExtArgs>;
        fields: Prisma.auditLogFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.auditLogFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$auditLogPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.auditLogFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$auditLogPayload>;
          };
          findFirst: {
            args: Prisma.auditLogFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$auditLogPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.auditLogFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$auditLogPayload>;
          };
          findMany: {
            args: Prisma.auditLogFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$auditLogPayload>[];
          };
          create: {
            args: Prisma.auditLogCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$auditLogPayload>;
          };
          createMany: {
            args: Prisma.auditLogCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.auditLogCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$auditLogPayload>[];
          };
          delete: {
            args: Prisma.auditLogDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$auditLogPayload>;
          };
          update: {
            args: Prisma.auditLogUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$auditLogPayload>;
          };
          deleteMany: {
            args: Prisma.auditLogDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.auditLogUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.auditLogUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$auditLogPayload>[];
          };
          upsert: {
            args: Prisma.auditLogUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$auditLogPayload>;
          };
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAuditLog>;
          };
          groupBy: {
            args: Prisma.auditLogGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AuditLogGroupByOutputType>[];
          };
          count: {
            args: Prisma.auditLogCountArgs<ExtArgs>;
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number;
          };
        };
      };
      phoneNumber: {
        payload: Prisma.$phoneNumberPayload<ExtArgs>;
        fields: Prisma.phoneNumberFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.phoneNumberFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$phoneNumberPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.phoneNumberFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$phoneNumberPayload>;
          };
          findFirst: {
            args: Prisma.phoneNumberFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$phoneNumberPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.phoneNumberFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$phoneNumberPayload>;
          };
          findMany: {
            args: Prisma.phoneNumberFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$phoneNumberPayload>[];
          };
          create: {
            args: Prisma.phoneNumberCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$phoneNumberPayload>;
          };
          createMany: {
            args: Prisma.phoneNumberCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.phoneNumberCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$phoneNumberPayload>[];
          };
          delete: {
            args: Prisma.phoneNumberDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$phoneNumberPayload>;
          };
          update: {
            args: Prisma.phoneNumberUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$phoneNumberPayload>;
          };
          deleteMany: {
            args: Prisma.phoneNumberDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.phoneNumberUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.phoneNumberUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$phoneNumberPayload>[];
          };
          upsert: {
            args: Prisma.phoneNumberUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$phoneNumberPayload>;
          };
          aggregate: {
            args: Prisma.PhoneNumberAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregatePhoneNumber>;
          };
          groupBy: {
            args: Prisma.phoneNumberGroupByArgs<ExtArgs>;
            result: $Utils.Optional<PhoneNumberGroupByOutputType>[];
          };
          count: {
            args: Prisma.phoneNumberCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<PhoneNumberCountAggregateOutputType>
              | number;
          };
        };
      };
      email: {
        payload: Prisma.$emailPayload<ExtArgs>;
        fields: Prisma.emailFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.emailFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$emailPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.emailFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$emailPayload>;
          };
          findFirst: {
            args: Prisma.emailFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$emailPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.emailFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$emailPayload>;
          };
          findMany: {
            args: Prisma.emailFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$emailPayload>[];
          };
          create: {
            args: Prisma.emailCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$emailPayload>;
          };
          createMany: {
            args: Prisma.emailCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.emailCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$emailPayload>[];
          };
          delete: {
            args: Prisma.emailDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$emailPayload>;
          };
          update: {
            args: Prisma.emailUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$emailPayload>;
          };
          deleteMany: {
            args: Prisma.emailDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.emailUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.emailUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$emailPayload>[];
          };
          upsert: {
            args: Prisma.emailUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$emailPayload>;
          };
          aggregate: {
            args: Prisma.EmailAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateEmail>;
          };
          groupBy: {
            args: Prisma.emailGroupByArgs<ExtArgs>;
            result: $Utils.Optional<EmailGroupByOutputType>[];
          };
          count: {
            args: Prisma.emailCountArgs<ExtArgs>;
            result: $Utils.Optional<EmailCountAggregateOutputType> | number;
          };
        };
      };
      userRole: {
        payload: Prisma.$userRolePayload<ExtArgs>;
        fields: Prisma.userRoleFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.userRoleFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$userRolePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.userRoleFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$userRolePayload>;
          };
          findFirst: {
            args: Prisma.userRoleFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$userRolePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.userRoleFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$userRolePayload>;
          };
          findMany: {
            args: Prisma.userRoleFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$userRolePayload>[];
          };
          create: {
            args: Prisma.userRoleCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$userRolePayload>;
          };
          createMany: {
            args: Prisma.userRoleCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.userRoleCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$userRolePayload>[];
          };
          delete: {
            args: Prisma.userRoleDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$userRolePayload>;
          };
          update: {
            args: Prisma.userRoleUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$userRolePayload>;
          };
          deleteMany: {
            args: Prisma.userRoleDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.userRoleUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.userRoleUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$userRolePayload>[];
          };
          upsert: {
            args: Prisma.userRoleUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$userRolePayload>;
          };
          aggregate: {
            args: Prisma.UserRoleAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateUserRole>;
          };
          groupBy: {
            args: Prisma.userRoleGroupByArgs<ExtArgs>;
            result: $Utils.Optional<UserRoleGroupByOutputType>[];
          };
          count: {
            args: Prisma.userRoleCountArgs<ExtArgs>;
            result: $Utils.Optional<UserRoleCountAggregateOutputType> | number;
          };
        };
      };
      role: {
        payload: Prisma.$rolePayload<ExtArgs>;
        fields: Prisma.roleFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.roleFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$rolePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.roleFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$rolePayload>;
          };
          findFirst: {
            args: Prisma.roleFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$rolePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.roleFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$rolePayload>;
          };
          findMany: {
            args: Prisma.roleFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$rolePayload>[];
          };
          create: {
            args: Prisma.roleCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$rolePayload>;
          };
          createMany: {
            args: Prisma.roleCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.roleCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$rolePayload>[];
          };
          delete: {
            args: Prisma.roleDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$rolePayload>;
          };
          update: {
            args: Prisma.roleUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$rolePayload>;
          };
          deleteMany: {
            args: Prisma.roleDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.roleUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.roleUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$rolePayload>[];
          };
          upsert: {
            args: Prisma.roleUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$rolePayload>;
          };
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateRole>;
          };
          groupBy: {
            args: Prisma.roleGroupByArgs<ExtArgs>;
            result: $Utils.Optional<RoleGroupByOutputType>[];
          };
          count: {
            args: Prisma.roleCountArgs<ExtArgs>;
            result: $Utils.Optional<RoleCountAggregateOutputType> | number;
          };
        };
      };
      qrCode: {
        payload: Prisma.$qrCodePayload<ExtArgs>;
        fields: Prisma.qrCodeFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.qrCodeFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$qrCodePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.qrCodeFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$qrCodePayload>;
          };
          findFirst: {
            args: Prisma.qrCodeFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$qrCodePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.qrCodeFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$qrCodePayload>;
          };
          findMany: {
            args: Prisma.qrCodeFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$qrCodePayload>[];
          };
          create: {
            args: Prisma.qrCodeCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$qrCodePayload>;
          };
          createMany: {
            args: Prisma.qrCodeCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.qrCodeCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$qrCodePayload>[];
          };
          delete: {
            args: Prisma.qrCodeDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$qrCodePayload>;
          };
          update: {
            args: Prisma.qrCodeUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$qrCodePayload>;
          };
          deleteMany: {
            args: Prisma.qrCodeDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.qrCodeUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.qrCodeUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$qrCodePayload>[];
          };
          upsert: {
            args: Prisma.qrCodeUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$qrCodePayload>;
          };
          aggregate: {
            args: Prisma.QrCodeAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateQrCode>;
          };
          groupBy: {
            args: Prisma.qrCodeGroupByArgs<ExtArgs>;
            result: $Utils.Optional<QrCodeGroupByOutputType>[];
          };
          count: {
            args: Prisma.qrCodeCountArgs<ExtArgs>;
            result: $Utils.Optional<QrCodeCountAggregateOutputType> | number;
          };
        };
      };
      image: {
        payload: Prisma.$imagePayload<ExtArgs>;
        fields: Prisma.imageFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.imageFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$imagePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.imageFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$imagePayload>;
          };
          findFirst: {
            args: Prisma.imageFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$imagePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.imageFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$imagePayload>;
          };
          findMany: {
            args: Prisma.imageFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$imagePayload>[];
          };
          create: {
            args: Prisma.imageCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$imagePayload>;
          };
          createMany: {
            args: Prisma.imageCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.imageCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$imagePayload>[];
          };
          delete: {
            args: Prisma.imageDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$imagePayload>;
          };
          update: {
            args: Prisma.imageUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$imagePayload>;
          };
          deleteMany: {
            args: Prisma.imageDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.imageUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.imageUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$imagePayload>[];
          };
          upsert: {
            args: Prisma.imageUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$imagePayload>;
          };
          aggregate: {
            args: Prisma.ImageAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateImage>;
          };
          groupBy: {
            args: Prisma.imageGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ImageGroupByOutputType>[];
          };
          count: {
            args: Prisma.imageCountArgs<ExtArgs>;
            result: $Utils.Optional<ImageCountAggregateOutputType> | number;
          };
        };
      };
      event: {
        payload: Prisma.$eventPayload<ExtArgs>;
        fields: Prisma.eventFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.eventFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$eventPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.eventFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$eventPayload>;
          };
          findFirst: {
            args: Prisma.eventFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$eventPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.eventFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$eventPayload>;
          };
          findMany: {
            args: Prisma.eventFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$eventPayload>[];
          };
          create: {
            args: Prisma.eventCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$eventPayload>;
          };
          createMany: {
            args: Prisma.eventCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.eventCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$eventPayload>[];
          };
          delete: {
            args: Prisma.eventDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$eventPayload>;
          };
          update: {
            args: Prisma.eventUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$eventPayload>;
          };
          deleteMany: {
            args: Prisma.eventDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.eventUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.eventUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$eventPayload>[];
          };
          upsert: {
            args: Prisma.eventUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$eventPayload>;
          };
          aggregate: {
            args: Prisma.EventAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateEvent>;
          };
          groupBy: {
            args: Prisma.eventGroupByArgs<ExtArgs>;
            result: $Utils.Optional<EventGroupByOutputType>[];
          };
          count: {
            args: Prisma.eventCountArgs<ExtArgs>;
            result: $Utils.Optional<EventCountAggregateOutputType> | number;
          };
        };
      };
      session: {
        payload: Prisma.$sessionPayload<ExtArgs>;
        fields: Prisma.sessionFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.sessionFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$sessionPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.sessionFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>;
          };
          findFirst: {
            args: Prisma.sessionFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$sessionPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.sessionFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>;
          };
          findMany: {
            args: Prisma.sessionFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>[];
          };
          create: {
            args: Prisma.sessionCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>;
          };
          createMany: {
            args: Prisma.sessionCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.sessionCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>[];
          };
          delete: {
            args: Prisma.sessionDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>;
          };
          update: {
            args: Prisma.sessionUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>;
          };
          deleteMany: {
            args: Prisma.sessionDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.sessionUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.sessionUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>[];
          };
          upsert: {
            args: Prisma.sessionUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>;
          };
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateSession>;
          };
          groupBy: {
            args: Prisma.sessionGroupByArgs<ExtArgs>;
            result: $Utils.Optional<SessionGroupByOutputType>[];
          };
          count: {
            args: Prisma.sessionCountArgs<ExtArgs>;
            result: $Utils.Optional<SessionCountAggregateOutputType> | number;
          };
        };
      };
      userProfile: {
        payload: Prisma.$userProfilePayload<ExtArgs>;
        fields: Prisma.userProfileFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.userProfileFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$userProfilePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.userProfileFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$userProfilePayload>;
          };
          findFirst: {
            args: Prisma.userProfileFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$userProfilePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.userProfileFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$userProfilePayload>;
          };
          findMany: {
            args: Prisma.userProfileFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$userProfilePayload>[];
          };
          create: {
            args: Prisma.userProfileCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$userProfilePayload>;
          };
          createMany: {
            args: Prisma.userProfileCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.userProfileCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$userProfilePayload>[];
          };
          delete: {
            args: Prisma.userProfileDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$userProfilePayload>;
          };
          update: {
            args: Prisma.userProfileUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$userProfilePayload>;
          };
          deleteMany: {
            args: Prisma.userProfileDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.userProfileUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.userProfileUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$userProfilePayload>[];
          };
          upsert: {
            args: Prisma.userProfileUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$userProfilePayload>;
          };
          aggregate: {
            args: Prisma.UserProfileAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateUserProfile>;
          };
          groupBy: {
            args: Prisma.userProfileGroupByArgs<ExtArgs>;
            result: $Utils.Optional<UserProfileGroupByOutputType>[];
          };
          count: {
            args: Prisma.userProfileCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<UserProfileCountAggregateOutputType>
              | number;
          };
        };
      };
      language: {
        payload: Prisma.$languagePayload<ExtArgs>;
        fields: Prisma.languageFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.languageFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$languagePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.languageFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$languagePayload>;
          };
          findFirst: {
            args: Prisma.languageFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$languagePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.languageFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$languagePayload>;
          };
          findMany: {
            args: Prisma.languageFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$languagePayload>[];
          };
          create: {
            args: Prisma.languageCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$languagePayload>;
          };
          createMany: {
            args: Prisma.languageCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.languageCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$languagePayload>[];
          };
          delete: {
            args: Prisma.languageDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$languagePayload>;
          };
          update: {
            args: Prisma.languageUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$languagePayload>;
          };
          deleteMany: {
            args: Prisma.languageDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.languageUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.languageUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$languagePayload>[];
          };
          upsert: {
            args: Prisma.languageUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$languagePayload>;
          };
          aggregate: {
            args: Prisma.LanguageAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateLanguage>;
          };
          groupBy: {
            args: Prisma.languageGroupByArgs<ExtArgs>;
            result: $Utils.Optional<LanguageGroupByOutputType>[];
          };
          count: {
            args: Prisma.languageCountArgs<ExtArgs>;
            result: $Utils.Optional<LanguageCountAggregateOutputType> | number;
          };
        };
      };
      subtitle: {
        payload: Prisma.$subtitlePayload<ExtArgs>;
        fields: Prisma.subtitleFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.subtitleFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$subtitlePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.subtitleFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$subtitlePayload>;
          };
          findFirst: {
            args: Prisma.subtitleFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$subtitlePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.subtitleFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$subtitlePayload>;
          };
          findMany: {
            args: Prisma.subtitleFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$subtitlePayload>[];
          };
          create: {
            args: Prisma.subtitleCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$subtitlePayload>;
          };
          createMany: {
            args: Prisma.subtitleCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.subtitleCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$subtitlePayload>[];
          };
          delete: {
            args: Prisma.subtitleDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$subtitlePayload>;
          };
          update: {
            args: Prisma.subtitleUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$subtitlePayload>;
          };
          deleteMany: {
            args: Prisma.subtitleDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.subtitleUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.subtitleUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$subtitlePayload>[];
          };
          upsert: {
            args: Prisma.subtitleUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$subtitlePayload>;
          };
          aggregate: {
            args: Prisma.SubtitleAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateSubtitle>;
          };
          groupBy: {
            args: Prisma.subtitleGroupByArgs<ExtArgs>;
            result: $Utils.Optional<SubtitleGroupByOutputType>[];
          };
          count: {
            args: Prisma.subtitleCountArgs<ExtArgs>;
            result: $Utils.Optional<SubtitleCountAggregateOutputType> | number;
          };
        };
      };
      exhibitSubtitle: {
        payload: Prisma.$exhibitSubtitlePayload<ExtArgs>;
        fields: Prisma.exhibitSubtitleFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.exhibitSubtitleFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$exhibitSubtitlePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.exhibitSubtitleFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$exhibitSubtitlePayload>;
          };
          findFirst: {
            args: Prisma.exhibitSubtitleFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$exhibitSubtitlePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.exhibitSubtitleFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$exhibitSubtitlePayload>;
          };
          findMany: {
            args: Prisma.exhibitSubtitleFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$exhibitSubtitlePayload>[];
          };
          create: {
            args: Prisma.exhibitSubtitleCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$exhibitSubtitlePayload>;
          };
          createMany: {
            args: Prisma.exhibitSubtitleCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.exhibitSubtitleCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$exhibitSubtitlePayload>[];
          };
          delete: {
            args: Prisma.exhibitSubtitleDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$exhibitSubtitlePayload>;
          };
          update: {
            args: Prisma.exhibitSubtitleUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$exhibitSubtitlePayload>;
          };
          deleteMany: {
            args: Prisma.exhibitSubtitleDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.exhibitSubtitleUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.exhibitSubtitleUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$exhibitSubtitlePayload>[];
          };
          upsert: {
            args: Prisma.exhibitSubtitleUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$exhibitSubtitlePayload>;
          };
          aggregate: {
            args: Prisma.ExhibitSubtitleAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateExhibitSubtitle>;
          };
          groupBy: {
            args: Prisma.exhibitSubtitleGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ExhibitSubtitleGroupByOutputType>[];
          };
          count: {
            args: Prisma.exhibitSubtitleCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<ExhibitSubtitleCountAggregateOutputType>
              | number;
          };
        };
      };
    };
  } & {
    other: {
      payload: any;
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
      };
    };
  };
  export const defineExtension: $Extensions.ExtendsHook<
    "define",
    Prisma.TypeMapCb,
    $Extensions.DefaultArgs
  >;
  export type DefaultPrismaClient = PrismaClient;
  export type ErrorFormat = "pretty" | "colorless" | "minimal";
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources;
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string;
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat;
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     *
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[];
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    };
    /**
     * Global configuration for omitting model fields by default.
     *
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig;
  }
  export type GlobalOmitConfig = {
    users?: usersOmit;
    status?: statusOmit;
    audio?: audioOmit;
    exhibitAudioRelation?: exhibitAudioRelationOmit;
    exhibit?: exhibitOmit;
    auditLog?: auditLogOmit;
    phoneNumber?: phoneNumberOmit;
    email?: emailOmit;
    userRole?: userRoleOmit;
    role?: roleOmit;
    qrCode?: qrCodeOmit;
    image?: imageOmit;
    event?: eventOmit;
    session?: sessionOmit;
    userProfile?: userProfileOmit;
    language?: languageOmit;
    subtitle?: subtitleOmit;
    exhibitSubtitle?: exhibitSubtitleOmit;
  };

  /* Types for Logging */
  export type LogLevel = "info" | "query" | "warn" | "error";
  export type LogDefinition = {
    level: LogLevel;
    emit: "stdout" | "event";
  };

  export type GetLogType<T extends LogLevel | LogDefinition> =
    T extends LogDefinition
      ? T["emit"] extends "event"
        ? T["level"]
        : never
      : never;
  export type GetEvents<T extends any> =
    T extends Array<LogLevel | LogDefinition>
      ?
          | GetLogType<T[0]>
          | GetLogType<T[1]>
          | GetLogType<T[2]>
          | GetLogType<T[3]>
      : never;

  export type QueryEvent = {
    timestamp: Date;
    query: string;
    params: string;
    duration: number;
    target: string;
  };

  export type LogEvent = {
    timestamp: Date;
    message: string;
    target: string;
  };
  /* End Types for Logging */

  export type PrismaAction =
    | "findUnique"
    | "findUniqueOrThrow"
    | "findMany"
    | "findFirst"
    | "findFirstOrThrow"
    | "create"
    | "createMany"
    | "createManyAndReturn"
    | "update"
    | "updateMany"
    | "updateManyAndReturn"
    | "upsert"
    | "delete"
    | "deleteMany"
    | "executeRaw"
    | "queryRaw"
    | "aggregate"
    | "count"
    | "runCommandRaw"
    | "findRaw"
    | "groupBy";

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName;
    action: PrismaAction;
    args: any;
    dataPath: string[];
    runInTransaction: boolean;
  };

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>;

  // tested in getLogLevel.test.ts
  export function getLogLevel(
    log: Array<LogLevel | LogDefinition>,
  ): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<
    Prisma.DefaultPrismaClient,
    runtime.ITXClientDenyList
  >;

  export type Datasource = {
    url?: string;
  };

  /**
   * Count Types
   */

  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    phoneNumbers: number;
    emails: number;
    sessions: number;
    auditLogs: number;
    events: number;
    userRoles: number;
  };

  export type UsersCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    phoneNumbers?: boolean | UsersCountOutputTypeCountPhoneNumbersArgs;
    emails?: boolean | UsersCountOutputTypeCountEmailsArgs;
    sessions?: boolean | UsersCountOutputTypeCountSessionsArgs;
    auditLogs?: boolean | UsersCountOutputTypeCountAuditLogsArgs;
    events?: boolean | UsersCountOutputTypeCountEventsArgs;
    userRoles?: boolean | UsersCountOutputTypeCountUserRolesArgs;
  };

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountPhoneNumbersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: phoneNumberWhereInput;
  };

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountEmailsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: emailWhereInput;
  };

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountSessionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: sessionWhereInput;
  };

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountAuditLogsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: auditLogWhereInput;
  };

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountEventsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: eventWhereInput;
  };

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUserRolesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: userRoleWhereInput;
  };

  /**
   * Count Type StatusCountOutputType
   */

  export type StatusCountOutputType = {
    users: number;
    audios: number;
    exhibits: number;
    phoneNumbers: number;
    emails: number;
    roles: number;
    qrcodes: number;
    images: number;
    subtitles: number;
    languages: number;
    auditLogs: number;
    userProfiles: number;
  };

  export type StatusCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    users?: boolean | StatusCountOutputTypeCountUsersArgs;
    audios?: boolean | StatusCountOutputTypeCountAudiosArgs;
    exhibits?: boolean | StatusCountOutputTypeCountExhibitsArgs;
    phoneNumbers?: boolean | StatusCountOutputTypeCountPhoneNumbersArgs;
    emails?: boolean | StatusCountOutputTypeCountEmailsArgs;
    roles?: boolean | StatusCountOutputTypeCountRolesArgs;
    qrcodes?: boolean | StatusCountOutputTypeCountQrcodesArgs;
    images?: boolean | StatusCountOutputTypeCountImagesArgs;
    subtitles?: boolean | StatusCountOutputTypeCountSubtitlesArgs;
    languages?: boolean | StatusCountOutputTypeCountLanguagesArgs;
    auditLogs?: boolean | StatusCountOutputTypeCountAuditLogsArgs;
    userProfiles?: boolean | StatusCountOutputTypeCountUserProfilesArgs;
  };

  // Custom InputTypes
  /**
   * StatusCountOutputType without action
   */
  export type StatusCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the StatusCountOutputType
     */
    select?: StatusCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * StatusCountOutputType without action
   */
  export type StatusCountOutputTypeCountUsersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: usersWhereInput;
  };

  /**
   * StatusCountOutputType without action
   */
  export type StatusCountOutputTypeCountAudiosArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: audioWhereInput;
  };

  /**
   * StatusCountOutputType without action
   */
  export type StatusCountOutputTypeCountExhibitsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: exhibitWhereInput;
  };

  /**
   * StatusCountOutputType without action
   */
  export type StatusCountOutputTypeCountPhoneNumbersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: phoneNumberWhereInput;
  };

  /**
   * StatusCountOutputType without action
   */
  export type StatusCountOutputTypeCountEmailsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: emailWhereInput;
  };

  /**
   * StatusCountOutputType without action
   */
  export type StatusCountOutputTypeCountRolesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: roleWhereInput;
  };

  /**
   * StatusCountOutputType without action
   */
  export type StatusCountOutputTypeCountQrcodesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: qrCodeWhereInput;
  };

  /**
   * StatusCountOutputType without action
   */
  export type StatusCountOutputTypeCountImagesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: imageWhereInput;
  };

  /**
   * StatusCountOutputType without action
   */
  export type StatusCountOutputTypeCountSubtitlesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: subtitleWhereInput;
  };

  /**
   * StatusCountOutputType without action
   */
  export type StatusCountOutputTypeCountLanguagesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: languageWhereInput;
  };

  /**
   * StatusCountOutputType without action
   */
  export type StatusCountOutputTypeCountAuditLogsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: auditLogWhereInput;
  };

  /**
   * StatusCountOutputType without action
   */
  export type StatusCountOutputTypeCountUserProfilesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: userProfileWhereInput;
  };

  /**
   * Count Type AudioCountOutputType
   */

  export type AudioCountOutputType = {
    exhibits: number;
    exhibit: number;
  };

  export type AudioCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    exhibits?: boolean | AudioCountOutputTypeCountExhibitsArgs;
    exhibit?: boolean | AudioCountOutputTypeCountExhibitArgs;
  };

  // Custom InputTypes
  /**
   * AudioCountOutputType without action
   */
  export type AudioCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AudioCountOutputType
     */
    select?: AudioCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * AudioCountOutputType without action
   */
  export type AudioCountOutputTypeCountExhibitsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: exhibitAudioRelationWhereInput;
  };

  /**
   * AudioCountOutputType without action
   */
  export type AudioCountOutputTypeCountExhibitArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: exhibitWhereInput;
  };

  /**
   * Count Type ExhibitCountOutputType
   */

  export type ExhibitCountOutputType = {
    subtitles: number;
    exhibitAudioRelation: number;
  };

  export type ExhibitCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    subtitles?: boolean | ExhibitCountOutputTypeCountSubtitlesArgs;
    exhibitAudioRelation?:
      | boolean
      | ExhibitCountOutputTypeCountExhibitAudioRelationArgs;
  };

  // Custom InputTypes
  /**
   * ExhibitCountOutputType without action
   */
  export type ExhibitCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ExhibitCountOutputType
     */
    select?: ExhibitCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * ExhibitCountOutputType without action
   */
  export type ExhibitCountOutputTypeCountSubtitlesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: exhibitSubtitleWhereInput;
  };

  /**
   * ExhibitCountOutputType without action
   */
  export type ExhibitCountOutputTypeCountExhibitAudioRelationArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: exhibitAudioRelationWhereInput;
  };

  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    userRoles: number;
  };

  export type RoleCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    userRoles?: boolean | RoleCountOutputTypeCountUserRolesArgs;
  };

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUserRolesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: userRoleWhereInput;
  };

  /**
   * Count Type QrCodeCountOutputType
   */

  export type QrCodeCountOutputType = {
    exhibit: number;
  };

  export type QrCodeCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    exhibit?: boolean | QrCodeCountOutputTypeCountExhibitArgs;
  };

  // Custom InputTypes
  /**
   * QrCodeCountOutputType without action
   */
  export type QrCodeCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the QrCodeCountOutputType
     */
    select?: QrCodeCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * QrCodeCountOutputType without action
   */
  export type QrCodeCountOutputTypeCountExhibitArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: exhibitWhereInput;
  };

  /**
   * Count Type ImageCountOutputType
   */

  export type ImageCountOutputType = {
    exhibit: number;
  };

  export type ImageCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    exhibit?: boolean | ImageCountOutputTypeCountExhibitArgs;
  };

  // Custom InputTypes
  /**
   * ImageCountOutputType without action
   */
  export type ImageCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ImageCountOutputType
     */
    select?: ImageCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * ImageCountOutputType without action
   */
  export type ImageCountOutputTypeCountExhibitArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: exhibitWhereInput;
  };

  /**
   * Count Type SessionCountOutputType
   */

  export type SessionCountOutputType = {
    events: number;
  };

  export type SessionCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    events?: boolean | SessionCountOutputTypeCountEventsArgs;
  };

  // Custom InputTypes
  /**
   * SessionCountOutputType without action
   */
  export type SessionCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SessionCountOutputType
     */
    select?: SessionCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * SessionCountOutputType without action
   */
  export type SessionCountOutputTypeCountEventsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: eventWhereInput;
  };

  /**
   * Count Type LanguageCountOutputType
   */

  export type LanguageCountOutputType = {
    audios: number;
    profiles: number;
    subtitles: number;
  };

  export type LanguageCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    audios?: boolean | LanguageCountOutputTypeCountAudiosArgs;
    profiles?: boolean | LanguageCountOutputTypeCountProfilesArgs;
    subtitles?: boolean | LanguageCountOutputTypeCountSubtitlesArgs;
  };

  // Custom InputTypes
  /**
   * LanguageCountOutputType without action
   */
  export type LanguageCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the LanguageCountOutputType
     */
    select?: LanguageCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * LanguageCountOutputType without action
   */
  export type LanguageCountOutputTypeCountAudiosArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: audioWhereInput;
  };

  /**
   * LanguageCountOutputType without action
   */
  export type LanguageCountOutputTypeCountProfilesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: userProfileWhereInput;
  };

  /**
   * LanguageCountOutputType without action
   */
  export type LanguageCountOutputTypeCountSubtitlesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: subtitleWhereInput;
  };

  /**
   * Count Type SubtitleCountOutputType
   */

  export type SubtitleCountOutputType = {
    exhibits: number;
  };

  export type SubtitleCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    exhibits?: boolean | SubtitleCountOutputTypeCountExhibitsArgs;
  };

  // Custom InputTypes
  /**
   * SubtitleCountOutputType without action
   */
  export type SubtitleCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SubtitleCountOutputType
     */
    select?: SubtitleCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * SubtitleCountOutputType without action
   */
  export type SubtitleCountOutputTypeCountExhibitsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: exhibitSubtitleWhereInput;
  };

  /**
   * Models
   */

  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null;
    _min: UsersMinAggregateOutputType | null;
    _max: UsersMaxAggregateOutputType | null;
  };

  export type UsersMinAggregateOutputType = {
    userId: string | null;
    username: string | null;
    password: string | null;
    createdAt: Date | null;
    modifiedAt: Date | null;
    statusCode: string | null;
  };

  export type UsersMaxAggregateOutputType = {
    userId: string | null;
    username: string | null;
    password: string | null;
    createdAt: Date | null;
    modifiedAt: Date | null;
    statusCode: string | null;
  };

  export type UsersCountAggregateOutputType = {
    userId: number;
    username: number;
    password: number;
    createdAt: number;
    modifiedAt: number;
    statusCode: number;
    _all: number;
  };

  export type UsersMinAggregateInputType = {
    userId?: true;
    username?: true;
    password?: true;
    createdAt?: true;
    modifiedAt?: true;
    statusCode?: true;
  };

  export type UsersMaxAggregateInputType = {
    userId?: true;
    username?: true;
    password?: true;
    createdAt?: true;
    modifiedAt?: true;
    statusCode?: true;
  };

  export type UsersCountAggregateInputType = {
    userId?: true;
    username?: true;
    password?: true;
    createdAt?: true;
    modifiedAt?: true;
    statusCode?: true;
    _all?: true;
  };

  export type UsersAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned users
     **/
    _count?: true | UsersCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: UsersMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: UsersMaxAggregateInputType;
  };

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
    [P in keyof T & keyof AggregateUsers]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>;
  };

  export type usersGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: usersWhereInput;
    orderBy?:
      | usersOrderByWithAggregationInput
      | usersOrderByWithAggregationInput[];
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum;
    having?: usersScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: UsersCountAggregateInputType | true;
    _min?: UsersMinAggregateInputType;
    _max?: UsersMaxAggregateInputType;
  };

  export type UsersGroupByOutputType = {
    userId: string;
    username: string;
    password: string;
    createdAt: Date;
    modifiedAt: Date;
    statusCode: string;
    _count: UsersCountAggregateOutputType | null;
    _min: UsersMinAggregateOutputType | null;
    _max: UsersMaxAggregateOutputType | null;
  };

  type GetUsersGroupByPayload<T extends usersGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<UsersGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof UsersGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>;
        }
      >
    >;

  export type usersSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      userId?: boolean;
      username?: boolean;
      password?: boolean;
      createdAt?: boolean;
      modifiedAt?: boolean;
      statusCode?: boolean;
      phoneNumbers?: boolean | users$phoneNumbersArgs<ExtArgs>;
      emails?: boolean | users$emailsArgs<ExtArgs>;
      userProfile?: boolean | users$userProfileArgs<ExtArgs>;
      sessions?: boolean | users$sessionsArgs<ExtArgs>;
      auditLogs?: boolean | users$auditLogsArgs<ExtArgs>;
      events?: boolean | users$eventsArgs<ExtArgs>;
      userRoles?: boolean | users$userRolesArgs<ExtArgs>;
      status?: boolean | statusDefaultArgs<ExtArgs>;
      _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["users"]
  >;

  export type usersSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      userId?: boolean;
      username?: boolean;
      password?: boolean;
      createdAt?: boolean;
      modifiedAt?: boolean;
      statusCode?: boolean;
      status?: boolean | statusDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["users"]
  >;

  export type usersSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      userId?: boolean;
      username?: boolean;
      password?: boolean;
      createdAt?: boolean;
      modifiedAt?: boolean;
      statusCode?: boolean;
      status?: boolean | statusDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["users"]
  >;

  export type usersSelectScalar = {
    userId?: boolean;
    username?: boolean;
    password?: boolean;
    createdAt?: boolean;
    modifiedAt?: boolean;
    statusCode?: boolean;
  };

  export type usersOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "userId"
    | "username"
    | "password"
    | "createdAt"
    | "modifiedAt"
    | "statusCode",
    ExtArgs["result"]["users"]
  >;
  export type usersInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    phoneNumbers?: boolean | users$phoneNumbersArgs<ExtArgs>;
    emails?: boolean | users$emailsArgs<ExtArgs>;
    userProfile?: boolean | users$userProfileArgs<ExtArgs>;
    sessions?: boolean | users$sessionsArgs<ExtArgs>;
    auditLogs?: boolean | users$auditLogsArgs<ExtArgs>;
    events?: boolean | users$eventsArgs<ExtArgs>;
    userRoles?: boolean | users$userRolesArgs<ExtArgs>;
    status?: boolean | statusDefaultArgs<ExtArgs>;
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type usersIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    status?: boolean | statusDefaultArgs<ExtArgs>;
  };
  export type usersIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    status?: boolean | statusDefaultArgs<ExtArgs>;
  };

  export type $usersPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "users";
    objects: {
      phoneNumbers: Prisma.$phoneNumberPayload<ExtArgs>[];
      emails: Prisma.$emailPayload<ExtArgs>[];
      userProfile: Prisma.$userProfilePayload<ExtArgs> | null;
      sessions: Prisma.$sessionPayload<ExtArgs>[];
      auditLogs: Prisma.$auditLogPayload<ExtArgs>[];
      events: Prisma.$eventPayload<ExtArgs>[];
      userRoles: Prisma.$userRolePayload<ExtArgs>[];
      status: Prisma.$statusPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        userId: string;
        username: string;
        password: string;
        createdAt: Date;
        modifiedAt: Date;
        statusCode: string;
      },
      ExtArgs["result"]["users"]
    >;
    composites: {};
  };

  type usersGetPayload<
    S extends boolean | null | undefined | usersDefaultArgs,
  > = $Result.GetResult<Prisma.$usersPayload, S>;

  type usersCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<usersFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: UsersCountAggregateInputType | true;
  };

  export interface usersDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["users"];
      meta: { name: "users" };
    };
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(
      args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>,
    ): Prisma__usersClient<
      $Result.GetResult<
        Prisma.$usersPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(
      args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__usersClient<
      $Result.GetResult<
        Prisma.$usersPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(
      args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>,
    ): Prisma__usersClient<
      $Result.GetResult<
        Prisma.$usersPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(
      args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__usersClient<
      $Result.GetResult<
        Prisma.$usersPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     *
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     *
     * // Only select the `userId`
     * const usersWithUserIdOnly = await prisma.users.findMany({ select: { userId: true } })
     *
     */
    findMany<T extends usersFindManyArgs>(
      args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$usersPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     *
     */
    create<T extends usersCreateArgs>(
      args: SelectSubset<T, usersCreateArgs<ExtArgs>>,
    ): Prisma__usersClient<
      $Result.GetResult<
        Prisma.$usersPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends usersCreateManyArgs>(
      args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Users and returns the data saved in the database.
     * @param {usersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Users and only return the `userId`
     * const usersWithUserIdOnly = await prisma.users.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends usersCreateManyAndReturnArgs>(
      args?: SelectSubset<T, usersCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$usersPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     *
     */
    delete<T extends usersDeleteArgs>(
      args: SelectSubset<T, usersDeleteArgs<ExtArgs>>,
    ): Prisma__usersClient<
      $Result.GetResult<
        Prisma.$usersPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends usersUpdateArgs>(
      args: SelectSubset<T, usersUpdateArgs<ExtArgs>>,
    ): Prisma__usersClient<
      $Result.GetResult<
        Prisma.$usersPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends usersDeleteManyArgs>(
      args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends usersUpdateManyArgs>(
      args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {usersUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Users and only return the `userId`
     * const usersWithUserIdOnly = await prisma.users.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends usersUpdateManyAndReturnArgs>(
      args: SelectSubset<T, usersUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$usersPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(
      args: SelectSubset<T, usersUpsertArgs<ExtArgs>>,
    ): Prisma__usersClient<
      $Result.GetResult<
        Prisma.$usersPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
     **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], UsersCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends UsersAggregateArgs>(
      args: Subset<T, UsersAggregateArgs>,
    ): Prisma.PrismaPromise<GetUsersAggregateType<T>>;

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs["orderBy"] }
        : { orderBy?: usersGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetUsersGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the users model
     */
    readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    phoneNumbers<T extends users$phoneNumbersArgs<ExtArgs> = {}>(
      args?: Subset<T, users$phoneNumbersArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$phoneNumberPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    emails<T extends users$emailsArgs<ExtArgs> = {}>(
      args?: Subset<T, users$emailsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$emailPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    userProfile<T extends users$userProfileArgs<ExtArgs> = {}>(
      args?: Subset<T, users$userProfileArgs<ExtArgs>>,
    ): Prisma__userProfileClient<
      $Result.GetResult<
        Prisma.$userProfilePayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    sessions<T extends users$sessionsArgs<ExtArgs> = {}>(
      args?: Subset<T, users$sessionsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$sessionPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    auditLogs<T extends users$auditLogsArgs<ExtArgs> = {}>(
      args?: Subset<T, users$auditLogsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$auditLogPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    events<T extends users$eventsArgs<ExtArgs> = {}>(
      args?: Subset<T, users$eventsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$eventPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    userRoles<T extends users$userRolesArgs<ExtArgs> = {}>(
      args?: Subset<T, users$userRolesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$userRolePayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    status<T extends statusDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, statusDefaultArgs<ExtArgs>>,
    ): Prisma__statusClient<
      | $Result.GetResult<
          Prisma.$statusPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the users model
   */
  interface usersFieldRefs {
    readonly userId: FieldRef<"users", "String">;
    readonly username: FieldRef<"users", "String">;
    readonly password: FieldRef<"users", "String">;
    readonly createdAt: FieldRef<"users", "DateTime">;
    readonly modifiedAt: FieldRef<"users", "DateTime">;
    readonly statusCode: FieldRef<"users", "String">;
  }

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null;
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput;
  };

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null;
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput;
  };

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null;
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[];
  };

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null;
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[];
  };

  /**
   * users findMany
   */
  export type usersFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null;
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` users.
     */
    skip?: number;
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[];
  };

  /**
   * users create
   */
  export type usersCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null;
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>;
  };

  /**
   * users createMany
   */
  export type usersCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * users createManyAndReturn
   */
  export type usersCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null;
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * users update
   */
  export type usersUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null;
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>;
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput;
  };

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>;
    /**
     * Filter which users to update
     */
    where?: usersWhereInput;
    /**
     * Limit how many users to update.
     */
    limit?: number;
  };

  /**
   * users updateManyAndReturn
   */
  export type usersUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null;
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>;
    /**
     * Filter which users to update
     */
    where?: usersWhereInput;
    /**
     * Limit how many users to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * users upsert
   */
  export type usersUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null;
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput;
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>;
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>;
  };

  /**
   * users delete
   */
  export type usersDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null;
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput;
  };

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput;
    /**
     * Limit how many users to delete.
     */
    limit?: number;
  };

  /**
   * users.phoneNumbers
   */
  export type users$phoneNumbersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the phoneNumber
     */
    select?: phoneNumberSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the phoneNumber
     */
    omit?: phoneNumberOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: phoneNumberInclude<ExtArgs> | null;
    where?: phoneNumberWhereInput;
    orderBy?:
      | phoneNumberOrderByWithRelationInput
      | phoneNumberOrderByWithRelationInput[];
    cursor?: phoneNumberWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: PhoneNumberScalarFieldEnum | PhoneNumberScalarFieldEnum[];
  };

  /**
   * users.emails
   */
  export type users$emailsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the email
     */
    select?: emailSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the email
     */
    omit?: emailOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: emailInclude<ExtArgs> | null;
    where?: emailWhereInput;
    orderBy?: emailOrderByWithRelationInput | emailOrderByWithRelationInput[];
    cursor?: emailWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: EmailScalarFieldEnum | EmailScalarFieldEnum[];
  };

  /**
   * users.userProfile
   */
  export type users$userProfileArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the userProfile
     */
    select?: userProfileSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the userProfile
     */
    omit?: userProfileOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userProfileInclude<ExtArgs> | null;
    where?: userProfileWhereInput;
  };

  /**
   * users.sessions
   */
  export type users$sessionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null;
    where?: sessionWhereInput;
    orderBy?:
      | sessionOrderByWithRelationInput
      | sessionOrderByWithRelationInput[];
    cursor?: sessionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[];
  };

  /**
   * users.auditLogs
   */
  export type users$auditLogsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the auditLog
     */
    select?: auditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the auditLog
     */
    omit?: auditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditLogInclude<ExtArgs> | null;
    where?: auditLogWhereInput;
    orderBy?:
      | auditLogOrderByWithRelationInput
      | auditLogOrderByWithRelationInput[];
    cursor?: auditLogWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[];
  };

  /**
   * users.events
   */
  export type users$eventsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the event
     */
    omit?: eventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventInclude<ExtArgs> | null;
    where?: eventWhereInput;
    orderBy?: eventOrderByWithRelationInput | eventOrderByWithRelationInput[];
    cursor?: eventWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[];
  };

  /**
   * users.userRoles
   */
  export type users$userRolesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the userRole
     */
    select?: userRoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the userRole
     */
    omit?: userRoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userRoleInclude<ExtArgs> | null;
    where?: userRoleWhereInput;
    orderBy?:
      | userRoleOrderByWithRelationInput
      | userRoleOrderByWithRelationInput[];
    cursor?: userRoleWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[];
  };

  /**
   * users without action
   */
  export type usersDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null;
  };

  /**
   * Model status
   */

  export type AggregateStatus = {
    _count: StatusCountAggregateOutputType | null;
    _min: StatusMinAggregateOutputType | null;
    _max: StatusMaxAggregateOutputType | null;
  };

  export type StatusMinAggregateOutputType = {
    statusCode: string | null;
    description: string | null;
  };

  export type StatusMaxAggregateOutputType = {
    statusCode: string | null;
    description: string | null;
  };

  export type StatusCountAggregateOutputType = {
    statusCode: number;
    description: number;
    _all: number;
  };

  export type StatusMinAggregateInputType = {
    statusCode?: true;
    description?: true;
  };

  export type StatusMaxAggregateInputType = {
    statusCode?: true;
    description?: true;
  };

  export type StatusCountAggregateInputType = {
    statusCode?: true;
    description?: true;
    _all?: true;
  };

  export type StatusAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which status to aggregate.
     */
    where?: statusWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of statuses to fetch.
     */
    orderBy?: statusOrderByWithRelationInput | statusOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: statusWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` statuses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` statuses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned statuses
     **/
    _count?: true | StatusCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: StatusMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: StatusMaxAggregateInputType;
  };

  export type GetStatusAggregateType<T extends StatusAggregateArgs> = {
    [P in keyof T & keyof AggregateStatus]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStatus[P]>
      : GetScalarType<T[P], AggregateStatus[P]>;
  };

  export type statusGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: statusWhereInput;
    orderBy?:
      | statusOrderByWithAggregationInput
      | statusOrderByWithAggregationInput[];
    by: StatusScalarFieldEnum[] | StatusScalarFieldEnum;
    having?: statusScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: StatusCountAggregateInputType | true;
    _min?: StatusMinAggregateInputType;
    _max?: StatusMaxAggregateInputType;
  };

  export type StatusGroupByOutputType = {
    statusCode: string;
    description: string;
    _count: StatusCountAggregateOutputType | null;
    _min: StatusMinAggregateOutputType | null;
    _max: StatusMaxAggregateOutputType | null;
  };

  type GetStatusGroupByPayload<T extends statusGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<StatusGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof StatusGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StatusGroupByOutputType[P]>
            : GetScalarType<T[P], StatusGroupByOutputType[P]>;
        }
      >
    >;

  export type statusSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      statusCode?: boolean;
      description?: boolean;
      users?: boolean | status$usersArgs<ExtArgs>;
      audios?: boolean | status$audiosArgs<ExtArgs>;
      exhibits?: boolean | status$exhibitsArgs<ExtArgs>;
      phoneNumbers?: boolean | status$phoneNumbersArgs<ExtArgs>;
      emails?: boolean | status$emailsArgs<ExtArgs>;
      roles?: boolean | status$rolesArgs<ExtArgs>;
      qrcodes?: boolean | status$qrcodesArgs<ExtArgs>;
      images?: boolean | status$imagesArgs<ExtArgs>;
      subtitles?: boolean | status$subtitlesArgs<ExtArgs>;
      languages?: boolean | status$languagesArgs<ExtArgs>;
      auditLogs?: boolean | status$auditLogsArgs<ExtArgs>;
      userProfiles?: boolean | status$userProfilesArgs<ExtArgs>;
      _count?: boolean | StatusCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["status"]
  >;

  export type statusSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      statusCode?: boolean;
      description?: boolean;
    },
    ExtArgs["result"]["status"]
  >;

  export type statusSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      statusCode?: boolean;
      description?: boolean;
    },
    ExtArgs["result"]["status"]
  >;

  export type statusSelectScalar = {
    statusCode?: boolean;
    description?: boolean;
  };

  export type statusOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "statusCode" | "description",
    ExtArgs["result"]["status"]
  >;
  export type statusInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    users?: boolean | status$usersArgs<ExtArgs>;
    audios?: boolean | status$audiosArgs<ExtArgs>;
    exhibits?: boolean | status$exhibitsArgs<ExtArgs>;
    phoneNumbers?: boolean | status$phoneNumbersArgs<ExtArgs>;
    emails?: boolean | status$emailsArgs<ExtArgs>;
    roles?: boolean | status$rolesArgs<ExtArgs>;
    qrcodes?: boolean | status$qrcodesArgs<ExtArgs>;
    images?: boolean | status$imagesArgs<ExtArgs>;
    subtitles?: boolean | status$subtitlesArgs<ExtArgs>;
    languages?: boolean | status$languagesArgs<ExtArgs>;
    auditLogs?: boolean | status$auditLogsArgs<ExtArgs>;
    userProfiles?: boolean | status$userProfilesArgs<ExtArgs>;
    _count?: boolean | StatusCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type statusIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};
  export type statusIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $statusPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "status";
    objects: {
      users: Prisma.$usersPayload<ExtArgs>[];
      audios: Prisma.$audioPayload<ExtArgs>[];
      exhibits: Prisma.$exhibitPayload<ExtArgs>[];
      phoneNumbers: Prisma.$phoneNumberPayload<ExtArgs>[];
      emails: Prisma.$emailPayload<ExtArgs>[];
      roles: Prisma.$rolePayload<ExtArgs>[];
      qrcodes: Prisma.$qrCodePayload<ExtArgs>[];
      images: Prisma.$imagePayload<ExtArgs>[];
      subtitles: Prisma.$subtitlePayload<ExtArgs>[];
      languages: Prisma.$languagePayload<ExtArgs>[];
      auditLogs: Prisma.$auditLogPayload<ExtArgs>[];
      userProfiles: Prisma.$userProfilePayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        statusCode: string;
        description: string;
      },
      ExtArgs["result"]["status"]
    >;
    composites: {};
  };

  type statusGetPayload<
    S extends boolean | null | undefined | statusDefaultArgs,
  > = $Result.GetResult<Prisma.$statusPayload, S>;

  type statusCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<statusFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: StatusCountAggregateInputType | true;
  };

  export interface statusDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["status"];
      meta: { name: "status" };
    };
    /**
     * Find zero or one Status that matches the filter.
     * @param {statusFindUniqueArgs} args - Arguments to find a Status
     * @example
     * // Get one Status
     * const status = await prisma.status.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends statusFindUniqueArgs>(
      args: SelectSubset<T, statusFindUniqueArgs<ExtArgs>>,
    ): Prisma__statusClient<
      $Result.GetResult<
        Prisma.$statusPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Status that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {statusFindUniqueOrThrowArgs} args - Arguments to find a Status
     * @example
     * // Get one Status
     * const status = await prisma.status.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends statusFindUniqueOrThrowArgs>(
      args: SelectSubset<T, statusFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__statusClient<
      $Result.GetResult<
        Prisma.$statusPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Status that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statusFindFirstArgs} args - Arguments to find a Status
     * @example
     * // Get one Status
     * const status = await prisma.status.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends statusFindFirstArgs>(
      args?: SelectSubset<T, statusFindFirstArgs<ExtArgs>>,
    ): Prisma__statusClient<
      $Result.GetResult<
        Prisma.$statusPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Status that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statusFindFirstOrThrowArgs} args - Arguments to find a Status
     * @example
     * // Get one Status
     * const status = await prisma.status.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends statusFindFirstOrThrowArgs>(
      args?: SelectSubset<T, statusFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__statusClient<
      $Result.GetResult<
        Prisma.$statusPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Statuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Statuses
     * const statuses = await prisma.status.findMany()
     *
     * // Get first 10 Statuses
     * const statuses = await prisma.status.findMany({ take: 10 })
     *
     * // Only select the `statusCode`
     * const statusWithStatusCodeOnly = await prisma.status.findMany({ select: { statusCode: true } })
     *
     */
    findMany<T extends statusFindManyArgs>(
      args?: SelectSubset<T, statusFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$statusPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Status.
     * @param {statusCreateArgs} args - Arguments to create a Status.
     * @example
     * // Create one Status
     * const Status = await prisma.status.create({
     *   data: {
     *     // ... data to create a Status
     *   }
     * })
     *
     */
    create<T extends statusCreateArgs>(
      args: SelectSubset<T, statusCreateArgs<ExtArgs>>,
    ): Prisma__statusClient<
      $Result.GetResult<
        Prisma.$statusPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Statuses.
     * @param {statusCreateManyArgs} args - Arguments to create many Statuses.
     * @example
     * // Create many Statuses
     * const status = await prisma.status.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends statusCreateManyArgs>(
      args?: SelectSubset<T, statusCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Statuses and returns the data saved in the database.
     * @param {statusCreateManyAndReturnArgs} args - Arguments to create many Statuses.
     * @example
     * // Create many Statuses
     * const status = await prisma.status.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Statuses and only return the `statusCode`
     * const statusWithStatusCodeOnly = await prisma.status.createManyAndReturn({
     *   select: { statusCode: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends statusCreateManyAndReturnArgs>(
      args?: SelectSubset<T, statusCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$statusPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Status.
     * @param {statusDeleteArgs} args - Arguments to delete one Status.
     * @example
     * // Delete one Status
     * const Status = await prisma.status.delete({
     *   where: {
     *     // ... filter to delete one Status
     *   }
     * })
     *
     */
    delete<T extends statusDeleteArgs>(
      args: SelectSubset<T, statusDeleteArgs<ExtArgs>>,
    ): Prisma__statusClient<
      $Result.GetResult<
        Prisma.$statusPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Status.
     * @param {statusUpdateArgs} args - Arguments to update one Status.
     * @example
     * // Update one Status
     * const status = await prisma.status.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends statusUpdateArgs>(
      args: SelectSubset<T, statusUpdateArgs<ExtArgs>>,
    ): Prisma__statusClient<
      $Result.GetResult<
        Prisma.$statusPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Statuses.
     * @param {statusDeleteManyArgs} args - Arguments to filter Statuses to delete.
     * @example
     * // Delete a few Statuses
     * const { count } = await prisma.status.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends statusDeleteManyArgs>(
      args?: SelectSubset<T, statusDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Statuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Statuses
     * const status = await prisma.status.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends statusUpdateManyArgs>(
      args: SelectSubset<T, statusUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Statuses and returns the data updated in the database.
     * @param {statusUpdateManyAndReturnArgs} args - Arguments to update many Statuses.
     * @example
     * // Update many Statuses
     * const status = await prisma.status.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Statuses and only return the `statusCode`
     * const statusWithStatusCodeOnly = await prisma.status.updateManyAndReturn({
     *   select: { statusCode: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends statusUpdateManyAndReturnArgs>(
      args: SelectSubset<T, statusUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$statusPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Status.
     * @param {statusUpsertArgs} args - Arguments to update or create a Status.
     * @example
     * // Update or create a Status
     * const status = await prisma.status.upsert({
     *   create: {
     *     // ... data to create a Status
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Status we want to update
     *   }
     * })
     */
    upsert<T extends statusUpsertArgs>(
      args: SelectSubset<T, statusUpsertArgs<ExtArgs>>,
    ): Prisma__statusClient<
      $Result.GetResult<
        Prisma.$statusPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Statuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statusCountArgs} args - Arguments to filter Statuses to count.
     * @example
     * // Count the number of Statuses
     * const count = await prisma.status.count({
     *   where: {
     *     // ... the filter for the Statuses we want to count
     *   }
     * })
     **/
    count<T extends statusCountArgs>(
      args?: Subset<T, statusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], StatusCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Status.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends StatusAggregateArgs>(
      args: Subset<T, StatusAggregateArgs>,
    ): Prisma.PrismaPromise<GetStatusAggregateType<T>>;

    /**
     * Group by Status.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends statusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: statusGroupByArgs["orderBy"] }
        : { orderBy?: statusGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, statusGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetStatusGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the status model
     */
    readonly fields: statusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for status.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__statusClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    users<T extends status$usersArgs<ExtArgs> = {}>(
      args?: Subset<T, status$usersArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$usersPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    audios<T extends status$audiosArgs<ExtArgs> = {}>(
      args?: Subset<T, status$audiosArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$audioPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    exhibits<T extends status$exhibitsArgs<ExtArgs> = {}>(
      args?: Subset<T, status$exhibitsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$exhibitPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    phoneNumbers<T extends status$phoneNumbersArgs<ExtArgs> = {}>(
      args?: Subset<T, status$phoneNumbersArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$phoneNumberPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    emails<T extends status$emailsArgs<ExtArgs> = {}>(
      args?: Subset<T, status$emailsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$emailPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    roles<T extends status$rolesArgs<ExtArgs> = {}>(
      args?: Subset<T, status$rolesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$rolePayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    qrcodes<T extends status$qrcodesArgs<ExtArgs> = {}>(
      args?: Subset<T, status$qrcodesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$qrCodePayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    images<T extends status$imagesArgs<ExtArgs> = {}>(
      args?: Subset<T, status$imagesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$imagePayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    subtitles<T extends status$subtitlesArgs<ExtArgs> = {}>(
      args?: Subset<T, status$subtitlesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$subtitlePayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    languages<T extends status$languagesArgs<ExtArgs> = {}>(
      args?: Subset<T, status$languagesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$languagePayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    auditLogs<T extends status$auditLogsArgs<ExtArgs> = {}>(
      args?: Subset<T, status$auditLogsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$auditLogPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    userProfiles<T extends status$userProfilesArgs<ExtArgs> = {}>(
      args?: Subset<T, status$userProfilesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$userProfilePayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the status model
   */
  interface statusFieldRefs {
    readonly statusCode: FieldRef<"status", "String">;
    readonly description: FieldRef<"status", "String">;
  }

  // Custom InputTypes
  /**
   * status findUnique
   */
  export type statusFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the status
     */
    select?: statusSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the status
     */
    omit?: statusOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusInclude<ExtArgs> | null;
    /**
     * Filter, which status to fetch.
     */
    where: statusWhereUniqueInput;
  };

  /**
   * status findUniqueOrThrow
   */
  export type statusFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the status
     */
    select?: statusSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the status
     */
    omit?: statusOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusInclude<ExtArgs> | null;
    /**
     * Filter, which status to fetch.
     */
    where: statusWhereUniqueInput;
  };

  /**
   * status findFirst
   */
  export type statusFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the status
     */
    select?: statusSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the status
     */
    omit?: statusOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusInclude<ExtArgs> | null;
    /**
     * Filter, which status to fetch.
     */
    where?: statusWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of statuses to fetch.
     */
    orderBy?: statusOrderByWithRelationInput | statusOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for statuses.
     */
    cursor?: statusWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` statuses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` statuses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of statuses.
     */
    distinct?: StatusScalarFieldEnum | StatusScalarFieldEnum[];
  };

  /**
   * status findFirstOrThrow
   */
  export type statusFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the status
     */
    select?: statusSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the status
     */
    omit?: statusOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusInclude<ExtArgs> | null;
    /**
     * Filter, which status to fetch.
     */
    where?: statusWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of statuses to fetch.
     */
    orderBy?: statusOrderByWithRelationInput | statusOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for statuses.
     */
    cursor?: statusWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` statuses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` statuses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of statuses.
     */
    distinct?: StatusScalarFieldEnum | StatusScalarFieldEnum[];
  };

  /**
   * status findMany
   */
  export type statusFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the status
     */
    select?: statusSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the status
     */
    omit?: statusOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusInclude<ExtArgs> | null;
    /**
     * Filter, which statuses to fetch.
     */
    where?: statusWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of statuses to fetch.
     */
    orderBy?: statusOrderByWithRelationInput | statusOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing statuses.
     */
    cursor?: statusWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` statuses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` statuses.
     */
    skip?: number;
    distinct?: StatusScalarFieldEnum | StatusScalarFieldEnum[];
  };

  /**
   * status create
   */
  export type statusCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the status
     */
    select?: statusSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the status
     */
    omit?: statusOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusInclude<ExtArgs> | null;
    /**
     * The data needed to create a status.
     */
    data: XOR<statusCreateInput, statusUncheckedCreateInput>;
  };

  /**
   * status createMany
   */
  export type statusCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many statuses.
     */
    data: statusCreateManyInput | statusCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * status createManyAndReturn
   */
  export type statusCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the status
     */
    select?: statusSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the status
     */
    omit?: statusOmit<ExtArgs> | null;
    /**
     * The data used to create many statuses.
     */
    data: statusCreateManyInput | statusCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * status update
   */
  export type statusUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the status
     */
    select?: statusSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the status
     */
    omit?: statusOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusInclude<ExtArgs> | null;
    /**
     * The data needed to update a status.
     */
    data: XOR<statusUpdateInput, statusUncheckedUpdateInput>;
    /**
     * Choose, which status to update.
     */
    where: statusWhereUniqueInput;
  };

  /**
   * status updateMany
   */
  export type statusUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update statuses.
     */
    data: XOR<statusUpdateManyMutationInput, statusUncheckedUpdateManyInput>;
    /**
     * Filter which statuses to update
     */
    where?: statusWhereInput;
    /**
     * Limit how many statuses to update.
     */
    limit?: number;
  };

  /**
   * status updateManyAndReturn
   */
  export type statusUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the status
     */
    select?: statusSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the status
     */
    omit?: statusOmit<ExtArgs> | null;
    /**
     * The data used to update statuses.
     */
    data: XOR<statusUpdateManyMutationInput, statusUncheckedUpdateManyInput>;
    /**
     * Filter which statuses to update
     */
    where?: statusWhereInput;
    /**
     * Limit how many statuses to update.
     */
    limit?: number;
  };

  /**
   * status upsert
   */
  export type statusUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the status
     */
    select?: statusSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the status
     */
    omit?: statusOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusInclude<ExtArgs> | null;
    /**
     * The filter to search for the status to update in case it exists.
     */
    where: statusWhereUniqueInput;
    /**
     * In case the status found by the `where` argument doesn't exist, create a new status with this data.
     */
    create: XOR<statusCreateInput, statusUncheckedCreateInput>;
    /**
     * In case the status was found with the provided `where` argument, update it with this data.
     */
    update: XOR<statusUpdateInput, statusUncheckedUpdateInput>;
  };

  /**
   * status delete
   */
  export type statusDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the status
     */
    select?: statusSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the status
     */
    omit?: statusOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusInclude<ExtArgs> | null;
    /**
     * Filter which status to delete.
     */
    where: statusWhereUniqueInput;
  };

  /**
   * status deleteMany
   */
  export type statusDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which statuses to delete
     */
    where?: statusWhereInput;
    /**
     * Limit how many statuses to delete.
     */
    limit?: number;
  };

  /**
   * status.users
   */
  export type status$usersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null;
    where?: usersWhereInput;
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[];
    cursor?: usersWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[];
  };

  /**
   * status.audios
   */
  export type status$audiosArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the audio
     */
    select?: audioSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the audio
     */
    omit?: audioOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audioInclude<ExtArgs> | null;
    where?: audioWhereInput;
    orderBy?: audioOrderByWithRelationInput | audioOrderByWithRelationInput[];
    cursor?: audioWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AudioScalarFieldEnum | AudioScalarFieldEnum[];
  };

  /**
   * status.exhibits
   */
  export type status$exhibitsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the exhibit
     */
    select?: exhibitSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the exhibit
     */
    omit?: exhibitOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exhibitInclude<ExtArgs> | null;
    where?: exhibitWhereInput;
    orderBy?:
      | exhibitOrderByWithRelationInput
      | exhibitOrderByWithRelationInput[];
    cursor?: exhibitWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ExhibitScalarFieldEnum | ExhibitScalarFieldEnum[];
  };

  /**
   * status.phoneNumbers
   */
  export type status$phoneNumbersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the phoneNumber
     */
    select?: phoneNumberSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the phoneNumber
     */
    omit?: phoneNumberOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: phoneNumberInclude<ExtArgs> | null;
    where?: phoneNumberWhereInput;
    orderBy?:
      | phoneNumberOrderByWithRelationInput
      | phoneNumberOrderByWithRelationInput[];
    cursor?: phoneNumberWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: PhoneNumberScalarFieldEnum | PhoneNumberScalarFieldEnum[];
  };

  /**
   * status.emails
   */
  export type status$emailsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the email
     */
    select?: emailSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the email
     */
    omit?: emailOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: emailInclude<ExtArgs> | null;
    where?: emailWhereInput;
    orderBy?: emailOrderByWithRelationInput | emailOrderByWithRelationInput[];
    cursor?: emailWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: EmailScalarFieldEnum | EmailScalarFieldEnum[];
  };

  /**
   * status.roles
   */
  export type status$rolesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null;
    where?: roleWhereInput;
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[];
    cursor?: roleWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[];
  };

  /**
   * status.qrcodes
   */
  export type status$qrcodesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the qrCode
     */
    select?: qrCodeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the qrCode
     */
    omit?: qrCodeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qrCodeInclude<ExtArgs> | null;
    where?: qrCodeWhereInput;
    orderBy?: qrCodeOrderByWithRelationInput | qrCodeOrderByWithRelationInput[];
    cursor?: qrCodeWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: QrCodeScalarFieldEnum | QrCodeScalarFieldEnum[];
  };

  /**
   * status.images
   */
  export type status$imagesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the image
     */
    select?: imageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the image
     */
    omit?: imageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: imageInclude<ExtArgs> | null;
    where?: imageWhereInput;
    orderBy?: imageOrderByWithRelationInput | imageOrderByWithRelationInput[];
    cursor?: imageWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[];
  };

  /**
   * status.subtitles
   */
  export type status$subtitlesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the subtitle
     */
    select?: subtitleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the subtitle
     */
    omit?: subtitleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subtitleInclude<ExtArgs> | null;
    where?: subtitleWhereInput;
    orderBy?:
      | subtitleOrderByWithRelationInput
      | subtitleOrderByWithRelationInput[];
    cursor?: subtitleWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: SubtitleScalarFieldEnum | SubtitleScalarFieldEnum[];
  };

  /**
   * status.languages
   */
  export type status$languagesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the language
     */
    select?: languageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the language
     */
    omit?: languageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: languageInclude<ExtArgs> | null;
    where?: languageWhereInput;
    orderBy?:
      | languageOrderByWithRelationInput
      | languageOrderByWithRelationInput[];
    cursor?: languageWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[];
  };

  /**
   * status.auditLogs
   */
  export type status$auditLogsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the auditLog
     */
    select?: auditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the auditLog
     */
    omit?: auditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditLogInclude<ExtArgs> | null;
    where?: auditLogWhereInput;
    orderBy?:
      | auditLogOrderByWithRelationInput
      | auditLogOrderByWithRelationInput[];
    cursor?: auditLogWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[];
  };

  /**
   * status.userProfiles
   */
  export type status$userProfilesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the userProfile
     */
    select?: userProfileSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the userProfile
     */
    omit?: userProfileOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userProfileInclude<ExtArgs> | null;
    where?: userProfileWhereInput;
    orderBy?:
      | userProfileOrderByWithRelationInput
      | userProfileOrderByWithRelationInput[];
    cursor?: userProfileWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[];
  };

  /**
   * status without action
   */
  export type statusDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the status
     */
    select?: statusSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the status
     */
    omit?: statusOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statusInclude<ExtArgs> | null;
  };

  /**
   * Model audio
   */

  export type AggregateAudio = {
    _count: AudioCountAggregateOutputType | null;
    _min: AudioMinAggregateOutputType | null;
    _max: AudioMaxAggregateOutputType | null;
  };

  export type AudioMinAggregateOutputType = {
    audioId: string | null;
    fileUrl: string | null;
    description: string | null;
    createdBy: string | null;
    languageId: string | null;
    createdAt: Date | null;
    statusCode: string | null;
  };

  export type AudioMaxAggregateOutputType = {
    audioId: string | null;
    fileUrl: string | null;
    description: string | null;
    createdBy: string | null;
    languageId: string | null;
    createdAt: Date | null;
    statusCode: string | null;
  };

  export type AudioCountAggregateOutputType = {
    audioId: number;
    fileUrl: number;
    description: number;
    createdBy: number;
    languageId: number;
    createdAt: number;
    statusCode: number;
    _all: number;
  };

  export type AudioMinAggregateInputType = {
    audioId?: true;
    fileUrl?: true;
    description?: true;
    createdBy?: true;
    languageId?: true;
    createdAt?: true;
    statusCode?: true;
  };

  export type AudioMaxAggregateInputType = {
    audioId?: true;
    fileUrl?: true;
    description?: true;
    createdBy?: true;
    languageId?: true;
    createdAt?: true;
    statusCode?: true;
  };

  export type AudioCountAggregateInputType = {
    audioId?: true;
    fileUrl?: true;
    description?: true;
    createdBy?: true;
    languageId?: true;
    createdAt?: true;
    statusCode?: true;
    _all?: true;
  };

  export type AudioAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which audio to aggregate.
     */
    where?: audioWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of audio to fetch.
     */
    orderBy?: audioOrderByWithRelationInput | audioOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: audioWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` audio from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` audio.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned audio
     **/
    _count?: true | AudioCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AudioMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AudioMaxAggregateInputType;
  };

  export type GetAudioAggregateType<T extends AudioAggregateArgs> = {
    [P in keyof T & keyof AggregateAudio]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAudio[P]>
      : GetScalarType<T[P], AggregateAudio[P]>;
  };

  export type audioGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: audioWhereInput;
    orderBy?:
      | audioOrderByWithAggregationInput
      | audioOrderByWithAggregationInput[];
    by: AudioScalarFieldEnum[] | AudioScalarFieldEnum;
    having?: audioScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AudioCountAggregateInputType | true;
    _min?: AudioMinAggregateInputType;
    _max?: AudioMaxAggregateInputType;
  };

  export type AudioGroupByOutputType = {
    audioId: string;
    fileUrl: string;
    description: string;
    createdBy: string;
    languageId: string;
    createdAt: Date;
    statusCode: string;
    _count: AudioCountAggregateOutputType | null;
    _min: AudioMinAggregateOutputType | null;
    _max: AudioMaxAggregateOutputType | null;
  };

  type GetAudioGroupByPayload<T extends audioGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<AudioGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof AudioGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AudioGroupByOutputType[P]>
            : GetScalarType<T[P], AudioGroupByOutputType[P]>;
        }
      >
    >;

  export type audioSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      audioId?: boolean;
      fileUrl?: boolean;
      description?: boolean;
      createdBy?: boolean;
      languageId?: boolean;
      createdAt?: boolean;
      statusCode?: boolean;
      language?: boolean | languageDefaultArgs<ExtArgs>;
      status?: boolean | statusDefaultArgs<ExtArgs>;
      exhibits?: boolean | audio$exhibitsArgs<ExtArgs>;
      exhibit?: boolean | audio$exhibitArgs<ExtArgs>;
      _count?: boolean | AudioCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["audio"]
  >;

  export type audioSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      audioId?: boolean;
      fileUrl?: boolean;
      description?: boolean;
      createdBy?: boolean;
      languageId?: boolean;
      createdAt?: boolean;
      statusCode?: boolean;
      language?: boolean | languageDefaultArgs<ExtArgs>;
      status?: boolean | statusDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["audio"]
  >;

  export type audioSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      audioId?: boolean;
      fileUrl?: boolean;
      description?: boolean;
      createdBy?: boolean;
      languageId?: boolean;
      createdAt?: boolean;
      statusCode?: boolean;
      language?: boolean | languageDefaultArgs<ExtArgs>;
      status?: boolean | statusDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["audio"]
  >;

  export type audioSelectScalar = {
    audioId?: boolean;
    fileUrl?: boolean;
    description?: boolean;
    createdBy?: boolean;
    languageId?: boolean;
    createdAt?: boolean;
    statusCode?: boolean;
  };

  export type audioOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "audioId"
    | "fileUrl"
    | "description"
    | "createdBy"
    | "languageId"
    | "createdAt"
    | "statusCode",
    ExtArgs["result"]["audio"]
  >;
  export type audioInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    language?: boolean | languageDefaultArgs<ExtArgs>;
    status?: boolean | statusDefaultArgs<ExtArgs>;
    exhibits?: boolean | audio$exhibitsArgs<ExtArgs>;
    exhibit?: boolean | audio$exhibitArgs<ExtArgs>;
    _count?: boolean | AudioCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type audioIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    language?: boolean | languageDefaultArgs<ExtArgs>;
    status?: boolean | statusDefaultArgs<ExtArgs>;
  };
  export type audioIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    language?: boolean | languageDefaultArgs<ExtArgs>;
    status?: boolean | statusDefaultArgs<ExtArgs>;
  };

  export type $audioPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "audio";
    objects: {
      language: Prisma.$languagePayload<ExtArgs>;
      status: Prisma.$statusPayload<ExtArgs>;
      exhibits: Prisma.$exhibitAudioRelationPayload<ExtArgs>[];
      exhibit: Prisma.$exhibitPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        audioId: string;
        fileUrl: string;
        description: string;
        createdBy: string;
        languageId: string;
        createdAt: Date;
        statusCode: string;
      },
      ExtArgs["result"]["audio"]
    >;
    composites: {};
  };

  type audioGetPayload<
    S extends boolean | null | undefined | audioDefaultArgs,
  > = $Result.GetResult<Prisma.$audioPayload, S>;

  type audioCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<audioFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: AudioCountAggregateInputType | true;
  };

  export interface audioDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["audio"];
      meta: { name: "audio" };
    };
    /**
     * Find zero or one Audio that matches the filter.
     * @param {audioFindUniqueArgs} args - Arguments to find a Audio
     * @example
     * // Get one Audio
     * const audio = await prisma.audio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends audioFindUniqueArgs>(
      args: SelectSubset<T, audioFindUniqueArgs<ExtArgs>>,
    ): Prisma__audioClient<
      $Result.GetResult<
        Prisma.$audioPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Audio that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {audioFindUniqueOrThrowArgs} args - Arguments to find a Audio
     * @example
     * // Get one Audio
     * const audio = await prisma.audio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends audioFindUniqueOrThrowArgs>(
      args: SelectSubset<T, audioFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__audioClient<
      $Result.GetResult<
        Prisma.$audioPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Audio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audioFindFirstArgs} args - Arguments to find a Audio
     * @example
     * // Get one Audio
     * const audio = await prisma.audio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends audioFindFirstArgs>(
      args?: SelectSubset<T, audioFindFirstArgs<ExtArgs>>,
    ): Prisma__audioClient<
      $Result.GetResult<
        Prisma.$audioPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Audio that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audioFindFirstOrThrowArgs} args - Arguments to find a Audio
     * @example
     * // Get one Audio
     * const audio = await prisma.audio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends audioFindFirstOrThrowArgs>(
      args?: SelectSubset<T, audioFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__audioClient<
      $Result.GetResult<
        Prisma.$audioPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Audio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Audio
     * const audio = await prisma.audio.findMany()
     *
     * // Get first 10 Audio
     * const audio = await prisma.audio.findMany({ take: 10 })
     *
     * // Only select the `audioId`
     * const audioWithAudioIdOnly = await prisma.audio.findMany({ select: { audioId: true } })
     *
     */
    findMany<T extends audioFindManyArgs>(
      args?: SelectSubset<T, audioFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$audioPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Audio.
     * @param {audioCreateArgs} args - Arguments to create a Audio.
     * @example
     * // Create one Audio
     * const Audio = await prisma.audio.create({
     *   data: {
     *     // ... data to create a Audio
     *   }
     * })
     *
     */
    create<T extends audioCreateArgs>(
      args: SelectSubset<T, audioCreateArgs<ExtArgs>>,
    ): Prisma__audioClient<
      $Result.GetResult<
        Prisma.$audioPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Audio.
     * @param {audioCreateManyArgs} args - Arguments to create many Audio.
     * @example
     * // Create many Audio
     * const audio = await prisma.audio.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends audioCreateManyArgs>(
      args?: SelectSubset<T, audioCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Audio and returns the data saved in the database.
     * @param {audioCreateManyAndReturnArgs} args - Arguments to create many Audio.
     * @example
     * // Create many Audio
     * const audio = await prisma.audio.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Audio and only return the `audioId`
     * const audioWithAudioIdOnly = await prisma.audio.createManyAndReturn({
     *   select: { audioId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends audioCreateManyAndReturnArgs>(
      args?: SelectSubset<T, audioCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$audioPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Audio.
     * @param {audioDeleteArgs} args - Arguments to delete one Audio.
     * @example
     * // Delete one Audio
     * const Audio = await prisma.audio.delete({
     *   where: {
     *     // ... filter to delete one Audio
     *   }
     * })
     *
     */
    delete<T extends audioDeleteArgs>(
      args: SelectSubset<T, audioDeleteArgs<ExtArgs>>,
    ): Prisma__audioClient<
      $Result.GetResult<
        Prisma.$audioPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Audio.
     * @param {audioUpdateArgs} args - Arguments to update one Audio.
     * @example
     * // Update one Audio
     * const audio = await prisma.audio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends audioUpdateArgs>(
      args: SelectSubset<T, audioUpdateArgs<ExtArgs>>,
    ): Prisma__audioClient<
      $Result.GetResult<
        Prisma.$audioPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Audio.
     * @param {audioDeleteManyArgs} args - Arguments to filter Audio to delete.
     * @example
     * // Delete a few Audio
     * const { count } = await prisma.audio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends audioDeleteManyArgs>(
      args?: SelectSubset<T, audioDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Audio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Audio
     * const audio = await prisma.audio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends audioUpdateManyArgs>(
      args: SelectSubset<T, audioUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Audio and returns the data updated in the database.
     * @param {audioUpdateManyAndReturnArgs} args - Arguments to update many Audio.
     * @example
     * // Update many Audio
     * const audio = await prisma.audio.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Audio and only return the `audioId`
     * const audioWithAudioIdOnly = await prisma.audio.updateManyAndReturn({
     *   select: { audioId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends audioUpdateManyAndReturnArgs>(
      args: SelectSubset<T, audioUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$audioPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Audio.
     * @param {audioUpsertArgs} args - Arguments to update or create a Audio.
     * @example
     * // Update or create a Audio
     * const audio = await prisma.audio.upsert({
     *   create: {
     *     // ... data to create a Audio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Audio we want to update
     *   }
     * })
     */
    upsert<T extends audioUpsertArgs>(
      args: SelectSubset<T, audioUpsertArgs<ExtArgs>>,
    ): Prisma__audioClient<
      $Result.GetResult<
        Prisma.$audioPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Audio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audioCountArgs} args - Arguments to filter Audio to count.
     * @example
     * // Count the number of Audio
     * const count = await prisma.audio.count({
     *   where: {
     *     // ... the filter for the Audio we want to count
     *   }
     * })
     **/
    count<T extends audioCountArgs>(
      args?: Subset<T, audioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], AudioCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Audio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AudioAggregateArgs>(
      args: Subset<T, AudioAggregateArgs>,
    ): Prisma.PrismaPromise<GetAudioAggregateType<T>>;

    /**
     * Group by Audio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {audioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends audioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: audioGroupByArgs["orderBy"] }
        : { orderBy?: audioGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, audioGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetAudioGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the audio model
     */
    readonly fields: audioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for audio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__audioClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    language<T extends languageDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, languageDefaultArgs<ExtArgs>>,
    ): Prisma__languageClient<
      | $Result.GetResult<
          Prisma.$languagePayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    status<T extends statusDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, statusDefaultArgs<ExtArgs>>,
    ): Prisma__statusClient<
      | $Result.GetResult<
          Prisma.$statusPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    exhibits<T extends audio$exhibitsArgs<ExtArgs> = {}>(
      args?: Subset<T, audio$exhibitsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$exhibitAudioRelationPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    exhibit<T extends audio$exhibitArgs<ExtArgs> = {}>(
      args?: Subset<T, audio$exhibitArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$exhibitPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the audio model
   */
  interface audioFieldRefs {
    readonly audioId: FieldRef<"audio", "String">;
    readonly fileUrl: FieldRef<"audio", "String">;
    readonly description: FieldRef<"audio", "String">;
    readonly createdBy: FieldRef<"audio", "String">;
    readonly languageId: FieldRef<"audio", "String">;
    readonly createdAt: FieldRef<"audio", "DateTime">;
    readonly statusCode: FieldRef<"audio", "String">;
  }

  // Custom InputTypes
  /**
   * audio findUnique
   */
  export type audioFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the audio
     */
    select?: audioSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the audio
     */
    omit?: audioOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audioInclude<ExtArgs> | null;
    /**
     * Filter, which audio to fetch.
     */
    where: audioWhereUniqueInput;
  };

  /**
   * audio findUniqueOrThrow
   */
  export type audioFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the audio
     */
    select?: audioSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the audio
     */
    omit?: audioOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audioInclude<ExtArgs> | null;
    /**
     * Filter, which audio to fetch.
     */
    where: audioWhereUniqueInput;
  };

  /**
   * audio findFirst
   */
  export type audioFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the audio
     */
    select?: audioSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the audio
     */
    omit?: audioOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audioInclude<ExtArgs> | null;
    /**
     * Filter, which audio to fetch.
     */
    where?: audioWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of audio to fetch.
     */
    orderBy?: audioOrderByWithRelationInput | audioOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for audio.
     */
    cursor?: audioWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` audio from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` audio.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of audio.
     */
    distinct?: AudioScalarFieldEnum | AudioScalarFieldEnum[];
  };

  /**
   * audio findFirstOrThrow
   */
  export type audioFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the audio
     */
    select?: audioSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the audio
     */
    omit?: audioOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audioInclude<ExtArgs> | null;
    /**
     * Filter, which audio to fetch.
     */
    where?: audioWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of audio to fetch.
     */
    orderBy?: audioOrderByWithRelationInput | audioOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for audio.
     */
    cursor?: audioWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` audio from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` audio.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of audio.
     */
    distinct?: AudioScalarFieldEnum | AudioScalarFieldEnum[];
  };

  /**
   * audio findMany
   */
  export type audioFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the audio
     */
    select?: audioSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the audio
     */
    omit?: audioOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audioInclude<ExtArgs> | null;
    /**
     * Filter, which audio to fetch.
     */
    where?: audioWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of audio to fetch.
     */
    orderBy?: audioOrderByWithRelationInput | audioOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing audio.
     */
    cursor?: audioWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` audio from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` audio.
     */
    skip?: number;
    distinct?: AudioScalarFieldEnum | AudioScalarFieldEnum[];
  };

  /**
   * audio create
   */
  export type audioCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the audio
     */
    select?: audioSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the audio
     */
    omit?: audioOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audioInclude<ExtArgs> | null;
    /**
     * The data needed to create a audio.
     */
    data: XOR<audioCreateInput, audioUncheckedCreateInput>;
  };

  /**
   * audio createMany
   */
  export type audioCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many audio.
     */
    data: audioCreateManyInput | audioCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * audio createManyAndReturn
   */
  export type audioCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the audio
     */
    select?: audioSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the audio
     */
    omit?: audioOmit<ExtArgs> | null;
    /**
     * The data used to create many audio.
     */
    data: audioCreateManyInput | audioCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audioIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * audio update
   */
  export type audioUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the audio
     */
    select?: audioSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the audio
     */
    omit?: audioOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audioInclude<ExtArgs> | null;
    /**
     * The data needed to update a audio.
     */
    data: XOR<audioUpdateInput, audioUncheckedUpdateInput>;
    /**
     * Choose, which audio to update.
     */
    where: audioWhereUniqueInput;
  };

  /**
   * audio updateMany
   */
  export type audioUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update audio.
     */
    data: XOR<audioUpdateManyMutationInput, audioUncheckedUpdateManyInput>;
    /**
     * Filter which audio to update
     */
    where?: audioWhereInput;
    /**
     * Limit how many audio to update.
     */
    limit?: number;
  };

  /**
   * audio updateManyAndReturn
   */
  export type audioUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the audio
     */
    select?: audioSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the audio
     */
    omit?: audioOmit<ExtArgs> | null;
    /**
     * The data used to update audio.
     */
    data: XOR<audioUpdateManyMutationInput, audioUncheckedUpdateManyInput>;
    /**
     * Filter which audio to update
     */
    where?: audioWhereInput;
    /**
     * Limit how many audio to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audioIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * audio upsert
   */
  export type audioUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the audio
     */
    select?: audioSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the audio
     */
    omit?: audioOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audioInclude<ExtArgs> | null;
    /**
     * The filter to search for the audio to update in case it exists.
     */
    where: audioWhereUniqueInput;
    /**
     * In case the audio found by the `where` argument doesn't exist, create a new audio with this data.
     */
    create: XOR<audioCreateInput, audioUncheckedCreateInput>;
    /**
     * In case the audio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<audioUpdateInput, audioUncheckedUpdateInput>;
  };

  /**
   * audio delete
   */
  export type audioDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the audio
     */
    select?: audioSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the audio
     */
    omit?: audioOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audioInclude<ExtArgs> | null;
    /**
     * Filter which audio to delete.
     */
    where: audioWhereUniqueInput;
  };

  /**
   * audio deleteMany
   */
  export type audioDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which audio to delete
     */
    where?: audioWhereInput;
    /**
     * Limit how many audio to delete.
     */
    limit?: number;
  };

  /**
   * audio.exhibits
   */
  export type audio$exhibitsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the exhibitAudioRelation
     */
    select?: exhibitAudioRelationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the exhibitAudioRelation
     */
    omit?: exhibitAudioRelationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exhibitAudioRelationInclude<ExtArgs> | null;
    where?: exhibitAudioRelationWhereInput;
    orderBy?:
      | exhibitAudioRelationOrderByWithRelationInput
      | exhibitAudioRelationOrderByWithRelationInput[];
    cursor?: exhibitAudioRelationWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | ExhibitAudioRelationScalarFieldEnum
      | ExhibitAudioRelationScalarFieldEnum[];
  };

  /**
   * audio.exhibit
   */
  export type audio$exhibitArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the exhibit
     */
    select?: exhibitSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the exhibit
     */
    omit?: exhibitOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exhibitInclude<ExtArgs> | null;
    where?: exhibitWhereInput;
    orderBy?:
      | exhibitOrderByWithRelationInput
      | exhibitOrderByWithRelationInput[];
    cursor?: exhibitWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ExhibitScalarFieldEnum | ExhibitScalarFieldEnum[];
  };

  /**
   * audio without action
   */
  export type audioDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the audio
     */
    select?: audioSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the audio
     */
    omit?: audioOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audioInclude<ExtArgs> | null;
  };

  /**
   * Model exhibitAudioRelation
   */

  export type AggregateExhibitAudioRelation = {
    _count: ExhibitAudioRelationCountAggregateOutputType | null;
    _min: ExhibitAudioRelationMinAggregateOutputType | null;
    _max: ExhibitAudioRelationMaxAggregateOutputType | null;
  };

  export type ExhibitAudioRelationMinAggregateOutputType = {
    audioId: string | null;
    exhibitId: string | null;
  };

  export type ExhibitAudioRelationMaxAggregateOutputType = {
    audioId: string | null;
    exhibitId: string | null;
  };

  export type ExhibitAudioRelationCountAggregateOutputType = {
    audioId: number;
    exhibitId: number;
    _all: number;
  };

  export type ExhibitAudioRelationMinAggregateInputType = {
    audioId?: true;
    exhibitId?: true;
  };

  export type ExhibitAudioRelationMaxAggregateInputType = {
    audioId?: true;
    exhibitId?: true;
  };

  export type ExhibitAudioRelationCountAggregateInputType = {
    audioId?: true;
    exhibitId?: true;
    _all?: true;
  };

  export type ExhibitAudioRelationAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which exhibitAudioRelation to aggregate.
     */
    where?: exhibitAudioRelationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of exhibitAudioRelations to fetch.
     */
    orderBy?:
      | exhibitAudioRelationOrderByWithRelationInput
      | exhibitAudioRelationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: exhibitAudioRelationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` exhibitAudioRelations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` exhibitAudioRelations.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned exhibitAudioRelations
     **/
    _count?: true | ExhibitAudioRelationCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ExhibitAudioRelationMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ExhibitAudioRelationMaxAggregateInputType;
  };

  export type GetExhibitAudioRelationAggregateType<
    T extends ExhibitAudioRelationAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateExhibitAudioRelation]: P extends
      | "_count"
      | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExhibitAudioRelation[P]>
      : GetScalarType<T[P], AggregateExhibitAudioRelation[P]>;
  };

  export type exhibitAudioRelationGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: exhibitAudioRelationWhereInput;
    orderBy?:
      | exhibitAudioRelationOrderByWithAggregationInput
      | exhibitAudioRelationOrderByWithAggregationInput[];
    by:
      | ExhibitAudioRelationScalarFieldEnum[]
      | ExhibitAudioRelationScalarFieldEnum;
    having?: exhibitAudioRelationScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ExhibitAudioRelationCountAggregateInputType | true;
    _min?: ExhibitAudioRelationMinAggregateInputType;
    _max?: ExhibitAudioRelationMaxAggregateInputType;
  };

  export type ExhibitAudioRelationGroupByOutputType = {
    audioId: string;
    exhibitId: string;
    _count: ExhibitAudioRelationCountAggregateOutputType | null;
    _min: ExhibitAudioRelationMinAggregateOutputType | null;
    _max: ExhibitAudioRelationMaxAggregateOutputType | null;
  };

  type GetExhibitAudioRelationGroupByPayload<
    T extends exhibitAudioRelationGroupByArgs,
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExhibitAudioRelationGroupByOutputType, T["by"]> & {
        [P in keyof T &
          keyof ExhibitAudioRelationGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], ExhibitAudioRelationGroupByOutputType[P]>
          : GetScalarType<T[P], ExhibitAudioRelationGroupByOutputType[P]>;
      }
    >
  >;

  export type exhibitAudioRelationSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      audioId?: boolean;
      exhibitId?: boolean;
      audio?: boolean | audioDefaultArgs<ExtArgs>;
      exhibit?: boolean | exhibitDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["exhibitAudioRelation"]
  >;

  export type exhibitAudioRelationSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      audioId?: boolean;
      exhibitId?: boolean;
      audio?: boolean | audioDefaultArgs<ExtArgs>;
      exhibit?: boolean | exhibitDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["exhibitAudioRelation"]
  >;

  export type exhibitAudioRelationSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      audioId?: boolean;
      exhibitId?: boolean;
      audio?: boolean | audioDefaultArgs<ExtArgs>;
      exhibit?: boolean | exhibitDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["exhibitAudioRelation"]
  >;

  export type exhibitAudioRelationSelectScalar = {
    audioId?: boolean;
    exhibitId?: boolean;
  };

  export type exhibitAudioRelationOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "audioId" | "exhibitId",
    ExtArgs["result"]["exhibitAudioRelation"]
  >;
  export type exhibitAudioRelationInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    audio?: boolean | audioDefaultArgs<ExtArgs>;
    exhibit?: boolean | exhibitDefaultArgs<ExtArgs>;
  };
  export type exhibitAudioRelationIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    audio?: boolean | audioDefaultArgs<ExtArgs>;
    exhibit?: boolean | exhibitDefaultArgs<ExtArgs>;
  };
  export type exhibitAudioRelationIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    audio?: boolean | audioDefaultArgs<ExtArgs>;
    exhibit?: boolean | exhibitDefaultArgs<ExtArgs>;
  };

  export type $exhibitAudioRelationPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "exhibitAudioRelation";
    objects: {
      audio: Prisma.$audioPayload<ExtArgs>;
      exhibit: Prisma.$exhibitPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        audioId: string;
        exhibitId: string;
      },
      ExtArgs["result"]["exhibitAudioRelation"]
    >;
    composites: {};
  };

  type exhibitAudioRelationGetPayload<
    S extends boolean | null | undefined | exhibitAudioRelationDefaultArgs,
  > = $Result.GetResult<Prisma.$exhibitAudioRelationPayload, S>;

  type exhibitAudioRelationCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    exhibitAudioRelationFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: ExhibitAudioRelationCountAggregateInputType | true;
  };

  export interface exhibitAudioRelationDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["exhibitAudioRelation"];
      meta: { name: "exhibitAudioRelation" };
    };
    /**
     * Find zero or one ExhibitAudioRelation that matches the filter.
     * @param {exhibitAudioRelationFindUniqueArgs} args - Arguments to find a ExhibitAudioRelation
     * @example
     * // Get one ExhibitAudioRelation
     * const exhibitAudioRelation = await prisma.exhibitAudioRelation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends exhibitAudioRelationFindUniqueArgs>(
      args: SelectSubset<T, exhibitAudioRelationFindUniqueArgs<ExtArgs>>,
    ): Prisma__exhibitAudioRelationClient<
      $Result.GetResult<
        Prisma.$exhibitAudioRelationPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one ExhibitAudioRelation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {exhibitAudioRelationFindUniqueOrThrowArgs} args - Arguments to find a ExhibitAudioRelation
     * @example
     * // Get one ExhibitAudioRelation
     * const exhibitAudioRelation = await prisma.exhibitAudioRelation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends exhibitAudioRelationFindUniqueOrThrowArgs>(
      args: SelectSubset<T, exhibitAudioRelationFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__exhibitAudioRelationClient<
      $Result.GetResult<
        Prisma.$exhibitAudioRelationPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ExhibitAudioRelation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exhibitAudioRelationFindFirstArgs} args - Arguments to find a ExhibitAudioRelation
     * @example
     * // Get one ExhibitAudioRelation
     * const exhibitAudioRelation = await prisma.exhibitAudioRelation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends exhibitAudioRelationFindFirstArgs>(
      args?: SelectSubset<T, exhibitAudioRelationFindFirstArgs<ExtArgs>>,
    ): Prisma__exhibitAudioRelationClient<
      $Result.GetResult<
        Prisma.$exhibitAudioRelationPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ExhibitAudioRelation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exhibitAudioRelationFindFirstOrThrowArgs} args - Arguments to find a ExhibitAudioRelation
     * @example
     * // Get one ExhibitAudioRelation
     * const exhibitAudioRelation = await prisma.exhibitAudioRelation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends exhibitAudioRelationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, exhibitAudioRelationFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__exhibitAudioRelationClient<
      $Result.GetResult<
        Prisma.$exhibitAudioRelationPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ExhibitAudioRelations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exhibitAudioRelationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExhibitAudioRelations
     * const exhibitAudioRelations = await prisma.exhibitAudioRelation.findMany()
     *
     * // Get first 10 ExhibitAudioRelations
     * const exhibitAudioRelations = await prisma.exhibitAudioRelation.findMany({ take: 10 })
     *
     * // Only select the `audioId`
     * const exhibitAudioRelationWithAudioIdOnly = await prisma.exhibitAudioRelation.findMany({ select: { audioId: true } })
     *
     */
    findMany<T extends exhibitAudioRelationFindManyArgs>(
      args?: SelectSubset<T, exhibitAudioRelationFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$exhibitAudioRelationPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a ExhibitAudioRelation.
     * @param {exhibitAudioRelationCreateArgs} args - Arguments to create a ExhibitAudioRelation.
     * @example
     * // Create one ExhibitAudioRelation
     * const ExhibitAudioRelation = await prisma.exhibitAudioRelation.create({
     *   data: {
     *     // ... data to create a ExhibitAudioRelation
     *   }
     * })
     *
     */
    create<T extends exhibitAudioRelationCreateArgs>(
      args: SelectSubset<T, exhibitAudioRelationCreateArgs<ExtArgs>>,
    ): Prisma__exhibitAudioRelationClient<
      $Result.GetResult<
        Prisma.$exhibitAudioRelationPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many ExhibitAudioRelations.
     * @param {exhibitAudioRelationCreateManyArgs} args - Arguments to create many ExhibitAudioRelations.
     * @example
     * // Create many ExhibitAudioRelations
     * const exhibitAudioRelation = await prisma.exhibitAudioRelation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends exhibitAudioRelationCreateManyArgs>(
      args?: SelectSubset<T, exhibitAudioRelationCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many ExhibitAudioRelations and returns the data saved in the database.
     * @param {exhibitAudioRelationCreateManyAndReturnArgs} args - Arguments to create many ExhibitAudioRelations.
     * @example
     * // Create many ExhibitAudioRelations
     * const exhibitAudioRelation = await prisma.exhibitAudioRelation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ExhibitAudioRelations and only return the `audioId`
     * const exhibitAudioRelationWithAudioIdOnly = await prisma.exhibitAudioRelation.createManyAndReturn({
     *   select: { audioId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends exhibitAudioRelationCreateManyAndReturnArgs>(
      args?: SelectSubset<
        T,
        exhibitAudioRelationCreateManyAndReturnArgs<ExtArgs>
      >,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$exhibitAudioRelationPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a ExhibitAudioRelation.
     * @param {exhibitAudioRelationDeleteArgs} args - Arguments to delete one ExhibitAudioRelation.
     * @example
     * // Delete one ExhibitAudioRelation
     * const ExhibitAudioRelation = await prisma.exhibitAudioRelation.delete({
     *   where: {
     *     // ... filter to delete one ExhibitAudioRelation
     *   }
     * })
     *
     */
    delete<T extends exhibitAudioRelationDeleteArgs>(
      args: SelectSubset<T, exhibitAudioRelationDeleteArgs<ExtArgs>>,
    ): Prisma__exhibitAudioRelationClient<
      $Result.GetResult<
        Prisma.$exhibitAudioRelationPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one ExhibitAudioRelation.
     * @param {exhibitAudioRelationUpdateArgs} args - Arguments to update one ExhibitAudioRelation.
     * @example
     * // Update one ExhibitAudioRelation
     * const exhibitAudioRelation = await prisma.exhibitAudioRelation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends exhibitAudioRelationUpdateArgs>(
      args: SelectSubset<T, exhibitAudioRelationUpdateArgs<ExtArgs>>,
    ): Prisma__exhibitAudioRelationClient<
      $Result.GetResult<
        Prisma.$exhibitAudioRelationPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more ExhibitAudioRelations.
     * @param {exhibitAudioRelationDeleteManyArgs} args - Arguments to filter ExhibitAudioRelations to delete.
     * @example
     * // Delete a few ExhibitAudioRelations
     * const { count } = await prisma.exhibitAudioRelation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends exhibitAudioRelationDeleteManyArgs>(
      args?: SelectSubset<T, exhibitAudioRelationDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ExhibitAudioRelations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exhibitAudioRelationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExhibitAudioRelations
     * const exhibitAudioRelation = await prisma.exhibitAudioRelation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends exhibitAudioRelationUpdateManyArgs>(
      args: SelectSubset<T, exhibitAudioRelationUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ExhibitAudioRelations and returns the data updated in the database.
     * @param {exhibitAudioRelationUpdateManyAndReturnArgs} args - Arguments to update many ExhibitAudioRelations.
     * @example
     * // Update many ExhibitAudioRelations
     * const exhibitAudioRelation = await prisma.exhibitAudioRelation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more ExhibitAudioRelations and only return the `audioId`
     * const exhibitAudioRelationWithAudioIdOnly = await prisma.exhibitAudioRelation.updateManyAndReturn({
     *   select: { audioId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends exhibitAudioRelationUpdateManyAndReturnArgs>(
      args: SelectSubset<
        T,
        exhibitAudioRelationUpdateManyAndReturnArgs<ExtArgs>
      >,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$exhibitAudioRelationPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one ExhibitAudioRelation.
     * @param {exhibitAudioRelationUpsertArgs} args - Arguments to update or create a ExhibitAudioRelation.
     * @example
     * // Update or create a ExhibitAudioRelation
     * const exhibitAudioRelation = await prisma.exhibitAudioRelation.upsert({
     *   create: {
     *     // ... data to create a ExhibitAudioRelation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExhibitAudioRelation we want to update
     *   }
     * })
     */
    upsert<T extends exhibitAudioRelationUpsertArgs>(
      args: SelectSubset<T, exhibitAudioRelationUpsertArgs<ExtArgs>>,
    ): Prisma__exhibitAudioRelationClient<
      $Result.GetResult<
        Prisma.$exhibitAudioRelationPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of ExhibitAudioRelations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exhibitAudioRelationCountArgs} args - Arguments to filter ExhibitAudioRelations to count.
     * @example
     * // Count the number of ExhibitAudioRelations
     * const count = await prisma.exhibitAudioRelation.count({
     *   where: {
     *     // ... the filter for the ExhibitAudioRelations we want to count
     *   }
     * })
     **/
    count<T extends exhibitAudioRelationCountArgs>(
      args?: Subset<T, exhibitAudioRelationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<
              T["select"],
              ExhibitAudioRelationCountAggregateOutputType
            >
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ExhibitAudioRelation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExhibitAudioRelationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ExhibitAudioRelationAggregateArgs>(
      args: Subset<T, ExhibitAudioRelationAggregateArgs>,
    ): Prisma.PrismaPromise<GetExhibitAudioRelationAggregateType<T>>;

    /**
     * Group by ExhibitAudioRelation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exhibitAudioRelationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends exhibitAudioRelationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: exhibitAudioRelationGroupByArgs["orderBy"] }
        : { orderBy?: exhibitAudioRelationGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, exhibitAudioRelationGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetExhibitAudioRelationGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the exhibitAudioRelation model
     */
    readonly fields: exhibitAudioRelationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for exhibitAudioRelation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__exhibitAudioRelationClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    audio<T extends audioDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, audioDefaultArgs<ExtArgs>>,
    ): Prisma__audioClient<
      | $Result.GetResult<
          Prisma.$audioPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    exhibit<T extends exhibitDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, exhibitDefaultArgs<ExtArgs>>,
    ): Prisma__exhibitClient<
      | $Result.GetResult<
          Prisma.$exhibitPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the exhibitAudioRelation model
   */
  interface exhibitAudioRelationFieldRefs {
    readonly audioId: FieldRef<"exhibitAudioRelation", "String">;
    readonly exhibitId: FieldRef<"exhibitAudioRelation", "String">;
  }

  // Custom InputTypes
  /**
   * exhibitAudioRelation findUnique
   */
  export type exhibitAudioRelationFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the exhibitAudioRelation
     */
    select?: exhibitAudioRelationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the exhibitAudioRelation
     */
    omit?: exhibitAudioRelationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exhibitAudioRelationInclude<ExtArgs> | null;
    /**
     * Filter, which exhibitAudioRelation to fetch.
     */
    where: exhibitAudioRelationWhereUniqueInput;
  };

  /**
   * exhibitAudioRelation findUniqueOrThrow
   */
  export type exhibitAudioRelationFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the exhibitAudioRelation
     */
    select?: exhibitAudioRelationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the exhibitAudioRelation
     */
    omit?: exhibitAudioRelationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exhibitAudioRelationInclude<ExtArgs> | null;
    /**
     * Filter, which exhibitAudioRelation to fetch.
     */
    where: exhibitAudioRelationWhereUniqueInput;
  };

  /**
   * exhibitAudioRelation findFirst
   */
  export type exhibitAudioRelationFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the exhibitAudioRelation
     */
    select?: exhibitAudioRelationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the exhibitAudioRelation
     */
    omit?: exhibitAudioRelationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exhibitAudioRelationInclude<ExtArgs> | null;
    /**
     * Filter, which exhibitAudioRelation to fetch.
     */
    where?: exhibitAudioRelationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of exhibitAudioRelations to fetch.
     */
    orderBy?:
      | exhibitAudioRelationOrderByWithRelationInput
      | exhibitAudioRelationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for exhibitAudioRelations.
     */
    cursor?: exhibitAudioRelationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` exhibitAudioRelations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` exhibitAudioRelations.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of exhibitAudioRelations.
     */
    distinct?:
      | ExhibitAudioRelationScalarFieldEnum
      | ExhibitAudioRelationScalarFieldEnum[];
  };

  /**
   * exhibitAudioRelation findFirstOrThrow
   */
  export type exhibitAudioRelationFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the exhibitAudioRelation
     */
    select?: exhibitAudioRelationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the exhibitAudioRelation
     */
    omit?: exhibitAudioRelationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exhibitAudioRelationInclude<ExtArgs> | null;
    /**
     * Filter, which exhibitAudioRelation to fetch.
     */
    where?: exhibitAudioRelationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of exhibitAudioRelations to fetch.
     */
    orderBy?:
      | exhibitAudioRelationOrderByWithRelationInput
      | exhibitAudioRelationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for exhibitAudioRelations.
     */
    cursor?: exhibitAudioRelationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` exhibitAudioRelations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` exhibitAudioRelations.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of exhibitAudioRelations.
     */
    distinct?:
      | ExhibitAudioRelationScalarFieldEnum
      | ExhibitAudioRelationScalarFieldEnum[];
  };

  /**
   * exhibitAudioRelation findMany
   */
  export type exhibitAudioRelationFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the exhibitAudioRelation
     */
    select?: exhibitAudioRelationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the exhibitAudioRelation
     */
    omit?: exhibitAudioRelationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exhibitAudioRelationInclude<ExtArgs> | null;
    /**
     * Filter, which exhibitAudioRelations to fetch.
     */
    where?: exhibitAudioRelationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of exhibitAudioRelations to fetch.
     */
    orderBy?:
      | exhibitAudioRelationOrderByWithRelationInput
      | exhibitAudioRelationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing exhibitAudioRelations.
     */
    cursor?: exhibitAudioRelationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` exhibitAudioRelations from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` exhibitAudioRelations.
     */
    skip?: number;
    distinct?:
      | ExhibitAudioRelationScalarFieldEnum
      | ExhibitAudioRelationScalarFieldEnum[];
  };

  /**
   * exhibitAudioRelation create
   */
  export type exhibitAudioRelationCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the exhibitAudioRelation
     */
    select?: exhibitAudioRelationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the exhibitAudioRelation
     */
    omit?: exhibitAudioRelationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exhibitAudioRelationInclude<ExtArgs> | null;
    /**
     * The data needed to create a exhibitAudioRelation.
     */
    data: XOR<
      exhibitAudioRelationCreateInput,
      exhibitAudioRelationUncheckedCreateInput
    >;
  };

  /**
   * exhibitAudioRelation createMany
   */
  export type exhibitAudioRelationCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many exhibitAudioRelations.
     */
    data:
      | exhibitAudioRelationCreateManyInput
      | exhibitAudioRelationCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * exhibitAudioRelation createManyAndReturn
   */
  export type exhibitAudioRelationCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the exhibitAudioRelation
     */
    select?: exhibitAudioRelationSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the exhibitAudioRelation
     */
    omit?: exhibitAudioRelationOmit<ExtArgs> | null;
    /**
     * The data used to create many exhibitAudioRelations.
     */
    data:
      | exhibitAudioRelationCreateManyInput
      | exhibitAudioRelationCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exhibitAudioRelationIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * exhibitAudioRelation update
   */
  export type exhibitAudioRelationUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the exhibitAudioRelation
     */
    select?: exhibitAudioRelationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the exhibitAudioRelation
     */
    omit?: exhibitAudioRelationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exhibitAudioRelationInclude<ExtArgs> | null;
    /**
     * The data needed to update a exhibitAudioRelation.
     */
    data: XOR<
      exhibitAudioRelationUpdateInput,
      exhibitAudioRelationUncheckedUpdateInput
    >;
    /**
     * Choose, which exhibitAudioRelation to update.
     */
    where: exhibitAudioRelationWhereUniqueInput;
  };

  /**
   * exhibitAudioRelation updateMany
   */
  export type exhibitAudioRelationUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update exhibitAudioRelations.
     */
    data: XOR<
      exhibitAudioRelationUpdateManyMutationInput,
      exhibitAudioRelationUncheckedUpdateManyInput
    >;
    /**
     * Filter which exhibitAudioRelations to update
     */
    where?: exhibitAudioRelationWhereInput;
    /**
     * Limit how many exhibitAudioRelations to update.
     */
    limit?: number;
  };

  /**
   * exhibitAudioRelation updateManyAndReturn
   */
  export type exhibitAudioRelationUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the exhibitAudioRelation
     */
    select?: exhibitAudioRelationSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the exhibitAudioRelation
     */
    omit?: exhibitAudioRelationOmit<ExtArgs> | null;
    /**
     * The data used to update exhibitAudioRelations.
     */
    data: XOR<
      exhibitAudioRelationUpdateManyMutationInput,
      exhibitAudioRelationUncheckedUpdateManyInput
    >;
    /**
     * Filter which exhibitAudioRelations to update
     */
    where?: exhibitAudioRelationWhereInput;
    /**
     * Limit how many exhibitAudioRelations to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exhibitAudioRelationIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * exhibitAudioRelation upsert
   */
  export type exhibitAudioRelationUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the exhibitAudioRelation
     */
    select?: exhibitAudioRelationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the exhibitAudioRelation
     */
    omit?: exhibitAudioRelationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exhibitAudioRelationInclude<ExtArgs> | null;
    /**
     * The filter to search for the exhibitAudioRelation to update in case it exists.
     */
    where: exhibitAudioRelationWhereUniqueInput;
    /**
     * In case the exhibitAudioRelation found by the `where` argument doesn't exist, create a new exhibitAudioRelation with this data.
     */
    create: XOR<
      exhibitAudioRelationCreateInput,
      exhibitAudioRelationUncheckedCreateInput
    >;
    /**
     * In case the exhibitAudioRelation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      exhibitAudioRelationUpdateInput,
      exhibitAudioRelationUncheckedUpdateInput
    >;
  };

  /**
   * exhibitAudioRelation delete
   */
  export type exhibitAudioRelationDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the exhibitAudioRelation
     */
    select?: exhibitAudioRelationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the exhibitAudioRelation
     */
    omit?: exhibitAudioRelationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exhibitAudioRelationInclude<ExtArgs> | null;
    /**
     * Filter which exhibitAudioRelation to delete.
     */
    where: exhibitAudioRelationWhereUniqueInput;
  };

  /**
   * exhibitAudioRelation deleteMany
   */
  export type exhibitAudioRelationDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which exhibitAudioRelations to delete
     */
    where?: exhibitAudioRelationWhereInput;
    /**
     * Limit how many exhibitAudioRelations to delete.
     */
    limit?: number;
  };

  /**
   * exhibitAudioRelation without action
   */
  export type exhibitAudioRelationDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the exhibitAudioRelation
     */
    select?: exhibitAudioRelationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the exhibitAudioRelation
     */
    omit?: exhibitAudioRelationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exhibitAudioRelationInclude<ExtArgs> | null;
  };

  /**
   * Model exhibit
   */

  export type AggregateExhibit = {
    _count: ExhibitCountAggregateOutputType | null;
    _min: ExhibitMinAggregateOutputType | null;
    _max: ExhibitMaxAggregateOutputType | null;
  };

  export type ExhibitMinAggregateOutputType = {
    exhibitId: string | null;
    title: string | null;
    description: string | null;
    audioId: string | null;
    createdBy: string | null;
    modifiedBy: string | null;
    qrCodeId: string | null;
    imageId: string | null;
    createdAt: Date | null;
    modifiedAt: Date | null;
    statusCode: string | null;
  };

  export type ExhibitMaxAggregateOutputType = {
    exhibitId: string | null;
    title: string | null;
    description: string | null;
    audioId: string | null;
    createdBy: string | null;
    modifiedBy: string | null;
    qrCodeId: string | null;
    imageId: string | null;
    createdAt: Date | null;
    modifiedAt: Date | null;
    statusCode: string | null;
  };

  export type ExhibitCountAggregateOutputType = {
    exhibitId: number;
    title: number;
    description: number;
    audioId: number;
    createdBy: number;
    modifiedBy: number;
    qrCodeId: number;
    imageId: number;
    createdAt: number;
    modifiedAt: number;
    statusCode: number;
    _all: number;
  };

  export type ExhibitMinAggregateInputType = {
    exhibitId?: true;
    title?: true;
    description?: true;
    audioId?: true;
    createdBy?: true;
    modifiedBy?: true;
    qrCodeId?: true;
    imageId?: true;
    createdAt?: true;
    modifiedAt?: true;
    statusCode?: true;
  };

  export type ExhibitMaxAggregateInputType = {
    exhibitId?: true;
    title?: true;
    description?: true;
    audioId?: true;
    createdBy?: true;
    modifiedBy?: true;
    qrCodeId?: true;
    imageId?: true;
    createdAt?: true;
    modifiedAt?: true;
    statusCode?: true;
  };

  export type ExhibitCountAggregateInputType = {
    exhibitId?: true;
    title?: true;
    description?: true;
    audioId?: true;
    createdBy?: true;
    modifiedBy?: true;
    qrCodeId?: true;
    imageId?: true;
    createdAt?: true;
    modifiedAt?: true;
    statusCode?: true;
    _all?: true;
  };

  export type ExhibitAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which exhibit to aggregate.
     */
    where?: exhibitWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of exhibits to fetch.
     */
    orderBy?:
      | exhibitOrderByWithRelationInput
      | exhibitOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: exhibitWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` exhibits from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` exhibits.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned exhibits
     **/
    _count?: true | ExhibitCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ExhibitMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ExhibitMaxAggregateInputType;
  };

  export type GetExhibitAggregateType<T extends ExhibitAggregateArgs> = {
    [P in keyof T & keyof AggregateExhibit]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExhibit[P]>
      : GetScalarType<T[P], AggregateExhibit[P]>;
  };

  export type exhibitGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: exhibitWhereInput;
    orderBy?:
      | exhibitOrderByWithAggregationInput
      | exhibitOrderByWithAggregationInput[];
    by: ExhibitScalarFieldEnum[] | ExhibitScalarFieldEnum;
    having?: exhibitScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ExhibitCountAggregateInputType | true;
    _min?: ExhibitMinAggregateInputType;
    _max?: ExhibitMaxAggregateInputType;
  };

  export type ExhibitGroupByOutputType = {
    exhibitId: string;
    title: string;
    description: string;
    audioId: string;
    createdBy: string;
    modifiedBy: string;
    qrCodeId: string;
    imageId: string;
    createdAt: Date;
    modifiedAt: Date;
    statusCode: string;
    _count: ExhibitCountAggregateOutputType | null;
    _min: ExhibitMinAggregateOutputType | null;
    _max: ExhibitMaxAggregateOutputType | null;
  };

  type GetExhibitGroupByPayload<T extends exhibitGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ExhibitGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof ExhibitGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExhibitGroupByOutputType[P]>
            : GetScalarType<T[P], ExhibitGroupByOutputType[P]>;
        }
      >
    >;

  export type exhibitSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      exhibitId?: boolean;
      title?: boolean;
      description?: boolean;
      audioId?: boolean;
      createdBy?: boolean;
      modifiedBy?: boolean;
      qrCodeId?: boolean;
      imageId?: boolean;
      createdAt?: boolean;
      modifiedAt?: boolean;
      statusCode?: boolean;
      audio?: boolean | audioDefaultArgs<ExtArgs>;
      qrCode?: boolean | qrCodeDefaultArgs<ExtArgs>;
      image?: boolean | imageDefaultArgs<ExtArgs>;
      subtitles?: boolean | exhibit$subtitlesArgs<ExtArgs>;
      status?: boolean | statusDefaultArgs<ExtArgs>;
      exhibitAudioRelation?:
        | boolean
        | exhibit$exhibitAudioRelationArgs<ExtArgs>;
      _count?: boolean | ExhibitCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["exhibit"]
  >;

  export type exhibitSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      exhibitId?: boolean;
      title?: boolean;
      description?: boolean;
      audioId?: boolean;
      createdBy?: boolean;
      modifiedBy?: boolean;
      qrCodeId?: boolean;
      imageId?: boolean;
      createdAt?: boolean;
      modifiedAt?: boolean;
      statusCode?: boolean;
      audio?: boolean | audioDefaultArgs<ExtArgs>;
      qrCode?: boolean | qrCodeDefaultArgs<ExtArgs>;
      image?: boolean | imageDefaultArgs<ExtArgs>;
      status?: boolean | statusDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["exhibit"]
  >;

  export type exhibitSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      exhibitId?: boolean;
      title?: boolean;
      description?: boolean;
      audioId?: boolean;
      createdBy?: boolean;
      modifiedBy?: boolean;
      qrCodeId?: boolean;
      imageId?: boolean;
      createdAt?: boolean;
      modifiedAt?: boolean;
      statusCode?: boolean;
      audio?: boolean | audioDefaultArgs<ExtArgs>;
      qrCode?: boolean | qrCodeDefaultArgs<ExtArgs>;
      image?: boolean | imageDefaultArgs<ExtArgs>;
      status?: boolean | statusDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["exhibit"]
  >;

  export type exhibitSelectScalar = {
    exhibitId?: boolean;
    title?: boolean;
    description?: boolean;
    audioId?: boolean;
    createdBy?: boolean;
    modifiedBy?: boolean;
    qrCodeId?: boolean;
    imageId?: boolean;
    createdAt?: boolean;
    modifiedAt?: boolean;
    statusCode?: boolean;
  };

  export type exhibitOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "exhibitId"
    | "title"
    | "description"
    | "audioId"
    | "createdBy"
    | "modifiedBy"
    | "qrCodeId"
    | "imageId"
    | "createdAt"
    | "modifiedAt"
    | "statusCode",
    ExtArgs["result"]["exhibit"]
  >;
  export type exhibitInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    audio?: boolean | audioDefaultArgs<ExtArgs>;
    qrCode?: boolean | qrCodeDefaultArgs<ExtArgs>;
    image?: boolean | imageDefaultArgs<ExtArgs>;
    subtitles?: boolean | exhibit$subtitlesArgs<ExtArgs>;
    status?: boolean | statusDefaultArgs<ExtArgs>;
    exhibitAudioRelation?: boolean | exhibit$exhibitAudioRelationArgs<ExtArgs>;
    _count?: boolean | ExhibitCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type exhibitIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    audio?: boolean | audioDefaultArgs<ExtArgs>;
    qrCode?: boolean | qrCodeDefaultArgs<ExtArgs>;
    image?: boolean | imageDefaultArgs<ExtArgs>;
    status?: boolean | statusDefaultArgs<ExtArgs>;
  };
  export type exhibitIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    audio?: boolean | audioDefaultArgs<ExtArgs>;
    qrCode?: boolean | qrCodeDefaultArgs<ExtArgs>;
    image?: boolean | imageDefaultArgs<ExtArgs>;
    status?: boolean | statusDefaultArgs<ExtArgs>;
  };

  export type $exhibitPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "exhibit";
    objects: {
      audio: Prisma.$audioPayload<ExtArgs>;
      qrCode: Prisma.$qrCodePayload<ExtArgs>;
      image: Prisma.$imagePayload<ExtArgs>;
      subtitles: Prisma.$exhibitSubtitlePayload<ExtArgs>[];
      status: Prisma.$statusPayload<ExtArgs>;
      exhibitAudioRelation: Prisma.$exhibitAudioRelationPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        exhibitId: string;
        title: string;
        description: string;
        audioId: string;
        createdBy: string;
        modifiedBy: string;
        qrCodeId: string;
        imageId: string;
        createdAt: Date;
        modifiedAt: Date;
        statusCode: string;
      },
      ExtArgs["result"]["exhibit"]
    >;
    composites: {};
  };

  type exhibitGetPayload<
    S extends boolean | null | undefined | exhibitDefaultArgs,
  > = $Result.GetResult<Prisma.$exhibitPayload, S>;

  type exhibitCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<exhibitFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: ExhibitCountAggregateInputType | true;
  };

  export interface exhibitDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["exhibit"];
      meta: { name: "exhibit" };
    };
    /**
     * Find zero or one Exhibit that matches the filter.
     * @param {exhibitFindUniqueArgs} args - Arguments to find a Exhibit
     * @example
     * // Get one Exhibit
     * const exhibit = await prisma.exhibit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends exhibitFindUniqueArgs>(
      args: SelectSubset<T, exhibitFindUniqueArgs<ExtArgs>>,
    ): Prisma__exhibitClient<
      $Result.GetResult<
        Prisma.$exhibitPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Exhibit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {exhibitFindUniqueOrThrowArgs} args - Arguments to find a Exhibit
     * @example
     * // Get one Exhibit
     * const exhibit = await prisma.exhibit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends exhibitFindUniqueOrThrowArgs>(
      args: SelectSubset<T, exhibitFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__exhibitClient<
      $Result.GetResult<
        Prisma.$exhibitPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Exhibit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exhibitFindFirstArgs} args - Arguments to find a Exhibit
     * @example
     * // Get one Exhibit
     * const exhibit = await prisma.exhibit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends exhibitFindFirstArgs>(
      args?: SelectSubset<T, exhibitFindFirstArgs<ExtArgs>>,
    ): Prisma__exhibitClient<
      $Result.GetResult<
        Prisma.$exhibitPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Exhibit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exhibitFindFirstOrThrowArgs} args - Arguments to find a Exhibit
     * @example
     * // Get one Exhibit
     * const exhibit = await prisma.exhibit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends exhibitFindFirstOrThrowArgs>(
      args?: SelectSubset<T, exhibitFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__exhibitClient<
      $Result.GetResult<
        Prisma.$exhibitPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Exhibits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exhibitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exhibits
     * const exhibits = await prisma.exhibit.findMany()
     *
     * // Get first 10 Exhibits
     * const exhibits = await prisma.exhibit.findMany({ take: 10 })
     *
     * // Only select the `exhibitId`
     * const exhibitWithExhibitIdOnly = await prisma.exhibit.findMany({ select: { exhibitId: true } })
     *
     */
    findMany<T extends exhibitFindManyArgs>(
      args?: SelectSubset<T, exhibitFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$exhibitPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Exhibit.
     * @param {exhibitCreateArgs} args - Arguments to create a Exhibit.
     * @example
     * // Create one Exhibit
     * const Exhibit = await prisma.exhibit.create({
     *   data: {
     *     // ... data to create a Exhibit
     *   }
     * })
     *
     */
    create<T extends exhibitCreateArgs>(
      args: SelectSubset<T, exhibitCreateArgs<ExtArgs>>,
    ): Prisma__exhibitClient<
      $Result.GetResult<
        Prisma.$exhibitPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Exhibits.
     * @param {exhibitCreateManyArgs} args - Arguments to create many Exhibits.
     * @example
     * // Create many Exhibits
     * const exhibit = await prisma.exhibit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends exhibitCreateManyArgs>(
      args?: SelectSubset<T, exhibitCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Exhibits and returns the data saved in the database.
     * @param {exhibitCreateManyAndReturnArgs} args - Arguments to create many Exhibits.
     * @example
     * // Create many Exhibits
     * const exhibit = await prisma.exhibit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Exhibits and only return the `exhibitId`
     * const exhibitWithExhibitIdOnly = await prisma.exhibit.createManyAndReturn({
     *   select: { exhibitId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends exhibitCreateManyAndReturnArgs>(
      args?: SelectSubset<T, exhibitCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$exhibitPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Exhibit.
     * @param {exhibitDeleteArgs} args - Arguments to delete one Exhibit.
     * @example
     * // Delete one Exhibit
     * const Exhibit = await prisma.exhibit.delete({
     *   where: {
     *     // ... filter to delete one Exhibit
     *   }
     * })
     *
     */
    delete<T extends exhibitDeleteArgs>(
      args: SelectSubset<T, exhibitDeleteArgs<ExtArgs>>,
    ): Prisma__exhibitClient<
      $Result.GetResult<
        Prisma.$exhibitPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Exhibit.
     * @param {exhibitUpdateArgs} args - Arguments to update one Exhibit.
     * @example
     * // Update one Exhibit
     * const exhibit = await prisma.exhibit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends exhibitUpdateArgs>(
      args: SelectSubset<T, exhibitUpdateArgs<ExtArgs>>,
    ): Prisma__exhibitClient<
      $Result.GetResult<
        Prisma.$exhibitPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Exhibits.
     * @param {exhibitDeleteManyArgs} args - Arguments to filter Exhibits to delete.
     * @example
     * // Delete a few Exhibits
     * const { count } = await prisma.exhibit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends exhibitDeleteManyArgs>(
      args?: SelectSubset<T, exhibitDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Exhibits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exhibitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exhibits
     * const exhibit = await prisma.exhibit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends exhibitUpdateManyArgs>(
      args: SelectSubset<T, exhibitUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Exhibits and returns the data updated in the database.
     * @param {exhibitUpdateManyAndReturnArgs} args - Arguments to update many Exhibits.
     * @example
     * // Update many Exhibits
     * const exhibit = await prisma.exhibit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Exhibits and only return the `exhibitId`
     * const exhibitWithExhibitIdOnly = await prisma.exhibit.updateManyAndReturn({
     *   select: { exhibitId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends exhibitUpdateManyAndReturnArgs>(
      args: SelectSubset<T, exhibitUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$exhibitPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Exhibit.
     * @param {exhibitUpsertArgs} args - Arguments to update or create a Exhibit.
     * @example
     * // Update or create a Exhibit
     * const exhibit = await prisma.exhibit.upsert({
     *   create: {
     *     // ... data to create a Exhibit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exhibit we want to update
     *   }
     * })
     */
    upsert<T extends exhibitUpsertArgs>(
      args: SelectSubset<T, exhibitUpsertArgs<ExtArgs>>,
    ): Prisma__exhibitClient<
      $Result.GetResult<
        Prisma.$exhibitPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Exhibits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exhibitCountArgs} args - Arguments to filter Exhibits to count.
     * @example
     * // Count the number of Exhibits
     * const count = await prisma.exhibit.count({
     *   where: {
     *     // ... the filter for the Exhibits we want to count
     *   }
     * })
     **/
    count<T extends exhibitCountArgs>(
      args?: Subset<T, exhibitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], ExhibitCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Exhibit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExhibitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ExhibitAggregateArgs>(
      args: Subset<T, ExhibitAggregateArgs>,
    ): Prisma.PrismaPromise<GetExhibitAggregateType<T>>;

    /**
     * Group by Exhibit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exhibitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends exhibitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: exhibitGroupByArgs["orderBy"] }
        : { orderBy?: exhibitGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, exhibitGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetExhibitGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the exhibit model
     */
    readonly fields: exhibitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for exhibit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__exhibitClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    audio<T extends audioDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, audioDefaultArgs<ExtArgs>>,
    ): Prisma__audioClient<
      | $Result.GetResult<
          Prisma.$audioPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    qrCode<T extends qrCodeDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, qrCodeDefaultArgs<ExtArgs>>,
    ): Prisma__qrCodeClient<
      | $Result.GetResult<
          Prisma.$qrCodePayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    image<T extends imageDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, imageDefaultArgs<ExtArgs>>,
    ): Prisma__imageClient<
      | $Result.GetResult<
          Prisma.$imagePayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    subtitles<T extends exhibit$subtitlesArgs<ExtArgs> = {}>(
      args?: Subset<T, exhibit$subtitlesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$exhibitSubtitlePayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    status<T extends statusDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, statusDefaultArgs<ExtArgs>>,
    ): Prisma__statusClient<
      | $Result.GetResult<
          Prisma.$statusPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    exhibitAudioRelation<
      T extends exhibit$exhibitAudioRelationArgs<ExtArgs> = {},
    >(
      args?: Subset<T, exhibit$exhibitAudioRelationArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$exhibitAudioRelationPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the exhibit model
   */
  interface exhibitFieldRefs {
    readonly exhibitId: FieldRef<"exhibit", "String">;
    readonly title: FieldRef<"exhibit", "String">;
    readonly description: FieldRef<"exhibit", "String">;
    readonly audioId: FieldRef<"exhibit", "String">;
    readonly createdBy: FieldRef<"exhibit", "String">;
    readonly modifiedBy: FieldRef<"exhibit", "String">;
    readonly qrCodeId: FieldRef<"exhibit", "String">;
    readonly imageId: FieldRef<"exhibit", "String">;
    readonly createdAt: FieldRef<"exhibit", "DateTime">;
    readonly modifiedAt: FieldRef<"exhibit", "DateTime">;
    readonly statusCode: FieldRef<"exhibit", "String">;
  }

  // Custom InputTypes
  /**
   * exhibit findUnique
   */
  export type exhibitFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the exhibit
     */
    select?: exhibitSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the exhibit
     */
    omit?: exhibitOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exhibitInclude<ExtArgs> | null;
    /**
     * Filter, which exhibit to fetch.
     */
    where: exhibitWhereUniqueInput;
  };

  /**
   * exhibit findUniqueOrThrow
   */
  export type exhibitFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the exhibit
     */
    select?: exhibitSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the exhibit
     */
    omit?: exhibitOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exhibitInclude<ExtArgs> | null;
    /**
     * Filter, which exhibit to fetch.
     */
    where: exhibitWhereUniqueInput;
  };

  /**
   * exhibit findFirst
   */
  export type exhibitFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the exhibit
     */
    select?: exhibitSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the exhibit
     */
    omit?: exhibitOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exhibitInclude<ExtArgs> | null;
    /**
     * Filter, which exhibit to fetch.
     */
    where?: exhibitWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of exhibits to fetch.
     */
    orderBy?:
      | exhibitOrderByWithRelationInput
      | exhibitOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for exhibits.
     */
    cursor?: exhibitWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` exhibits from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` exhibits.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of exhibits.
     */
    distinct?: ExhibitScalarFieldEnum | ExhibitScalarFieldEnum[];
  };

  /**
   * exhibit findFirstOrThrow
   */
  export type exhibitFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the exhibit
     */
    select?: exhibitSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the exhibit
     */
    omit?: exhibitOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exhibitInclude<ExtArgs> | null;
    /**
     * Filter, which exhibit to fetch.
     */
    where?: exhibitWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of exhibits to fetch.
     */
    orderBy?:
      | exhibitOrderByWithRelationInput
      | exhibitOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for exhibits.
     */
    cursor?: exhibitWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` exhibits from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` exhibits.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of exhibits.
     */
    distinct?: ExhibitScalarFieldEnum | ExhibitScalarFieldEnum[];
  };

  /**
   * exhibit findMany
   */
  export type exhibitFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the exhibit
     */
    select?: exhibitSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the exhibit
     */
    omit?: exhibitOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exhibitInclude<ExtArgs> | null;
    /**
     * Filter, which exhibits to fetch.
     */
    where?: exhibitWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of exhibits to fetch.
     */
    orderBy?:
      | exhibitOrderByWithRelationInput
      | exhibitOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing exhibits.
     */
    cursor?: exhibitWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` exhibits from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` exhibits.
     */
    skip?: number;
    distinct?: ExhibitScalarFieldEnum | ExhibitScalarFieldEnum[];
  };

  /**
   * exhibit create
   */
  export type exhibitCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the exhibit
     */
    select?: exhibitSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the exhibit
     */
    omit?: exhibitOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exhibitInclude<ExtArgs> | null;
    /**
     * The data needed to create a exhibit.
     */
    data: XOR<exhibitCreateInput, exhibitUncheckedCreateInput>;
  };

  /**
   * exhibit createMany
   */
  export type exhibitCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many exhibits.
     */
    data: exhibitCreateManyInput | exhibitCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * exhibit createManyAndReturn
   */
  export type exhibitCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the exhibit
     */
    select?: exhibitSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the exhibit
     */
    omit?: exhibitOmit<ExtArgs> | null;
    /**
     * The data used to create many exhibits.
     */
    data: exhibitCreateManyInput | exhibitCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exhibitIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * exhibit update
   */
  export type exhibitUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the exhibit
     */
    select?: exhibitSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the exhibit
     */
    omit?: exhibitOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exhibitInclude<ExtArgs> | null;
    /**
     * The data needed to update a exhibit.
     */
    data: XOR<exhibitUpdateInput, exhibitUncheckedUpdateInput>;
    /**
     * Choose, which exhibit to update.
     */
    where: exhibitWhereUniqueInput;
  };

  /**
   * exhibit updateMany
   */
  export type exhibitUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update exhibits.
     */
    data: XOR<exhibitUpdateManyMutationInput, exhibitUncheckedUpdateManyInput>;
    /**
     * Filter which exhibits to update
     */
    where?: exhibitWhereInput;
    /**
     * Limit how many exhibits to update.
     */
    limit?: number;
  };

  /**
   * exhibit updateManyAndReturn
   */
  export type exhibitUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the exhibit
     */
    select?: exhibitSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the exhibit
     */
    omit?: exhibitOmit<ExtArgs> | null;
    /**
     * The data used to update exhibits.
     */
    data: XOR<exhibitUpdateManyMutationInput, exhibitUncheckedUpdateManyInput>;
    /**
     * Filter which exhibits to update
     */
    where?: exhibitWhereInput;
    /**
     * Limit how many exhibits to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exhibitIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * exhibit upsert
   */
  export type exhibitUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the exhibit
     */
    select?: exhibitSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the exhibit
     */
    omit?: exhibitOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exhibitInclude<ExtArgs> | null;
    /**
     * The filter to search for the exhibit to update in case it exists.
     */
    where: exhibitWhereUniqueInput;
    /**
     * In case the exhibit found by the `where` argument doesn't exist, create a new exhibit with this data.
     */
    create: XOR<exhibitCreateInput, exhibitUncheckedCreateInput>;
    /**
     * In case the exhibit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<exhibitUpdateInput, exhibitUncheckedUpdateInput>;
  };

  /**
   * exhibit delete
   */
  export type exhibitDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the exhibit
     */
    select?: exhibitSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the exhibit
     */
    omit?: exhibitOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exhibitInclude<ExtArgs> | null;
    /**
     * Filter which exhibit to delete.
     */
    where: exhibitWhereUniqueInput;
  };

  /**
   * exhibit deleteMany
   */
  export type exhibitDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which exhibits to delete
     */
    where?: exhibitWhereInput;
    /**
     * Limit how many exhibits to delete.
     */
    limit?: number;
  };

  /**
   * exhibit.subtitles
   */
  export type exhibit$subtitlesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the exhibitSubtitle
     */
    select?: exhibitSubtitleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the exhibitSubtitle
     */
    omit?: exhibitSubtitleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exhibitSubtitleInclude<ExtArgs> | null;
    where?: exhibitSubtitleWhereInput;
    orderBy?:
      | exhibitSubtitleOrderByWithRelationInput
      | exhibitSubtitleOrderByWithRelationInput[];
    cursor?: exhibitSubtitleWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | ExhibitSubtitleScalarFieldEnum
      | ExhibitSubtitleScalarFieldEnum[];
  };

  /**
   * exhibit.exhibitAudioRelation
   */
  export type exhibit$exhibitAudioRelationArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the exhibitAudioRelation
     */
    select?: exhibitAudioRelationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the exhibitAudioRelation
     */
    omit?: exhibitAudioRelationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exhibitAudioRelationInclude<ExtArgs> | null;
    where?: exhibitAudioRelationWhereInput;
    orderBy?:
      | exhibitAudioRelationOrderByWithRelationInput
      | exhibitAudioRelationOrderByWithRelationInput[];
    cursor?: exhibitAudioRelationWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | ExhibitAudioRelationScalarFieldEnum
      | ExhibitAudioRelationScalarFieldEnum[];
  };

  /**
   * exhibit without action
   */
  export type exhibitDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the exhibit
     */
    select?: exhibitSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the exhibit
     */
    omit?: exhibitOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exhibitInclude<ExtArgs> | null;
  };

  /**
   * Model auditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null;
    _min: AuditLogMinAggregateOutputType | null;
    _max: AuditLogMaxAggregateOutputType | null;
  };

  export type AuditLogMinAggregateOutputType = {
    auditLogId: string | null;
    userId: string | null;
    ipAddress: string | null;
    entityName: string | null;
    entityId: string | null;
    actionType: string | null;
    oldValue: string | null;
    newValue: string | null;
    timestamp: Date | null;
    statusCode: string | null;
  };

  export type AuditLogMaxAggregateOutputType = {
    auditLogId: string | null;
    userId: string | null;
    ipAddress: string | null;
    entityName: string | null;
    entityId: string | null;
    actionType: string | null;
    oldValue: string | null;
    newValue: string | null;
    timestamp: Date | null;
    statusCode: string | null;
  };

  export type AuditLogCountAggregateOutputType = {
    auditLogId: number;
    userId: number;
    ipAddress: number;
    entityName: number;
    entityId: number;
    actionType: number;
    oldValue: number;
    newValue: number;
    timestamp: number;
    statusCode: number;
    _all: number;
  };

  export type AuditLogMinAggregateInputType = {
    auditLogId?: true;
    userId?: true;
    ipAddress?: true;
    entityName?: true;
    entityId?: true;
    actionType?: true;
    oldValue?: true;
    newValue?: true;
    timestamp?: true;
    statusCode?: true;
  };

  export type AuditLogMaxAggregateInputType = {
    auditLogId?: true;
    userId?: true;
    ipAddress?: true;
    entityName?: true;
    entityId?: true;
    actionType?: true;
    oldValue?: true;
    newValue?: true;
    timestamp?: true;
    statusCode?: true;
  };

  export type AuditLogCountAggregateInputType = {
    auditLogId?: true;
    userId?: true;
    ipAddress?: true;
    entityName?: true;
    entityId?: true;
    actionType?: true;
    oldValue?: true;
    newValue?: true;
    timestamp?: true;
    statusCode?: true;
    _all?: true;
  };

  export type AuditLogAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which auditLog to aggregate.
     */
    where?: auditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of auditLogs to fetch.
     */
    orderBy?:
      | auditLogOrderByWithRelationInput
      | auditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: auditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` auditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` auditLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned auditLogs
     **/
    _count?: true | AuditLogCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AuditLogMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AuditLogMaxAggregateInputType;
  };

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
    [P in keyof T & keyof AggregateAuditLog]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>;
  };

  export type auditLogGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: auditLogWhereInput;
    orderBy?:
      | auditLogOrderByWithAggregationInput
      | auditLogOrderByWithAggregationInput[];
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum;
    having?: auditLogScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AuditLogCountAggregateInputType | true;
    _min?: AuditLogMinAggregateInputType;
    _max?: AuditLogMaxAggregateInputType;
  };

  export type AuditLogGroupByOutputType = {
    auditLogId: string;
    userId: string;
    ipAddress: string;
    entityName: string;
    entityId: string;
    actionType: string;
    oldValue: string;
    newValue: string;
    timestamp: Date;
    statusCode: string;
    _count: AuditLogCountAggregateOutputType | null;
    _min: AuditLogMinAggregateOutputType | null;
    _max: AuditLogMaxAggregateOutputType | null;
  };

  type GetAuditLogGroupByPayload<T extends auditLogGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<AuditLogGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof AuditLogGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>;
        }
      >
    >;

  export type auditLogSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      auditLogId?: boolean;
      userId?: boolean;
      ipAddress?: boolean;
      entityName?: boolean;
      entityId?: boolean;
      actionType?: boolean;
      oldValue?: boolean;
      newValue?: boolean;
      timestamp?: boolean;
      statusCode?: boolean;
      user?: boolean | usersDefaultArgs<ExtArgs>;
      status?: boolean | statusDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["auditLog"]
  >;

  export type auditLogSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      auditLogId?: boolean;
      userId?: boolean;
      ipAddress?: boolean;
      entityName?: boolean;
      entityId?: boolean;
      actionType?: boolean;
      oldValue?: boolean;
      newValue?: boolean;
      timestamp?: boolean;
      statusCode?: boolean;
      user?: boolean | usersDefaultArgs<ExtArgs>;
      status?: boolean | statusDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["auditLog"]
  >;

  export type auditLogSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      auditLogId?: boolean;
      userId?: boolean;
      ipAddress?: boolean;
      entityName?: boolean;
      entityId?: boolean;
      actionType?: boolean;
      oldValue?: boolean;
      newValue?: boolean;
      timestamp?: boolean;
      statusCode?: boolean;
      user?: boolean | usersDefaultArgs<ExtArgs>;
      status?: boolean | statusDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["auditLog"]
  >;

  export type auditLogSelectScalar = {
    auditLogId?: boolean;
    userId?: boolean;
    ipAddress?: boolean;
    entityName?: boolean;
    entityId?: boolean;
    actionType?: boolean;
    oldValue?: boolean;
    newValue?: boolean;
    timestamp?: boolean;
    statusCode?: boolean;
  };

  export type auditLogOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "auditLogId"
    | "userId"
    | "ipAddress"
    | "entityName"
    | "entityId"
    | "actionType"
    | "oldValue"
    | "newValue"
    | "timestamp"
    | "statusCode",
    ExtArgs["result"]["auditLog"]
  >;
  export type auditLogInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | usersDefaultArgs<ExtArgs>;
    status?: boolean | statusDefaultArgs<ExtArgs>;
  };
  export type auditLogIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | usersDefaultArgs<ExtArgs>;
    status?: boolean | statusDefaultArgs<ExtArgs>;
  };
  export type auditLogIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | usersDefaultArgs<ExtArgs>;
    status?: boolean | statusDefaultArgs<ExtArgs>;
  };

  export type $auditLogPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "auditLog";
    objects: {
      user: Prisma.$usersPayload<ExtArgs>;
      status: Prisma.$statusPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        auditLogId: string;
        userId: string;
        ipAddress: string;
        entityName: string;
        entityId: string;
        actionType: string;
        oldValue: string;
        newValue: string;
        timestamp: Date;
        statusCode: string;
      },
      ExtArgs["result"]["auditLog"]
    >;
    composites: {};
  };

  type auditLogGetPayload<
    S extends boolean | null | undefined | auditLogDefaultArgs,
  > = $Result.GetResult<Prisma.$auditLogPayload, S>;

  type auditLogCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<auditLogFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: AuditLogCountAggregateInputType | true;
  };

  export interface auditLogDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["auditLog"];
      meta: { name: "auditLog" };
    };
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {auditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends auditLogFindUniqueArgs>(
      args: SelectSubset<T, auditLogFindUniqueArgs<ExtArgs>>,
    ): Prisma__auditLogClient<
      $Result.GetResult<
        Prisma.$auditLogPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {auditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends auditLogFindUniqueOrThrowArgs>(
      args: SelectSubset<T, auditLogFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__auditLogClient<
      $Result.GetResult<
        Prisma.$auditLogPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends auditLogFindFirstArgs>(
      args?: SelectSubset<T, auditLogFindFirstArgs<ExtArgs>>,
    ): Prisma__auditLogClient<
      $Result.GetResult<
        Prisma.$auditLogPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends auditLogFindFirstOrThrowArgs>(
      args?: SelectSubset<T, auditLogFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__auditLogClient<
      $Result.GetResult<
        Prisma.$auditLogPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     *
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     *
     * // Only select the `auditLogId`
     * const auditLogWithAuditLogIdOnly = await prisma.auditLog.findMany({ select: { auditLogId: true } })
     *
     */
    findMany<T extends auditLogFindManyArgs>(
      args?: SelectSubset<T, auditLogFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$auditLogPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a AuditLog.
     * @param {auditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     *
     */
    create<T extends auditLogCreateArgs>(
      args: SelectSubset<T, auditLogCreateArgs<ExtArgs>>,
    ): Prisma__auditLogClient<
      $Result.GetResult<
        Prisma.$auditLogPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many AuditLogs.
     * @param {auditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends auditLogCreateManyArgs>(
      args?: SelectSubset<T, auditLogCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {auditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many AuditLogs and only return the `auditLogId`
     * const auditLogWithAuditLogIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { auditLogId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends auditLogCreateManyAndReturnArgs>(
      args?: SelectSubset<T, auditLogCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$auditLogPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a AuditLog.
     * @param {auditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     *
     */
    delete<T extends auditLogDeleteArgs>(
      args: SelectSubset<T, auditLogDeleteArgs<ExtArgs>>,
    ): Prisma__auditLogClient<
      $Result.GetResult<
        Prisma.$auditLogPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one AuditLog.
     * @param {auditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends auditLogUpdateArgs>(
      args: SelectSubset<T, auditLogUpdateArgs<ExtArgs>>,
    ): Prisma__auditLogClient<
      $Result.GetResult<
        Prisma.$auditLogPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more AuditLogs.
     * @param {auditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends auditLogDeleteManyArgs>(
      args?: SelectSubset<T, auditLogDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends auditLogUpdateManyArgs>(
      args: SelectSubset<T, auditLogUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {auditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more AuditLogs and only return the `auditLogId`
     * const auditLogWithAuditLogIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { auditLogId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends auditLogUpdateManyAndReturnArgs>(
      args: SelectSubset<T, auditLogUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$auditLogPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one AuditLog.
     * @param {auditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends auditLogUpsertArgs>(
      args: SelectSubset<T, auditLogUpsertArgs<ExtArgs>>,
    ): Prisma__auditLogClient<
      $Result.GetResult<
        Prisma.$auditLogPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
     **/
    count<T extends auditLogCountArgs>(
      args?: Subset<T, auditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], AuditLogCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AuditLogAggregateArgs>(
      args: Subset<T, AuditLogAggregateArgs>,
    ): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>;

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends auditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: auditLogGroupByArgs["orderBy"] }
        : { orderBy?: auditLogGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, auditLogGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetAuditLogGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the auditLog model
     */
    readonly fields: auditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for auditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__auditLogClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    user<T extends usersDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, usersDefaultArgs<ExtArgs>>,
    ): Prisma__usersClient<
      | $Result.GetResult<
          Prisma.$usersPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    status<T extends statusDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, statusDefaultArgs<ExtArgs>>,
    ): Prisma__statusClient<
      | $Result.GetResult<
          Prisma.$statusPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the auditLog model
   */
  interface auditLogFieldRefs {
    readonly auditLogId: FieldRef<"auditLog", "String">;
    readonly userId: FieldRef<"auditLog", "String">;
    readonly ipAddress: FieldRef<"auditLog", "String">;
    readonly entityName: FieldRef<"auditLog", "String">;
    readonly entityId: FieldRef<"auditLog", "String">;
    readonly actionType: FieldRef<"auditLog", "String">;
    readonly oldValue: FieldRef<"auditLog", "String">;
    readonly newValue: FieldRef<"auditLog", "String">;
    readonly timestamp: FieldRef<"auditLog", "DateTime">;
    readonly statusCode: FieldRef<"auditLog", "String">;
  }

  // Custom InputTypes
  /**
   * auditLog findUnique
   */
  export type auditLogFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the auditLog
     */
    select?: auditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the auditLog
     */
    omit?: auditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditLogInclude<ExtArgs> | null;
    /**
     * Filter, which auditLog to fetch.
     */
    where: auditLogWhereUniqueInput;
  };

  /**
   * auditLog findUniqueOrThrow
   */
  export type auditLogFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the auditLog
     */
    select?: auditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the auditLog
     */
    omit?: auditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditLogInclude<ExtArgs> | null;
    /**
     * Filter, which auditLog to fetch.
     */
    where: auditLogWhereUniqueInput;
  };

  /**
   * auditLog findFirst
   */
  export type auditLogFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the auditLog
     */
    select?: auditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the auditLog
     */
    omit?: auditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditLogInclude<ExtArgs> | null;
    /**
     * Filter, which auditLog to fetch.
     */
    where?: auditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of auditLogs to fetch.
     */
    orderBy?:
      | auditLogOrderByWithRelationInput
      | auditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for auditLogs.
     */
    cursor?: auditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` auditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` auditLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of auditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[];
  };

  /**
   * auditLog findFirstOrThrow
   */
  export type auditLogFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the auditLog
     */
    select?: auditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the auditLog
     */
    omit?: auditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditLogInclude<ExtArgs> | null;
    /**
     * Filter, which auditLog to fetch.
     */
    where?: auditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of auditLogs to fetch.
     */
    orderBy?:
      | auditLogOrderByWithRelationInput
      | auditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for auditLogs.
     */
    cursor?: auditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` auditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` auditLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of auditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[];
  };

  /**
   * auditLog findMany
   */
  export type auditLogFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the auditLog
     */
    select?: auditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the auditLog
     */
    omit?: auditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditLogInclude<ExtArgs> | null;
    /**
     * Filter, which auditLogs to fetch.
     */
    where?: auditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of auditLogs to fetch.
     */
    orderBy?:
      | auditLogOrderByWithRelationInput
      | auditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing auditLogs.
     */
    cursor?: auditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` auditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` auditLogs.
     */
    skip?: number;
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[];
  };

  /**
   * auditLog create
   */
  export type auditLogCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the auditLog
     */
    select?: auditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the auditLog
     */
    omit?: auditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditLogInclude<ExtArgs> | null;
    /**
     * The data needed to create a auditLog.
     */
    data: XOR<auditLogCreateInput, auditLogUncheckedCreateInput>;
  };

  /**
   * auditLog createMany
   */
  export type auditLogCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many auditLogs.
     */
    data: auditLogCreateManyInput | auditLogCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * auditLog createManyAndReturn
   */
  export type auditLogCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the auditLog
     */
    select?: auditLogSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the auditLog
     */
    omit?: auditLogOmit<ExtArgs> | null;
    /**
     * The data used to create many auditLogs.
     */
    data: auditLogCreateManyInput | auditLogCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditLogIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * auditLog update
   */
  export type auditLogUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the auditLog
     */
    select?: auditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the auditLog
     */
    omit?: auditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditLogInclude<ExtArgs> | null;
    /**
     * The data needed to update a auditLog.
     */
    data: XOR<auditLogUpdateInput, auditLogUncheckedUpdateInput>;
    /**
     * Choose, which auditLog to update.
     */
    where: auditLogWhereUniqueInput;
  };

  /**
   * auditLog updateMany
   */
  export type auditLogUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update auditLogs.
     */
    data: XOR<
      auditLogUpdateManyMutationInput,
      auditLogUncheckedUpdateManyInput
    >;
    /**
     * Filter which auditLogs to update
     */
    where?: auditLogWhereInput;
    /**
     * Limit how many auditLogs to update.
     */
    limit?: number;
  };

  /**
   * auditLog updateManyAndReturn
   */
  export type auditLogUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the auditLog
     */
    select?: auditLogSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the auditLog
     */
    omit?: auditLogOmit<ExtArgs> | null;
    /**
     * The data used to update auditLogs.
     */
    data: XOR<
      auditLogUpdateManyMutationInput,
      auditLogUncheckedUpdateManyInput
    >;
    /**
     * Filter which auditLogs to update
     */
    where?: auditLogWhereInput;
    /**
     * Limit how many auditLogs to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditLogIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * auditLog upsert
   */
  export type auditLogUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the auditLog
     */
    select?: auditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the auditLog
     */
    omit?: auditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditLogInclude<ExtArgs> | null;
    /**
     * The filter to search for the auditLog to update in case it exists.
     */
    where: auditLogWhereUniqueInput;
    /**
     * In case the auditLog found by the `where` argument doesn't exist, create a new auditLog with this data.
     */
    create: XOR<auditLogCreateInput, auditLogUncheckedCreateInput>;
    /**
     * In case the auditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<auditLogUpdateInput, auditLogUncheckedUpdateInput>;
  };

  /**
   * auditLog delete
   */
  export type auditLogDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the auditLog
     */
    select?: auditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the auditLog
     */
    omit?: auditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditLogInclude<ExtArgs> | null;
    /**
     * Filter which auditLog to delete.
     */
    where: auditLogWhereUniqueInput;
  };

  /**
   * auditLog deleteMany
   */
  export type auditLogDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which auditLogs to delete
     */
    where?: auditLogWhereInput;
    /**
     * Limit how many auditLogs to delete.
     */
    limit?: number;
  };

  /**
   * auditLog without action
   */
  export type auditLogDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the auditLog
     */
    select?: auditLogSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the auditLog
     */
    omit?: auditLogOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: auditLogInclude<ExtArgs> | null;
  };

  /**
   * Model phoneNumber
   */

  export type AggregatePhoneNumber = {
    _count: PhoneNumberCountAggregateOutputType | null;
    _min: PhoneNumberMinAggregateOutputType | null;
    _max: PhoneNumberMaxAggregateOutputType | null;
  };

  export type PhoneNumberMinAggregateOutputType = {
    phoneNumberId: string | null;
    userId: string | null;
    phoneNumber: string | null;
    verified: boolean | null;
    isPrimary: boolean | null;
    createdAt: Date | null;
    statusCode: string | null;
  };

  export type PhoneNumberMaxAggregateOutputType = {
    phoneNumberId: string | null;
    userId: string | null;
    phoneNumber: string | null;
    verified: boolean | null;
    isPrimary: boolean | null;
    createdAt: Date | null;
    statusCode: string | null;
  };

  export type PhoneNumberCountAggregateOutputType = {
    phoneNumberId: number;
    userId: number;
    phoneNumber: number;
    verified: number;
    isPrimary: number;
    createdAt: number;
    statusCode: number;
    _all: number;
  };

  export type PhoneNumberMinAggregateInputType = {
    phoneNumberId?: true;
    userId?: true;
    phoneNumber?: true;
    verified?: true;
    isPrimary?: true;
    createdAt?: true;
    statusCode?: true;
  };

  export type PhoneNumberMaxAggregateInputType = {
    phoneNumberId?: true;
    userId?: true;
    phoneNumber?: true;
    verified?: true;
    isPrimary?: true;
    createdAt?: true;
    statusCode?: true;
  };

  export type PhoneNumberCountAggregateInputType = {
    phoneNumberId?: true;
    userId?: true;
    phoneNumber?: true;
    verified?: true;
    isPrimary?: true;
    createdAt?: true;
    statusCode?: true;
    _all?: true;
  };

  export type PhoneNumberAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which phoneNumber to aggregate.
     */
    where?: phoneNumberWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of phoneNumbers to fetch.
     */
    orderBy?:
      | phoneNumberOrderByWithRelationInput
      | phoneNumberOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: phoneNumberWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` phoneNumbers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` phoneNumbers.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned phoneNumbers
     **/
    _count?: true | PhoneNumberCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: PhoneNumberMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: PhoneNumberMaxAggregateInputType;
  };

  export type GetPhoneNumberAggregateType<T extends PhoneNumberAggregateArgs> =
    {
      [P in keyof T & keyof AggregatePhoneNumber]: P extends "_count" | "count"
        ? T[P] extends true
          ? number
          : GetScalarType<T[P], AggregatePhoneNumber[P]>
        : GetScalarType<T[P], AggregatePhoneNumber[P]>;
    };

  export type phoneNumberGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: phoneNumberWhereInput;
    orderBy?:
      | phoneNumberOrderByWithAggregationInput
      | phoneNumberOrderByWithAggregationInput[];
    by: PhoneNumberScalarFieldEnum[] | PhoneNumberScalarFieldEnum;
    having?: phoneNumberScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: PhoneNumberCountAggregateInputType | true;
    _min?: PhoneNumberMinAggregateInputType;
    _max?: PhoneNumberMaxAggregateInputType;
  };

  export type PhoneNumberGroupByOutputType = {
    phoneNumberId: string;
    userId: string;
    phoneNumber: string;
    verified: boolean;
    isPrimary: boolean;
    createdAt: Date;
    statusCode: string;
    _count: PhoneNumberCountAggregateOutputType | null;
    _min: PhoneNumberMinAggregateOutputType | null;
    _max: PhoneNumberMaxAggregateOutputType | null;
  };

  type GetPhoneNumberGroupByPayload<T extends phoneNumberGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<PhoneNumberGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof PhoneNumberGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PhoneNumberGroupByOutputType[P]>
            : GetScalarType<T[P], PhoneNumberGroupByOutputType[P]>;
        }
      >
    >;

  export type phoneNumberSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      phoneNumberId?: boolean;
      userId?: boolean;
      phoneNumber?: boolean;
      verified?: boolean;
      isPrimary?: boolean;
      createdAt?: boolean;
      statusCode?: boolean;
      user?: boolean | usersDefaultArgs<ExtArgs>;
      status?: boolean | statusDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["phoneNumber"]
  >;

  export type phoneNumberSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      phoneNumberId?: boolean;
      userId?: boolean;
      phoneNumber?: boolean;
      verified?: boolean;
      isPrimary?: boolean;
      createdAt?: boolean;
      statusCode?: boolean;
      user?: boolean | usersDefaultArgs<ExtArgs>;
      status?: boolean | statusDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["phoneNumber"]
  >;

  export type phoneNumberSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      phoneNumberId?: boolean;
      userId?: boolean;
      phoneNumber?: boolean;
      verified?: boolean;
      isPrimary?: boolean;
      createdAt?: boolean;
      statusCode?: boolean;
      user?: boolean | usersDefaultArgs<ExtArgs>;
      status?: boolean | statusDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["phoneNumber"]
  >;

  export type phoneNumberSelectScalar = {
    phoneNumberId?: boolean;
    userId?: boolean;
    phoneNumber?: boolean;
    verified?: boolean;
    isPrimary?: boolean;
    createdAt?: boolean;
    statusCode?: boolean;
  };

  export type phoneNumberOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "phoneNumberId"
    | "userId"
    | "phoneNumber"
    | "verified"
    | "isPrimary"
    | "createdAt"
    | "statusCode",
    ExtArgs["result"]["phoneNumber"]
  >;
  export type phoneNumberInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | usersDefaultArgs<ExtArgs>;
    status?: boolean | statusDefaultArgs<ExtArgs>;
  };
  export type phoneNumberIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | usersDefaultArgs<ExtArgs>;
    status?: boolean | statusDefaultArgs<ExtArgs>;
  };
  export type phoneNumberIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | usersDefaultArgs<ExtArgs>;
    status?: boolean | statusDefaultArgs<ExtArgs>;
  };

  export type $phoneNumberPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "phoneNumber";
    objects: {
      user: Prisma.$usersPayload<ExtArgs>;
      status: Prisma.$statusPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        phoneNumberId: string;
        userId: string;
        phoneNumber: string;
        verified: boolean;
        isPrimary: boolean;
        createdAt: Date;
        statusCode: string;
      },
      ExtArgs["result"]["phoneNumber"]
    >;
    composites: {};
  };

  type phoneNumberGetPayload<
    S extends boolean | null | undefined | phoneNumberDefaultArgs,
  > = $Result.GetResult<Prisma.$phoneNumberPayload, S>;

  type phoneNumberCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    phoneNumberFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: PhoneNumberCountAggregateInputType | true;
  };

  export interface phoneNumberDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["phoneNumber"];
      meta: { name: "phoneNumber" };
    };
    /**
     * Find zero or one PhoneNumber that matches the filter.
     * @param {phoneNumberFindUniqueArgs} args - Arguments to find a PhoneNumber
     * @example
     * // Get one PhoneNumber
     * const phoneNumber = await prisma.phoneNumber.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends phoneNumberFindUniqueArgs>(
      args: SelectSubset<T, phoneNumberFindUniqueArgs<ExtArgs>>,
    ): Prisma__phoneNumberClient<
      $Result.GetResult<
        Prisma.$phoneNumberPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one PhoneNumber that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {phoneNumberFindUniqueOrThrowArgs} args - Arguments to find a PhoneNumber
     * @example
     * // Get one PhoneNumber
     * const phoneNumber = await prisma.phoneNumber.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends phoneNumberFindUniqueOrThrowArgs>(
      args: SelectSubset<T, phoneNumberFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__phoneNumberClient<
      $Result.GetResult<
        Prisma.$phoneNumberPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first PhoneNumber that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {phoneNumberFindFirstArgs} args - Arguments to find a PhoneNumber
     * @example
     * // Get one PhoneNumber
     * const phoneNumber = await prisma.phoneNumber.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends phoneNumberFindFirstArgs>(
      args?: SelectSubset<T, phoneNumberFindFirstArgs<ExtArgs>>,
    ): Prisma__phoneNumberClient<
      $Result.GetResult<
        Prisma.$phoneNumberPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first PhoneNumber that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {phoneNumberFindFirstOrThrowArgs} args - Arguments to find a PhoneNumber
     * @example
     * // Get one PhoneNumber
     * const phoneNumber = await prisma.phoneNumber.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends phoneNumberFindFirstOrThrowArgs>(
      args?: SelectSubset<T, phoneNumberFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__phoneNumberClient<
      $Result.GetResult<
        Prisma.$phoneNumberPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more PhoneNumbers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {phoneNumberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PhoneNumbers
     * const phoneNumbers = await prisma.phoneNumber.findMany()
     *
     * // Get first 10 PhoneNumbers
     * const phoneNumbers = await prisma.phoneNumber.findMany({ take: 10 })
     *
     * // Only select the `phoneNumberId`
     * const phoneNumberWithPhoneNumberIdOnly = await prisma.phoneNumber.findMany({ select: { phoneNumberId: true } })
     *
     */
    findMany<T extends phoneNumberFindManyArgs>(
      args?: SelectSubset<T, phoneNumberFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$phoneNumberPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a PhoneNumber.
     * @param {phoneNumberCreateArgs} args - Arguments to create a PhoneNumber.
     * @example
     * // Create one PhoneNumber
     * const PhoneNumber = await prisma.phoneNumber.create({
     *   data: {
     *     // ... data to create a PhoneNumber
     *   }
     * })
     *
     */
    create<T extends phoneNumberCreateArgs>(
      args: SelectSubset<T, phoneNumberCreateArgs<ExtArgs>>,
    ): Prisma__phoneNumberClient<
      $Result.GetResult<
        Prisma.$phoneNumberPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many PhoneNumbers.
     * @param {phoneNumberCreateManyArgs} args - Arguments to create many PhoneNumbers.
     * @example
     * // Create many PhoneNumbers
     * const phoneNumber = await prisma.phoneNumber.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends phoneNumberCreateManyArgs>(
      args?: SelectSubset<T, phoneNumberCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many PhoneNumbers and returns the data saved in the database.
     * @param {phoneNumberCreateManyAndReturnArgs} args - Arguments to create many PhoneNumbers.
     * @example
     * // Create many PhoneNumbers
     * const phoneNumber = await prisma.phoneNumber.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many PhoneNumbers and only return the `phoneNumberId`
     * const phoneNumberWithPhoneNumberIdOnly = await prisma.phoneNumber.createManyAndReturn({
     *   select: { phoneNumberId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends phoneNumberCreateManyAndReturnArgs>(
      args?: SelectSubset<T, phoneNumberCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$phoneNumberPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a PhoneNumber.
     * @param {phoneNumberDeleteArgs} args - Arguments to delete one PhoneNumber.
     * @example
     * // Delete one PhoneNumber
     * const PhoneNumber = await prisma.phoneNumber.delete({
     *   where: {
     *     // ... filter to delete one PhoneNumber
     *   }
     * })
     *
     */
    delete<T extends phoneNumberDeleteArgs>(
      args: SelectSubset<T, phoneNumberDeleteArgs<ExtArgs>>,
    ): Prisma__phoneNumberClient<
      $Result.GetResult<
        Prisma.$phoneNumberPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one PhoneNumber.
     * @param {phoneNumberUpdateArgs} args - Arguments to update one PhoneNumber.
     * @example
     * // Update one PhoneNumber
     * const phoneNumber = await prisma.phoneNumber.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends phoneNumberUpdateArgs>(
      args: SelectSubset<T, phoneNumberUpdateArgs<ExtArgs>>,
    ): Prisma__phoneNumberClient<
      $Result.GetResult<
        Prisma.$phoneNumberPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more PhoneNumbers.
     * @param {phoneNumberDeleteManyArgs} args - Arguments to filter PhoneNumbers to delete.
     * @example
     * // Delete a few PhoneNumbers
     * const { count } = await prisma.phoneNumber.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends phoneNumberDeleteManyArgs>(
      args?: SelectSubset<T, phoneNumberDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more PhoneNumbers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {phoneNumberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PhoneNumbers
     * const phoneNumber = await prisma.phoneNumber.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends phoneNumberUpdateManyArgs>(
      args: SelectSubset<T, phoneNumberUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more PhoneNumbers and returns the data updated in the database.
     * @param {phoneNumberUpdateManyAndReturnArgs} args - Arguments to update many PhoneNumbers.
     * @example
     * // Update many PhoneNumbers
     * const phoneNumber = await prisma.phoneNumber.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more PhoneNumbers and only return the `phoneNumberId`
     * const phoneNumberWithPhoneNumberIdOnly = await prisma.phoneNumber.updateManyAndReturn({
     *   select: { phoneNumberId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends phoneNumberUpdateManyAndReturnArgs>(
      args: SelectSubset<T, phoneNumberUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$phoneNumberPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one PhoneNumber.
     * @param {phoneNumberUpsertArgs} args - Arguments to update or create a PhoneNumber.
     * @example
     * // Update or create a PhoneNumber
     * const phoneNumber = await prisma.phoneNumber.upsert({
     *   create: {
     *     // ... data to create a PhoneNumber
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PhoneNumber we want to update
     *   }
     * })
     */
    upsert<T extends phoneNumberUpsertArgs>(
      args: SelectSubset<T, phoneNumberUpsertArgs<ExtArgs>>,
    ): Prisma__phoneNumberClient<
      $Result.GetResult<
        Prisma.$phoneNumberPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of PhoneNumbers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {phoneNumberCountArgs} args - Arguments to filter PhoneNumbers to count.
     * @example
     * // Count the number of PhoneNumbers
     * const count = await prisma.phoneNumber.count({
     *   where: {
     *     // ... the filter for the PhoneNumbers we want to count
     *   }
     * })
     **/
    count<T extends phoneNumberCountArgs>(
      args?: Subset<T, phoneNumberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], PhoneNumberCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a PhoneNumber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneNumberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends PhoneNumberAggregateArgs>(
      args: Subset<T, PhoneNumberAggregateArgs>,
    ): Prisma.PrismaPromise<GetPhoneNumberAggregateType<T>>;

    /**
     * Group by PhoneNumber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {phoneNumberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends phoneNumberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: phoneNumberGroupByArgs["orderBy"] }
        : { orderBy?: phoneNumberGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, phoneNumberGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetPhoneNumberGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the phoneNumber model
     */
    readonly fields: phoneNumberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for phoneNumber.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__phoneNumberClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    user<T extends usersDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, usersDefaultArgs<ExtArgs>>,
    ): Prisma__usersClient<
      | $Result.GetResult<
          Prisma.$usersPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    status<T extends statusDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, statusDefaultArgs<ExtArgs>>,
    ): Prisma__statusClient<
      | $Result.GetResult<
          Prisma.$statusPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the phoneNumber model
   */
  interface phoneNumberFieldRefs {
    readonly phoneNumberId: FieldRef<"phoneNumber", "String">;
    readonly userId: FieldRef<"phoneNumber", "String">;
    readonly phoneNumber: FieldRef<"phoneNumber", "String">;
    readonly verified: FieldRef<"phoneNumber", "Boolean">;
    readonly isPrimary: FieldRef<"phoneNumber", "Boolean">;
    readonly createdAt: FieldRef<"phoneNumber", "DateTime">;
    readonly statusCode: FieldRef<"phoneNumber", "String">;
  }

  // Custom InputTypes
  /**
   * phoneNumber findUnique
   */
  export type phoneNumberFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the phoneNumber
     */
    select?: phoneNumberSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the phoneNumber
     */
    omit?: phoneNumberOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: phoneNumberInclude<ExtArgs> | null;
    /**
     * Filter, which phoneNumber to fetch.
     */
    where: phoneNumberWhereUniqueInput;
  };

  /**
   * phoneNumber findUniqueOrThrow
   */
  export type phoneNumberFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the phoneNumber
     */
    select?: phoneNumberSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the phoneNumber
     */
    omit?: phoneNumberOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: phoneNumberInclude<ExtArgs> | null;
    /**
     * Filter, which phoneNumber to fetch.
     */
    where: phoneNumberWhereUniqueInput;
  };

  /**
   * phoneNumber findFirst
   */
  export type phoneNumberFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the phoneNumber
     */
    select?: phoneNumberSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the phoneNumber
     */
    omit?: phoneNumberOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: phoneNumberInclude<ExtArgs> | null;
    /**
     * Filter, which phoneNumber to fetch.
     */
    where?: phoneNumberWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of phoneNumbers to fetch.
     */
    orderBy?:
      | phoneNumberOrderByWithRelationInput
      | phoneNumberOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for phoneNumbers.
     */
    cursor?: phoneNumberWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` phoneNumbers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` phoneNumbers.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of phoneNumbers.
     */
    distinct?: PhoneNumberScalarFieldEnum | PhoneNumberScalarFieldEnum[];
  };

  /**
   * phoneNumber findFirstOrThrow
   */
  export type phoneNumberFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the phoneNumber
     */
    select?: phoneNumberSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the phoneNumber
     */
    omit?: phoneNumberOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: phoneNumberInclude<ExtArgs> | null;
    /**
     * Filter, which phoneNumber to fetch.
     */
    where?: phoneNumberWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of phoneNumbers to fetch.
     */
    orderBy?:
      | phoneNumberOrderByWithRelationInput
      | phoneNumberOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for phoneNumbers.
     */
    cursor?: phoneNumberWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` phoneNumbers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` phoneNumbers.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of phoneNumbers.
     */
    distinct?: PhoneNumberScalarFieldEnum | PhoneNumberScalarFieldEnum[];
  };

  /**
   * phoneNumber findMany
   */
  export type phoneNumberFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the phoneNumber
     */
    select?: phoneNumberSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the phoneNumber
     */
    omit?: phoneNumberOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: phoneNumberInclude<ExtArgs> | null;
    /**
     * Filter, which phoneNumbers to fetch.
     */
    where?: phoneNumberWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of phoneNumbers to fetch.
     */
    orderBy?:
      | phoneNumberOrderByWithRelationInput
      | phoneNumberOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing phoneNumbers.
     */
    cursor?: phoneNumberWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` phoneNumbers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` phoneNumbers.
     */
    skip?: number;
    distinct?: PhoneNumberScalarFieldEnum | PhoneNumberScalarFieldEnum[];
  };

  /**
   * phoneNumber create
   */
  export type phoneNumberCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the phoneNumber
     */
    select?: phoneNumberSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the phoneNumber
     */
    omit?: phoneNumberOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: phoneNumberInclude<ExtArgs> | null;
    /**
     * The data needed to create a phoneNumber.
     */
    data: XOR<phoneNumberCreateInput, phoneNumberUncheckedCreateInput>;
  };

  /**
   * phoneNumber createMany
   */
  export type phoneNumberCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many phoneNumbers.
     */
    data: phoneNumberCreateManyInput | phoneNumberCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * phoneNumber createManyAndReturn
   */
  export type phoneNumberCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the phoneNumber
     */
    select?: phoneNumberSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the phoneNumber
     */
    omit?: phoneNumberOmit<ExtArgs> | null;
    /**
     * The data used to create many phoneNumbers.
     */
    data: phoneNumberCreateManyInput | phoneNumberCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: phoneNumberIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * phoneNumber update
   */
  export type phoneNumberUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the phoneNumber
     */
    select?: phoneNumberSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the phoneNumber
     */
    omit?: phoneNumberOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: phoneNumberInclude<ExtArgs> | null;
    /**
     * The data needed to update a phoneNumber.
     */
    data: XOR<phoneNumberUpdateInput, phoneNumberUncheckedUpdateInput>;
    /**
     * Choose, which phoneNumber to update.
     */
    where: phoneNumberWhereUniqueInput;
  };

  /**
   * phoneNumber updateMany
   */
  export type phoneNumberUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update phoneNumbers.
     */
    data: XOR<
      phoneNumberUpdateManyMutationInput,
      phoneNumberUncheckedUpdateManyInput
    >;
    /**
     * Filter which phoneNumbers to update
     */
    where?: phoneNumberWhereInput;
    /**
     * Limit how many phoneNumbers to update.
     */
    limit?: number;
  };

  /**
   * phoneNumber updateManyAndReturn
   */
  export type phoneNumberUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the phoneNumber
     */
    select?: phoneNumberSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the phoneNumber
     */
    omit?: phoneNumberOmit<ExtArgs> | null;
    /**
     * The data used to update phoneNumbers.
     */
    data: XOR<
      phoneNumberUpdateManyMutationInput,
      phoneNumberUncheckedUpdateManyInput
    >;
    /**
     * Filter which phoneNumbers to update
     */
    where?: phoneNumberWhereInput;
    /**
     * Limit how many phoneNumbers to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: phoneNumberIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * phoneNumber upsert
   */
  export type phoneNumberUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the phoneNumber
     */
    select?: phoneNumberSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the phoneNumber
     */
    omit?: phoneNumberOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: phoneNumberInclude<ExtArgs> | null;
    /**
     * The filter to search for the phoneNumber to update in case it exists.
     */
    where: phoneNumberWhereUniqueInput;
    /**
     * In case the phoneNumber found by the `where` argument doesn't exist, create a new phoneNumber with this data.
     */
    create: XOR<phoneNumberCreateInput, phoneNumberUncheckedCreateInput>;
    /**
     * In case the phoneNumber was found with the provided `where` argument, update it with this data.
     */
    update: XOR<phoneNumberUpdateInput, phoneNumberUncheckedUpdateInput>;
  };

  /**
   * phoneNumber delete
   */
  export type phoneNumberDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the phoneNumber
     */
    select?: phoneNumberSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the phoneNumber
     */
    omit?: phoneNumberOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: phoneNumberInclude<ExtArgs> | null;
    /**
     * Filter which phoneNumber to delete.
     */
    where: phoneNumberWhereUniqueInput;
  };

  /**
   * phoneNumber deleteMany
   */
  export type phoneNumberDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which phoneNumbers to delete
     */
    where?: phoneNumberWhereInput;
    /**
     * Limit how many phoneNumbers to delete.
     */
    limit?: number;
  };

  /**
   * phoneNumber without action
   */
  export type phoneNumberDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the phoneNumber
     */
    select?: phoneNumberSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the phoneNumber
     */
    omit?: phoneNumberOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: phoneNumberInclude<ExtArgs> | null;
  };

  /**
   * Model email
   */

  export type AggregateEmail = {
    _count: EmailCountAggregateOutputType | null;
    _min: EmailMinAggregateOutputType | null;
    _max: EmailMaxAggregateOutputType | null;
  };

  export type EmailMinAggregateOutputType = {
    emailId: string | null;
    userId: string | null;
    email: string | null;
    verified: boolean | null;
    isPrimary: boolean | null;
    createdAt: Date | null;
    statusCode: string | null;
  };

  export type EmailMaxAggregateOutputType = {
    emailId: string | null;
    userId: string | null;
    email: string | null;
    verified: boolean | null;
    isPrimary: boolean | null;
    createdAt: Date | null;
    statusCode: string | null;
  };

  export type EmailCountAggregateOutputType = {
    emailId: number;
    userId: number;
    email: number;
    verified: number;
    isPrimary: number;
    createdAt: number;
    statusCode: number;
    _all: number;
  };

  export type EmailMinAggregateInputType = {
    emailId?: true;
    userId?: true;
    email?: true;
    verified?: true;
    isPrimary?: true;
    createdAt?: true;
    statusCode?: true;
  };

  export type EmailMaxAggregateInputType = {
    emailId?: true;
    userId?: true;
    email?: true;
    verified?: true;
    isPrimary?: true;
    createdAt?: true;
    statusCode?: true;
  };

  export type EmailCountAggregateInputType = {
    emailId?: true;
    userId?: true;
    email?: true;
    verified?: true;
    isPrimary?: true;
    createdAt?: true;
    statusCode?: true;
    _all?: true;
  };

  export type EmailAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which email to aggregate.
     */
    where?: emailWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of emails to fetch.
     */
    orderBy?: emailOrderByWithRelationInput | emailOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: emailWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` emails from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` emails.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned emails
     **/
    _count?: true | EmailCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: EmailMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: EmailMaxAggregateInputType;
  };

  export type GetEmailAggregateType<T extends EmailAggregateArgs> = {
    [P in keyof T & keyof AggregateEmail]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmail[P]>
      : GetScalarType<T[P], AggregateEmail[P]>;
  };

  export type emailGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: emailWhereInput;
    orderBy?:
      | emailOrderByWithAggregationInput
      | emailOrderByWithAggregationInput[];
    by: EmailScalarFieldEnum[] | EmailScalarFieldEnum;
    having?: emailScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: EmailCountAggregateInputType | true;
    _min?: EmailMinAggregateInputType;
    _max?: EmailMaxAggregateInputType;
  };

  export type EmailGroupByOutputType = {
    emailId: string;
    userId: string;
    email: string;
    verified: boolean;
    isPrimary: boolean;
    createdAt: Date;
    statusCode: string;
    _count: EmailCountAggregateOutputType | null;
    _min: EmailMinAggregateOutputType | null;
    _max: EmailMaxAggregateOutputType | null;
  };

  type GetEmailGroupByPayload<T extends emailGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<EmailGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof EmailGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailGroupByOutputType[P]>
            : GetScalarType<T[P], EmailGroupByOutputType[P]>;
        }
      >
    >;

  export type emailSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      emailId?: boolean;
      userId?: boolean;
      email?: boolean;
      verified?: boolean;
      isPrimary?: boolean;
      createdAt?: boolean;
      statusCode?: boolean;
      user?: boolean | usersDefaultArgs<ExtArgs>;
      status?: boolean | statusDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["email"]
  >;

  export type emailSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      emailId?: boolean;
      userId?: boolean;
      email?: boolean;
      verified?: boolean;
      isPrimary?: boolean;
      createdAt?: boolean;
      statusCode?: boolean;
      user?: boolean | usersDefaultArgs<ExtArgs>;
      status?: boolean | statusDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["email"]
  >;

  export type emailSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      emailId?: boolean;
      userId?: boolean;
      email?: boolean;
      verified?: boolean;
      isPrimary?: boolean;
      createdAt?: boolean;
      statusCode?: boolean;
      user?: boolean | usersDefaultArgs<ExtArgs>;
      status?: boolean | statusDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["email"]
  >;

  export type emailSelectScalar = {
    emailId?: boolean;
    userId?: boolean;
    email?: boolean;
    verified?: boolean;
    isPrimary?: boolean;
    createdAt?: boolean;
    statusCode?: boolean;
  };

  export type emailOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "emailId"
    | "userId"
    | "email"
    | "verified"
    | "isPrimary"
    | "createdAt"
    | "statusCode",
    ExtArgs["result"]["email"]
  >;
  export type emailInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | usersDefaultArgs<ExtArgs>;
    status?: boolean | statusDefaultArgs<ExtArgs>;
  };
  export type emailIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | usersDefaultArgs<ExtArgs>;
    status?: boolean | statusDefaultArgs<ExtArgs>;
  };
  export type emailIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | usersDefaultArgs<ExtArgs>;
    status?: boolean | statusDefaultArgs<ExtArgs>;
  };

  export type $emailPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "email";
    objects: {
      user: Prisma.$usersPayload<ExtArgs>;
      status: Prisma.$statusPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        emailId: string;
        userId: string;
        email: string;
        verified: boolean;
        isPrimary: boolean;
        createdAt: Date;
        statusCode: string;
      },
      ExtArgs["result"]["email"]
    >;
    composites: {};
  };

  type emailGetPayload<
    S extends boolean | null | undefined | emailDefaultArgs,
  > = $Result.GetResult<Prisma.$emailPayload, S>;

  type emailCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<emailFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: EmailCountAggregateInputType | true;
  };

  export interface emailDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["email"];
      meta: { name: "email" };
    };
    /**
     * Find zero or one Email that matches the filter.
     * @param {emailFindUniqueArgs} args - Arguments to find a Email
     * @example
     * // Get one Email
     * const email = await prisma.email.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends emailFindUniqueArgs>(
      args: SelectSubset<T, emailFindUniqueArgs<ExtArgs>>,
    ): Prisma__emailClient<
      $Result.GetResult<
        Prisma.$emailPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Email that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {emailFindUniqueOrThrowArgs} args - Arguments to find a Email
     * @example
     * // Get one Email
     * const email = await prisma.email.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends emailFindUniqueOrThrowArgs>(
      args: SelectSubset<T, emailFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__emailClient<
      $Result.GetResult<
        Prisma.$emailPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Email that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {emailFindFirstArgs} args - Arguments to find a Email
     * @example
     * // Get one Email
     * const email = await prisma.email.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends emailFindFirstArgs>(
      args?: SelectSubset<T, emailFindFirstArgs<ExtArgs>>,
    ): Prisma__emailClient<
      $Result.GetResult<
        Prisma.$emailPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Email that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {emailFindFirstOrThrowArgs} args - Arguments to find a Email
     * @example
     * // Get one Email
     * const email = await prisma.email.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends emailFindFirstOrThrowArgs>(
      args?: SelectSubset<T, emailFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__emailClient<
      $Result.GetResult<
        Prisma.$emailPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Emails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {emailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Emails
     * const emails = await prisma.email.findMany()
     *
     * // Get first 10 Emails
     * const emails = await prisma.email.findMany({ take: 10 })
     *
     * // Only select the `emailId`
     * const emailWithEmailIdOnly = await prisma.email.findMany({ select: { emailId: true } })
     *
     */
    findMany<T extends emailFindManyArgs>(
      args?: SelectSubset<T, emailFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$emailPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Email.
     * @param {emailCreateArgs} args - Arguments to create a Email.
     * @example
     * // Create one Email
     * const Email = await prisma.email.create({
     *   data: {
     *     // ... data to create a Email
     *   }
     * })
     *
     */
    create<T extends emailCreateArgs>(
      args: SelectSubset<T, emailCreateArgs<ExtArgs>>,
    ): Prisma__emailClient<
      $Result.GetResult<
        Prisma.$emailPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Emails.
     * @param {emailCreateManyArgs} args - Arguments to create many Emails.
     * @example
     * // Create many Emails
     * const email = await prisma.email.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends emailCreateManyArgs>(
      args?: SelectSubset<T, emailCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Emails and returns the data saved in the database.
     * @param {emailCreateManyAndReturnArgs} args - Arguments to create many Emails.
     * @example
     * // Create many Emails
     * const email = await prisma.email.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Emails and only return the `emailId`
     * const emailWithEmailIdOnly = await prisma.email.createManyAndReturn({
     *   select: { emailId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends emailCreateManyAndReturnArgs>(
      args?: SelectSubset<T, emailCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$emailPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Email.
     * @param {emailDeleteArgs} args - Arguments to delete one Email.
     * @example
     * // Delete one Email
     * const Email = await prisma.email.delete({
     *   where: {
     *     // ... filter to delete one Email
     *   }
     * })
     *
     */
    delete<T extends emailDeleteArgs>(
      args: SelectSubset<T, emailDeleteArgs<ExtArgs>>,
    ): Prisma__emailClient<
      $Result.GetResult<
        Prisma.$emailPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Email.
     * @param {emailUpdateArgs} args - Arguments to update one Email.
     * @example
     * // Update one Email
     * const email = await prisma.email.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends emailUpdateArgs>(
      args: SelectSubset<T, emailUpdateArgs<ExtArgs>>,
    ): Prisma__emailClient<
      $Result.GetResult<
        Prisma.$emailPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Emails.
     * @param {emailDeleteManyArgs} args - Arguments to filter Emails to delete.
     * @example
     * // Delete a few Emails
     * const { count } = await prisma.email.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends emailDeleteManyArgs>(
      args?: SelectSubset<T, emailDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Emails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {emailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Emails
     * const email = await prisma.email.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends emailUpdateManyArgs>(
      args: SelectSubset<T, emailUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Emails and returns the data updated in the database.
     * @param {emailUpdateManyAndReturnArgs} args - Arguments to update many Emails.
     * @example
     * // Update many Emails
     * const email = await prisma.email.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Emails and only return the `emailId`
     * const emailWithEmailIdOnly = await prisma.email.updateManyAndReturn({
     *   select: { emailId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends emailUpdateManyAndReturnArgs>(
      args: SelectSubset<T, emailUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$emailPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Email.
     * @param {emailUpsertArgs} args - Arguments to update or create a Email.
     * @example
     * // Update or create a Email
     * const email = await prisma.email.upsert({
     *   create: {
     *     // ... data to create a Email
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Email we want to update
     *   }
     * })
     */
    upsert<T extends emailUpsertArgs>(
      args: SelectSubset<T, emailUpsertArgs<ExtArgs>>,
    ): Prisma__emailClient<
      $Result.GetResult<
        Prisma.$emailPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Emails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {emailCountArgs} args - Arguments to filter Emails to count.
     * @example
     * // Count the number of Emails
     * const count = await prisma.email.count({
     *   where: {
     *     // ... the filter for the Emails we want to count
     *   }
     * })
     **/
    count<T extends emailCountArgs>(
      args?: Subset<T, emailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], EmailCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Email.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends EmailAggregateArgs>(
      args: Subset<T, EmailAggregateArgs>,
    ): Prisma.PrismaPromise<GetEmailAggregateType<T>>;

    /**
     * Group by Email.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {emailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends emailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: emailGroupByArgs["orderBy"] }
        : { orderBy?: emailGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, emailGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetEmailGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the email model
     */
    readonly fields: emailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for email.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__emailClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    user<T extends usersDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, usersDefaultArgs<ExtArgs>>,
    ): Prisma__usersClient<
      | $Result.GetResult<
          Prisma.$usersPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    status<T extends statusDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, statusDefaultArgs<ExtArgs>>,
    ): Prisma__statusClient<
      | $Result.GetResult<
          Prisma.$statusPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the email model
   */
  interface emailFieldRefs {
    readonly emailId: FieldRef<"email", "String">;
    readonly userId: FieldRef<"email", "String">;
    readonly email: FieldRef<"email", "String">;
    readonly verified: FieldRef<"email", "Boolean">;
    readonly isPrimary: FieldRef<"email", "Boolean">;
    readonly createdAt: FieldRef<"email", "DateTime">;
    readonly statusCode: FieldRef<"email", "String">;
  }

  // Custom InputTypes
  /**
   * email findUnique
   */
  export type emailFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the email
     */
    select?: emailSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the email
     */
    omit?: emailOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: emailInclude<ExtArgs> | null;
    /**
     * Filter, which email to fetch.
     */
    where: emailWhereUniqueInput;
  };

  /**
   * email findUniqueOrThrow
   */
  export type emailFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the email
     */
    select?: emailSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the email
     */
    omit?: emailOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: emailInclude<ExtArgs> | null;
    /**
     * Filter, which email to fetch.
     */
    where: emailWhereUniqueInput;
  };

  /**
   * email findFirst
   */
  export type emailFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the email
     */
    select?: emailSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the email
     */
    omit?: emailOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: emailInclude<ExtArgs> | null;
    /**
     * Filter, which email to fetch.
     */
    where?: emailWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of emails to fetch.
     */
    orderBy?: emailOrderByWithRelationInput | emailOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for emails.
     */
    cursor?: emailWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` emails from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` emails.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of emails.
     */
    distinct?: EmailScalarFieldEnum | EmailScalarFieldEnum[];
  };

  /**
   * email findFirstOrThrow
   */
  export type emailFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the email
     */
    select?: emailSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the email
     */
    omit?: emailOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: emailInclude<ExtArgs> | null;
    /**
     * Filter, which email to fetch.
     */
    where?: emailWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of emails to fetch.
     */
    orderBy?: emailOrderByWithRelationInput | emailOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for emails.
     */
    cursor?: emailWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` emails from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` emails.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of emails.
     */
    distinct?: EmailScalarFieldEnum | EmailScalarFieldEnum[];
  };

  /**
   * email findMany
   */
  export type emailFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the email
     */
    select?: emailSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the email
     */
    omit?: emailOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: emailInclude<ExtArgs> | null;
    /**
     * Filter, which emails to fetch.
     */
    where?: emailWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of emails to fetch.
     */
    orderBy?: emailOrderByWithRelationInput | emailOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing emails.
     */
    cursor?: emailWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` emails from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` emails.
     */
    skip?: number;
    distinct?: EmailScalarFieldEnum | EmailScalarFieldEnum[];
  };

  /**
   * email create
   */
  export type emailCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the email
     */
    select?: emailSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the email
     */
    omit?: emailOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: emailInclude<ExtArgs> | null;
    /**
     * The data needed to create a email.
     */
    data: XOR<emailCreateInput, emailUncheckedCreateInput>;
  };

  /**
   * email createMany
   */
  export type emailCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many emails.
     */
    data: emailCreateManyInput | emailCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * email createManyAndReturn
   */
  export type emailCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the email
     */
    select?: emailSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the email
     */
    omit?: emailOmit<ExtArgs> | null;
    /**
     * The data used to create many emails.
     */
    data: emailCreateManyInput | emailCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: emailIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * email update
   */
  export type emailUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the email
     */
    select?: emailSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the email
     */
    omit?: emailOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: emailInclude<ExtArgs> | null;
    /**
     * The data needed to update a email.
     */
    data: XOR<emailUpdateInput, emailUncheckedUpdateInput>;
    /**
     * Choose, which email to update.
     */
    where: emailWhereUniqueInput;
  };

  /**
   * email updateMany
   */
  export type emailUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update emails.
     */
    data: XOR<emailUpdateManyMutationInput, emailUncheckedUpdateManyInput>;
    /**
     * Filter which emails to update
     */
    where?: emailWhereInput;
    /**
     * Limit how many emails to update.
     */
    limit?: number;
  };

  /**
   * email updateManyAndReturn
   */
  export type emailUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the email
     */
    select?: emailSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the email
     */
    omit?: emailOmit<ExtArgs> | null;
    /**
     * The data used to update emails.
     */
    data: XOR<emailUpdateManyMutationInput, emailUncheckedUpdateManyInput>;
    /**
     * Filter which emails to update
     */
    where?: emailWhereInput;
    /**
     * Limit how many emails to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: emailIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * email upsert
   */
  export type emailUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the email
     */
    select?: emailSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the email
     */
    omit?: emailOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: emailInclude<ExtArgs> | null;
    /**
     * The filter to search for the email to update in case it exists.
     */
    where: emailWhereUniqueInput;
    /**
     * In case the email found by the `where` argument doesn't exist, create a new email with this data.
     */
    create: XOR<emailCreateInput, emailUncheckedCreateInput>;
    /**
     * In case the email was found with the provided `where` argument, update it with this data.
     */
    update: XOR<emailUpdateInput, emailUncheckedUpdateInput>;
  };

  /**
   * email delete
   */
  export type emailDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the email
     */
    select?: emailSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the email
     */
    omit?: emailOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: emailInclude<ExtArgs> | null;
    /**
     * Filter which email to delete.
     */
    where: emailWhereUniqueInput;
  };

  /**
   * email deleteMany
   */
  export type emailDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which emails to delete
     */
    where?: emailWhereInput;
    /**
     * Limit how many emails to delete.
     */
    limit?: number;
  };

  /**
   * email without action
   */
  export type emailDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the email
     */
    select?: emailSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the email
     */
    omit?: emailOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: emailInclude<ExtArgs> | null;
  };

  /**
   * Model userRole
   */

  export type AggregateUserRole = {
    _count: UserRoleCountAggregateOutputType | null;
    _avg: UserRoleAvgAggregateOutputType | null;
    _sum: UserRoleSumAggregateOutputType | null;
    _min: UserRoleMinAggregateOutputType | null;
    _max: UserRoleMaxAggregateOutputType | null;
  };

  export type UserRoleAvgAggregateOutputType = {
    roleId: number | null;
  };

  export type UserRoleSumAggregateOutputType = {
    roleId: number | null;
  };

  export type UserRoleMinAggregateOutputType = {
    userId: string | null;
    roleId: number | null;
  };

  export type UserRoleMaxAggregateOutputType = {
    userId: string | null;
    roleId: number | null;
  };

  export type UserRoleCountAggregateOutputType = {
    userId: number;
    roleId: number;
    _all: number;
  };

  export type UserRoleAvgAggregateInputType = {
    roleId?: true;
  };

  export type UserRoleSumAggregateInputType = {
    roleId?: true;
  };

  export type UserRoleMinAggregateInputType = {
    userId?: true;
    roleId?: true;
  };

  export type UserRoleMaxAggregateInputType = {
    userId?: true;
    roleId?: true;
  };

  export type UserRoleCountAggregateInputType = {
    userId?: true;
    roleId?: true;
    _all?: true;
  };

  export type UserRoleAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which userRole to aggregate.
     */
    where?: userRoleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of userRoles to fetch.
     */
    orderBy?:
      | userRoleOrderByWithRelationInput
      | userRoleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: userRoleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` userRoles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` userRoles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned userRoles
     **/
    _count?: true | UserRoleCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: UserRoleAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: UserRoleSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: UserRoleMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: UserRoleMaxAggregateInputType;
  };

  export type GetUserRoleAggregateType<T extends UserRoleAggregateArgs> = {
    [P in keyof T & keyof AggregateUserRole]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRole[P]>
      : GetScalarType<T[P], AggregateUserRole[P]>;
  };

  export type userRoleGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: userRoleWhereInput;
    orderBy?:
      | userRoleOrderByWithAggregationInput
      | userRoleOrderByWithAggregationInput[];
    by: UserRoleScalarFieldEnum[] | UserRoleScalarFieldEnum;
    having?: userRoleScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: UserRoleCountAggregateInputType | true;
    _avg?: UserRoleAvgAggregateInputType;
    _sum?: UserRoleSumAggregateInputType;
    _min?: UserRoleMinAggregateInputType;
    _max?: UserRoleMaxAggregateInputType;
  };

  export type UserRoleGroupByOutputType = {
    userId: string;
    roleId: number;
    _count: UserRoleCountAggregateOutputType | null;
    _avg: UserRoleAvgAggregateOutputType | null;
    _sum: UserRoleSumAggregateOutputType | null;
    _min: UserRoleMinAggregateOutputType | null;
    _max: UserRoleMaxAggregateOutputType | null;
  };

  type GetUserRoleGroupByPayload<T extends userRoleGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<UserRoleGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof UserRoleGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
            : GetScalarType<T[P], UserRoleGroupByOutputType[P]>;
        }
      >
    >;

  export type userRoleSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      userId?: boolean;
      roleId?: boolean;
      user?: boolean | usersDefaultArgs<ExtArgs>;
      role?: boolean | roleDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["userRole"]
  >;

  export type userRoleSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      userId?: boolean;
      roleId?: boolean;
      user?: boolean | usersDefaultArgs<ExtArgs>;
      role?: boolean | roleDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["userRole"]
  >;

  export type userRoleSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      userId?: boolean;
      roleId?: boolean;
      user?: boolean | usersDefaultArgs<ExtArgs>;
      role?: boolean | roleDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["userRole"]
  >;

  export type userRoleSelectScalar = {
    userId?: boolean;
    roleId?: boolean;
  };

  export type userRoleOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<"userId" | "roleId", ExtArgs["result"]["userRole"]>;
  export type userRoleInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | usersDefaultArgs<ExtArgs>;
    role?: boolean | roleDefaultArgs<ExtArgs>;
  };
  export type userRoleIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | usersDefaultArgs<ExtArgs>;
    role?: boolean | roleDefaultArgs<ExtArgs>;
  };
  export type userRoleIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | usersDefaultArgs<ExtArgs>;
    role?: boolean | roleDefaultArgs<ExtArgs>;
  };

  export type $userRolePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "userRole";
    objects: {
      user: Prisma.$usersPayload<ExtArgs>;
      role: Prisma.$rolePayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        userId: string;
        roleId: number;
      },
      ExtArgs["result"]["userRole"]
    >;
    composites: {};
  };

  type userRoleGetPayload<
    S extends boolean | null | undefined | userRoleDefaultArgs,
  > = $Result.GetResult<Prisma.$userRolePayload, S>;

  type userRoleCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<userRoleFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: UserRoleCountAggregateInputType | true;
  };

  export interface userRoleDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["userRole"];
      meta: { name: "userRole" };
    };
    /**
     * Find zero or one UserRole that matches the filter.
     * @param {userRoleFindUniqueArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userRoleFindUniqueArgs>(
      args: SelectSubset<T, userRoleFindUniqueArgs<ExtArgs>>,
    ): Prisma__userRoleClient<
      $Result.GetResult<
        Prisma.$userRolePayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one UserRole that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userRoleFindUniqueOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userRoleFindUniqueOrThrowArgs>(
      args: SelectSubset<T, userRoleFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__userRoleClient<
      $Result.GetResult<
        Prisma.$userRolePayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first UserRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userRoleFindFirstArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userRoleFindFirstArgs>(
      args?: SelectSubset<T, userRoleFindFirstArgs<ExtArgs>>,
    ): Prisma__userRoleClient<
      $Result.GetResult<
        Prisma.$userRolePayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first UserRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userRoleFindFirstOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userRoleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, userRoleFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__userRoleClient<
      $Result.GetResult<
        Prisma.$userRolePayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more UserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRoles
     * const userRoles = await prisma.userRole.findMany()
     *
     * // Get first 10 UserRoles
     * const userRoles = await prisma.userRole.findMany({ take: 10 })
     *
     * // Only select the `userId`
     * const userRoleWithUserIdOnly = await prisma.userRole.findMany({ select: { userId: true } })
     *
     */
    findMany<T extends userRoleFindManyArgs>(
      args?: SelectSubset<T, userRoleFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$userRolePayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a UserRole.
     * @param {userRoleCreateArgs} args - Arguments to create a UserRole.
     * @example
     * // Create one UserRole
     * const UserRole = await prisma.userRole.create({
     *   data: {
     *     // ... data to create a UserRole
     *   }
     * })
     *
     */
    create<T extends userRoleCreateArgs>(
      args: SelectSubset<T, userRoleCreateArgs<ExtArgs>>,
    ): Prisma__userRoleClient<
      $Result.GetResult<
        Prisma.$userRolePayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many UserRoles.
     * @param {userRoleCreateManyArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends userRoleCreateManyArgs>(
      args?: SelectSubset<T, userRoleCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many UserRoles and returns the data saved in the database.
     * @param {userRoleCreateManyAndReturnArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many UserRoles and only return the `userId`
     * const userRoleWithUserIdOnly = await prisma.userRole.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends userRoleCreateManyAndReturnArgs>(
      args?: SelectSubset<T, userRoleCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$userRolePayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a UserRole.
     * @param {userRoleDeleteArgs} args - Arguments to delete one UserRole.
     * @example
     * // Delete one UserRole
     * const UserRole = await prisma.userRole.delete({
     *   where: {
     *     // ... filter to delete one UserRole
     *   }
     * })
     *
     */
    delete<T extends userRoleDeleteArgs>(
      args: SelectSubset<T, userRoleDeleteArgs<ExtArgs>>,
    ): Prisma__userRoleClient<
      $Result.GetResult<
        Prisma.$userRolePayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one UserRole.
     * @param {userRoleUpdateArgs} args - Arguments to update one UserRole.
     * @example
     * // Update one UserRole
     * const userRole = await prisma.userRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends userRoleUpdateArgs>(
      args: SelectSubset<T, userRoleUpdateArgs<ExtArgs>>,
    ): Prisma__userRoleClient<
      $Result.GetResult<
        Prisma.$userRolePayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more UserRoles.
     * @param {userRoleDeleteManyArgs} args - Arguments to filter UserRoles to delete.
     * @example
     * // Delete a few UserRoles
     * const { count } = await prisma.userRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends userRoleDeleteManyArgs>(
      args?: SelectSubset<T, userRoleDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends userRoleUpdateManyArgs>(
      args: SelectSubset<T, userRoleUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more UserRoles and returns the data updated in the database.
     * @param {userRoleUpdateManyAndReturnArgs} args - Arguments to update many UserRoles.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more UserRoles and only return the `userId`
     * const userRoleWithUserIdOnly = await prisma.userRole.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends userRoleUpdateManyAndReturnArgs>(
      args: SelectSubset<T, userRoleUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$userRolePayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one UserRole.
     * @param {userRoleUpsertArgs} args - Arguments to update or create a UserRole.
     * @example
     * // Update or create a UserRole
     * const userRole = await prisma.userRole.upsert({
     *   create: {
     *     // ... data to create a UserRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRole we want to update
     *   }
     * })
     */
    upsert<T extends userRoleUpsertArgs>(
      args: SelectSubset<T, userRoleUpsertArgs<ExtArgs>>,
    ): Prisma__userRoleClient<
      $Result.GetResult<
        Prisma.$userRolePayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userRoleCountArgs} args - Arguments to filter UserRoles to count.
     * @example
     * // Count the number of UserRoles
     * const count = await prisma.userRole.count({
     *   where: {
     *     // ... the filter for the UserRoles we want to count
     *   }
     * })
     **/
    count<T extends userRoleCountArgs>(
      args?: Subset<T, userRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], UserRoleCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends UserRoleAggregateArgs>(
      args: Subset<T, UserRoleAggregateArgs>,
    ): Prisma.PrismaPromise<GetUserRoleAggregateType<T>>;

    /**
     * Group by UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends userRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userRoleGroupByArgs["orderBy"] }
        : { orderBy?: userRoleGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, userRoleGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetUserRoleGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the userRole model
     */
    readonly fields: userRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for userRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userRoleClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    user<T extends usersDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, usersDefaultArgs<ExtArgs>>,
    ): Prisma__usersClient<
      | $Result.GetResult<
          Prisma.$usersPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    role<T extends roleDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, roleDefaultArgs<ExtArgs>>,
    ): Prisma__roleClient<
      | $Result.GetResult<
          Prisma.$rolePayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the userRole model
   */
  interface userRoleFieldRefs {
    readonly userId: FieldRef<"userRole", "String">;
    readonly roleId: FieldRef<"userRole", "Int">;
  }

  // Custom InputTypes
  /**
   * userRole findUnique
   */
  export type userRoleFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the userRole
     */
    select?: userRoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the userRole
     */
    omit?: userRoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userRoleInclude<ExtArgs> | null;
    /**
     * Filter, which userRole to fetch.
     */
    where: userRoleWhereUniqueInput;
  };

  /**
   * userRole findUniqueOrThrow
   */
  export type userRoleFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the userRole
     */
    select?: userRoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the userRole
     */
    omit?: userRoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userRoleInclude<ExtArgs> | null;
    /**
     * Filter, which userRole to fetch.
     */
    where: userRoleWhereUniqueInput;
  };

  /**
   * userRole findFirst
   */
  export type userRoleFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the userRole
     */
    select?: userRoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the userRole
     */
    omit?: userRoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userRoleInclude<ExtArgs> | null;
    /**
     * Filter, which userRole to fetch.
     */
    where?: userRoleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of userRoles to fetch.
     */
    orderBy?:
      | userRoleOrderByWithRelationInput
      | userRoleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for userRoles.
     */
    cursor?: userRoleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` userRoles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` userRoles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of userRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[];
  };

  /**
   * userRole findFirstOrThrow
   */
  export type userRoleFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the userRole
     */
    select?: userRoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the userRole
     */
    omit?: userRoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userRoleInclude<ExtArgs> | null;
    /**
     * Filter, which userRole to fetch.
     */
    where?: userRoleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of userRoles to fetch.
     */
    orderBy?:
      | userRoleOrderByWithRelationInput
      | userRoleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for userRoles.
     */
    cursor?: userRoleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` userRoles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` userRoles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of userRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[];
  };

  /**
   * userRole findMany
   */
  export type userRoleFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the userRole
     */
    select?: userRoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the userRole
     */
    omit?: userRoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userRoleInclude<ExtArgs> | null;
    /**
     * Filter, which userRoles to fetch.
     */
    where?: userRoleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of userRoles to fetch.
     */
    orderBy?:
      | userRoleOrderByWithRelationInput
      | userRoleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing userRoles.
     */
    cursor?: userRoleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` userRoles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` userRoles.
     */
    skip?: number;
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[];
  };

  /**
   * userRole create
   */
  export type userRoleCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the userRole
     */
    select?: userRoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the userRole
     */
    omit?: userRoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userRoleInclude<ExtArgs> | null;
    /**
     * The data needed to create a userRole.
     */
    data: XOR<userRoleCreateInput, userRoleUncheckedCreateInput>;
  };

  /**
   * userRole createMany
   */
  export type userRoleCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many userRoles.
     */
    data: userRoleCreateManyInput | userRoleCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * userRole createManyAndReturn
   */
  export type userRoleCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the userRole
     */
    select?: userRoleSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the userRole
     */
    omit?: userRoleOmit<ExtArgs> | null;
    /**
     * The data used to create many userRoles.
     */
    data: userRoleCreateManyInput | userRoleCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userRoleIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * userRole update
   */
  export type userRoleUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the userRole
     */
    select?: userRoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the userRole
     */
    omit?: userRoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userRoleInclude<ExtArgs> | null;
    /**
     * The data needed to update a userRole.
     */
    data: XOR<userRoleUpdateInput, userRoleUncheckedUpdateInput>;
    /**
     * Choose, which userRole to update.
     */
    where: userRoleWhereUniqueInput;
  };

  /**
   * userRole updateMany
   */
  export type userRoleUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update userRoles.
     */
    data: XOR<
      userRoleUpdateManyMutationInput,
      userRoleUncheckedUpdateManyInput
    >;
    /**
     * Filter which userRoles to update
     */
    where?: userRoleWhereInput;
    /**
     * Limit how many userRoles to update.
     */
    limit?: number;
  };

  /**
   * userRole updateManyAndReturn
   */
  export type userRoleUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the userRole
     */
    select?: userRoleSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the userRole
     */
    omit?: userRoleOmit<ExtArgs> | null;
    /**
     * The data used to update userRoles.
     */
    data: XOR<
      userRoleUpdateManyMutationInput,
      userRoleUncheckedUpdateManyInput
    >;
    /**
     * Filter which userRoles to update
     */
    where?: userRoleWhereInput;
    /**
     * Limit how many userRoles to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userRoleIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * userRole upsert
   */
  export type userRoleUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the userRole
     */
    select?: userRoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the userRole
     */
    omit?: userRoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userRoleInclude<ExtArgs> | null;
    /**
     * The filter to search for the userRole to update in case it exists.
     */
    where: userRoleWhereUniqueInput;
    /**
     * In case the userRole found by the `where` argument doesn't exist, create a new userRole with this data.
     */
    create: XOR<userRoleCreateInput, userRoleUncheckedCreateInput>;
    /**
     * In case the userRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userRoleUpdateInput, userRoleUncheckedUpdateInput>;
  };

  /**
   * userRole delete
   */
  export type userRoleDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the userRole
     */
    select?: userRoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the userRole
     */
    omit?: userRoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userRoleInclude<ExtArgs> | null;
    /**
     * Filter which userRole to delete.
     */
    where: userRoleWhereUniqueInput;
  };

  /**
   * userRole deleteMany
   */
  export type userRoleDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which userRoles to delete
     */
    where?: userRoleWhereInput;
    /**
     * Limit how many userRoles to delete.
     */
    limit?: number;
  };

  /**
   * userRole without action
   */
  export type userRoleDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the userRole
     */
    select?: userRoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the userRole
     */
    omit?: userRoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userRoleInclude<ExtArgs> | null;
  };

  /**
   * Model role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null;
    _avg: RoleAvgAggregateOutputType | null;
    _sum: RoleSumAggregateOutputType | null;
    _min: RoleMinAggregateOutputType | null;
    _max: RoleMaxAggregateOutputType | null;
  };

  export type RoleAvgAggregateOutputType = {
    roleId: number | null;
  };

  export type RoleSumAggregateOutputType = {
    roleId: number | null;
  };

  export type RoleMinAggregateOutputType = {
    roleId: number | null;
    roleName: string | null;
    description: string | null;
    statusCode: string | null;
  };

  export type RoleMaxAggregateOutputType = {
    roleId: number | null;
    roleName: string | null;
    description: string | null;
    statusCode: string | null;
  };

  export type RoleCountAggregateOutputType = {
    roleId: number;
    roleName: number;
    description: number;
    statusCode: number;
    _all: number;
  };

  export type RoleAvgAggregateInputType = {
    roleId?: true;
  };

  export type RoleSumAggregateInputType = {
    roleId?: true;
  };

  export type RoleMinAggregateInputType = {
    roleId?: true;
    roleName?: true;
    description?: true;
    statusCode?: true;
  };

  export type RoleMaxAggregateInputType = {
    roleId?: true;
    roleName?: true;
    description?: true;
    statusCode?: true;
  };

  export type RoleCountAggregateInputType = {
    roleId?: true;
    roleName?: true;
    description?: true;
    statusCode?: true;
    _all?: true;
  };

  export type RoleAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which role to aggregate.
     */
    where?: roleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: roleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` roles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` roles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned roles
     **/
    _count?: true | RoleCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: RoleAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: RoleSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: RoleMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: RoleMaxAggregateInputType;
  };

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
    [P in keyof T & keyof AggregateRole]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>;
  };

  export type roleGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: roleWhereInput;
    orderBy?:
      | roleOrderByWithAggregationInput
      | roleOrderByWithAggregationInput[];
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum;
    having?: roleScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: RoleCountAggregateInputType | true;
    _avg?: RoleAvgAggregateInputType;
    _sum?: RoleSumAggregateInputType;
    _min?: RoleMinAggregateInputType;
    _max?: RoleMaxAggregateInputType;
  };

  export type RoleGroupByOutputType = {
    roleId: number;
    roleName: string;
    description: string;
    statusCode: string;
    _count: RoleCountAggregateOutputType | null;
    _avg: RoleAvgAggregateOutputType | null;
    _sum: RoleSumAggregateOutputType | null;
    _min: RoleMinAggregateOutputType | null;
    _max: RoleMaxAggregateOutputType | null;
  };

  type GetRoleGroupByPayload<T extends roleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T["by"]> & {
        [P in keyof T & keyof RoleGroupByOutputType]: P extends "_count"
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
          : GetScalarType<T[P], RoleGroupByOutputType[P]>;
      }
    >
  >;

  export type roleSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      roleId?: boolean;
      roleName?: boolean;
      description?: boolean;
      statusCode?: boolean;
      userRoles?: boolean | role$userRolesArgs<ExtArgs>;
      status?: boolean | statusDefaultArgs<ExtArgs>;
      _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["role"]
  >;

  export type roleSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      roleId?: boolean;
      roleName?: boolean;
      description?: boolean;
      statusCode?: boolean;
      status?: boolean | statusDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["role"]
  >;

  export type roleSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      roleId?: boolean;
      roleName?: boolean;
      description?: boolean;
      statusCode?: boolean;
      status?: boolean | statusDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["role"]
  >;

  export type roleSelectScalar = {
    roleId?: boolean;
    roleName?: boolean;
    description?: boolean;
    statusCode?: boolean;
  };

  export type roleOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "roleId" | "roleName" | "description" | "statusCode",
    ExtArgs["result"]["role"]
  >;
  export type roleInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    userRoles?: boolean | role$userRolesArgs<ExtArgs>;
    status?: boolean | statusDefaultArgs<ExtArgs>;
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type roleIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    status?: boolean | statusDefaultArgs<ExtArgs>;
  };
  export type roleIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    status?: boolean | statusDefaultArgs<ExtArgs>;
  };

  export type $rolePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "role";
    objects: {
      userRoles: Prisma.$userRolePayload<ExtArgs>[];
      status: Prisma.$statusPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        roleId: number;
        roleName: string;
        description: string;
        statusCode: string;
      },
      ExtArgs["result"]["role"]
    >;
    composites: {};
  };

  type roleGetPayload<S extends boolean | null | undefined | roleDefaultArgs> =
    $Result.GetResult<Prisma.$rolePayload, S>;

  type roleCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<roleFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: RoleCountAggregateInputType | true;
  };

  export interface roleDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["role"];
      meta: { name: "role" };
    };
    /**
     * Find zero or one Role that matches the filter.
     * @param {roleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends roleFindUniqueArgs>(
      args: SelectSubset<T, roleFindUniqueArgs<ExtArgs>>,
    ): Prisma__roleClient<
      $Result.GetResult<
        Prisma.$rolePayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {roleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends roleFindUniqueOrThrowArgs>(
      args: SelectSubset<T, roleFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__roleClient<
      $Result.GetResult<
        Prisma.$rolePayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends roleFindFirstArgs>(
      args?: SelectSubset<T, roleFindFirstArgs<ExtArgs>>,
    ): Prisma__roleClient<
      $Result.GetResult<
        Prisma.$rolePayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends roleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, roleFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__roleClient<
      $Result.GetResult<
        Prisma.$rolePayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     *
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     *
     * // Only select the `roleId`
     * const roleWithRoleIdOnly = await prisma.role.findMany({ select: { roleId: true } })
     *
     */
    findMany<T extends roleFindManyArgs>(
      args?: SelectSubset<T, roleFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$rolePayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Role.
     * @param {roleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     *
     */
    create<T extends roleCreateArgs>(
      args: SelectSubset<T, roleCreateArgs<ExtArgs>>,
    ): Prisma__roleClient<
      $Result.GetResult<
        Prisma.$rolePayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Roles.
     * @param {roleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends roleCreateManyArgs>(
      args?: SelectSubset<T, roleCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {roleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Roles and only return the `roleId`
     * const roleWithRoleIdOnly = await prisma.role.createManyAndReturn({
     *   select: { roleId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends roleCreateManyAndReturnArgs>(
      args?: SelectSubset<T, roleCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$rolePayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Role.
     * @param {roleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     *
     */
    delete<T extends roleDeleteArgs>(
      args: SelectSubset<T, roleDeleteArgs<ExtArgs>>,
    ): Prisma__roleClient<
      $Result.GetResult<
        Prisma.$rolePayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Role.
     * @param {roleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends roleUpdateArgs>(
      args: SelectSubset<T, roleUpdateArgs<ExtArgs>>,
    ): Prisma__roleClient<
      $Result.GetResult<
        Prisma.$rolePayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Roles.
     * @param {roleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends roleDeleteManyArgs>(
      args?: SelectSubset<T, roleDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends roleUpdateManyArgs>(
      args: SelectSubset<T, roleUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {roleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Roles and only return the `roleId`
     * const roleWithRoleIdOnly = await prisma.role.updateManyAndReturn({
     *   select: { roleId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends roleUpdateManyAndReturnArgs>(
      args: SelectSubset<T, roleUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$rolePayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Role.
     * @param {roleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends roleUpsertArgs>(
      args: SelectSubset<T, roleUpsertArgs<ExtArgs>>,
    ): Prisma__roleClient<
      $Result.GetResult<
        Prisma.$rolePayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
     **/
    count<T extends roleCountArgs>(
      args?: Subset<T, roleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], RoleCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends RoleAggregateArgs>(
      args: Subset<T, RoleAggregateArgs>,
    ): Prisma.PrismaPromise<GetRoleAggregateType<T>>;

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends roleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: roleGroupByArgs["orderBy"] }
        : { orderBy?: roleGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, roleGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetRoleGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the role model
     */
    readonly fields: roleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__roleClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    userRoles<T extends role$userRolesArgs<ExtArgs> = {}>(
      args?: Subset<T, role$userRolesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$userRolePayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    status<T extends statusDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, statusDefaultArgs<ExtArgs>>,
    ): Prisma__statusClient<
      | $Result.GetResult<
          Prisma.$statusPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the role model
   */
  interface roleFieldRefs {
    readonly roleId: FieldRef<"role", "Int">;
    readonly roleName: FieldRef<"role", "String">;
    readonly description: FieldRef<"role", "String">;
    readonly statusCode: FieldRef<"role", "String">;
  }

  // Custom InputTypes
  /**
   * role findUnique
   */
  export type roleFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null;
    /**
     * Filter, which role to fetch.
     */
    where: roleWhereUniqueInput;
  };

  /**
   * role findUniqueOrThrow
   */
  export type roleFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null;
    /**
     * Filter, which role to fetch.
     */
    where: roleWhereUniqueInput;
  };

  /**
   * role findFirst
   */
  export type roleFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null;
    /**
     * Filter, which role to fetch.
     */
    where?: roleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for roles.
     */
    cursor?: roleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` roles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` roles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[];
  };

  /**
   * role findFirstOrThrow
   */
  export type roleFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null;
    /**
     * Filter, which role to fetch.
     */
    where?: roleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for roles.
     */
    cursor?: roleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` roles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` roles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[];
  };

  /**
   * role findMany
   */
  export type roleFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null;
    /**
     * Filter, which roles to fetch.
     */
    where?: roleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of roles to fetch.
     */
    orderBy?: roleOrderByWithRelationInput | roleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing roles.
     */
    cursor?: roleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` roles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` roles.
     */
    skip?: number;
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[];
  };

  /**
   * role create
   */
  export type roleCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null;
    /**
     * The data needed to create a role.
     */
    data: XOR<roleCreateInput, roleUncheckedCreateInput>;
  };

  /**
   * role createMany
   */
  export type roleCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many roles.
     */
    data: roleCreateManyInput | roleCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * role createManyAndReturn
   */
  export type roleCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null;
    /**
     * The data used to create many roles.
     */
    data: roleCreateManyInput | roleCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * role update
   */
  export type roleUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null;
    /**
     * The data needed to update a role.
     */
    data: XOR<roleUpdateInput, roleUncheckedUpdateInput>;
    /**
     * Choose, which role to update.
     */
    where: roleWhereUniqueInput;
  };

  /**
   * role updateMany
   */
  export type roleUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update roles.
     */
    data: XOR<roleUpdateManyMutationInput, roleUncheckedUpdateManyInput>;
    /**
     * Filter which roles to update
     */
    where?: roleWhereInput;
    /**
     * Limit how many roles to update.
     */
    limit?: number;
  };

  /**
   * role updateManyAndReturn
   */
  export type roleUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null;
    /**
     * The data used to update roles.
     */
    data: XOR<roleUpdateManyMutationInput, roleUncheckedUpdateManyInput>;
    /**
     * Filter which roles to update
     */
    where?: roleWhereInput;
    /**
     * Limit how many roles to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * role upsert
   */
  export type roleUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null;
    /**
     * The filter to search for the role to update in case it exists.
     */
    where: roleWhereUniqueInput;
    /**
     * In case the role found by the `where` argument doesn't exist, create a new role with this data.
     */
    create: XOR<roleCreateInput, roleUncheckedCreateInput>;
    /**
     * In case the role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<roleUpdateInput, roleUncheckedUpdateInput>;
  };

  /**
   * role delete
   */
  export type roleDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null;
    /**
     * Filter which role to delete.
     */
    where: roleWhereUniqueInput;
  };

  /**
   * role deleteMany
   */
  export type roleDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which roles to delete
     */
    where?: roleWhereInput;
    /**
     * Limit how many roles to delete.
     */
    limit?: number;
  };

  /**
   * role.userRoles
   */
  export type role$userRolesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the userRole
     */
    select?: userRoleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the userRole
     */
    omit?: userRoleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userRoleInclude<ExtArgs> | null;
    where?: userRoleWhereInput;
    orderBy?:
      | userRoleOrderByWithRelationInput
      | userRoleOrderByWithRelationInput[];
    cursor?: userRoleWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[];
  };

  /**
   * role without action
   */
  export type roleDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the role
     */
    select?: roleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the role
     */
    omit?: roleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roleInclude<ExtArgs> | null;
  };

  /**
   * Model qrCode
   */

  export type AggregateQrCode = {
    _count: QrCodeCountAggregateOutputType | null;
    _min: QrCodeMinAggregateOutputType | null;
    _max: QrCodeMaxAggregateOutputType | null;
  };

  export type QrCodeMinAggregateOutputType = {
    qrCodeId: string | null;
    qrLink: string | null;
    createdBy: string | null;
    createdAt: Date | null;
    statusCode: string | null;
  };

  export type QrCodeMaxAggregateOutputType = {
    qrCodeId: string | null;
    qrLink: string | null;
    createdBy: string | null;
    createdAt: Date | null;
    statusCode: string | null;
  };

  export type QrCodeCountAggregateOutputType = {
    qrCodeId: number;
    qrLink: number;
    createdBy: number;
    createdAt: number;
    statusCode: number;
    _all: number;
  };

  export type QrCodeMinAggregateInputType = {
    qrCodeId?: true;
    qrLink?: true;
    createdBy?: true;
    createdAt?: true;
    statusCode?: true;
  };

  export type QrCodeMaxAggregateInputType = {
    qrCodeId?: true;
    qrLink?: true;
    createdBy?: true;
    createdAt?: true;
    statusCode?: true;
  };

  export type QrCodeCountAggregateInputType = {
    qrCodeId?: true;
    qrLink?: true;
    createdBy?: true;
    createdAt?: true;
    statusCode?: true;
    _all?: true;
  };

  export type QrCodeAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which qrCode to aggregate.
     */
    where?: qrCodeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of qrCodes to fetch.
     */
    orderBy?: qrCodeOrderByWithRelationInput | qrCodeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: qrCodeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` qrCodes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` qrCodes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned qrCodes
     **/
    _count?: true | QrCodeCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: QrCodeMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: QrCodeMaxAggregateInputType;
  };

  export type GetQrCodeAggregateType<T extends QrCodeAggregateArgs> = {
    [P in keyof T & keyof AggregateQrCode]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQrCode[P]>
      : GetScalarType<T[P], AggregateQrCode[P]>;
  };

  export type qrCodeGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: qrCodeWhereInput;
    orderBy?:
      | qrCodeOrderByWithAggregationInput
      | qrCodeOrderByWithAggregationInput[];
    by: QrCodeScalarFieldEnum[] | QrCodeScalarFieldEnum;
    having?: qrCodeScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: QrCodeCountAggregateInputType | true;
    _min?: QrCodeMinAggregateInputType;
    _max?: QrCodeMaxAggregateInputType;
  };

  export type QrCodeGroupByOutputType = {
    qrCodeId: string;
    qrLink: string;
    createdBy: string;
    createdAt: Date;
    statusCode: string;
    _count: QrCodeCountAggregateOutputType | null;
    _min: QrCodeMinAggregateOutputType | null;
    _max: QrCodeMaxAggregateOutputType | null;
  };

  type GetQrCodeGroupByPayload<T extends qrCodeGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<QrCodeGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof QrCodeGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QrCodeGroupByOutputType[P]>
            : GetScalarType<T[P], QrCodeGroupByOutputType[P]>;
        }
      >
    >;

  export type qrCodeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      qrCodeId?: boolean;
      qrLink?: boolean;
      createdBy?: boolean;
      createdAt?: boolean;
      statusCode?: boolean;
      exhibit?: boolean | qrCode$exhibitArgs<ExtArgs>;
      status?: boolean | statusDefaultArgs<ExtArgs>;
      _count?: boolean | QrCodeCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["qrCode"]
  >;

  export type qrCodeSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      qrCodeId?: boolean;
      qrLink?: boolean;
      createdBy?: boolean;
      createdAt?: boolean;
      statusCode?: boolean;
      status?: boolean | statusDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["qrCode"]
  >;

  export type qrCodeSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      qrCodeId?: boolean;
      qrLink?: boolean;
      createdBy?: boolean;
      createdAt?: boolean;
      statusCode?: boolean;
      status?: boolean | statusDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["qrCode"]
  >;

  export type qrCodeSelectScalar = {
    qrCodeId?: boolean;
    qrLink?: boolean;
    createdBy?: boolean;
    createdAt?: boolean;
    statusCode?: boolean;
  };

  export type qrCodeOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "qrCodeId" | "qrLink" | "createdBy" | "createdAt" | "statusCode",
    ExtArgs["result"]["qrCode"]
  >;
  export type qrCodeInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    exhibit?: boolean | qrCode$exhibitArgs<ExtArgs>;
    status?: boolean | statusDefaultArgs<ExtArgs>;
    _count?: boolean | QrCodeCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type qrCodeIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    status?: boolean | statusDefaultArgs<ExtArgs>;
  };
  export type qrCodeIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    status?: boolean | statusDefaultArgs<ExtArgs>;
  };

  export type $qrCodePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "qrCode";
    objects: {
      exhibit: Prisma.$exhibitPayload<ExtArgs>[];
      status: Prisma.$statusPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        qrCodeId: string;
        qrLink: string;
        createdBy: string;
        createdAt: Date;
        statusCode: string;
      },
      ExtArgs["result"]["qrCode"]
    >;
    composites: {};
  };

  type qrCodeGetPayload<
    S extends boolean | null | undefined | qrCodeDefaultArgs,
  > = $Result.GetResult<Prisma.$qrCodePayload, S>;

  type qrCodeCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<qrCodeFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: QrCodeCountAggregateInputType | true;
  };

  export interface qrCodeDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["qrCode"];
      meta: { name: "qrCode" };
    };
    /**
     * Find zero or one QrCode that matches the filter.
     * @param {qrCodeFindUniqueArgs} args - Arguments to find a QrCode
     * @example
     * // Get one QrCode
     * const qrCode = await prisma.qrCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends qrCodeFindUniqueArgs>(
      args: SelectSubset<T, qrCodeFindUniqueArgs<ExtArgs>>,
    ): Prisma__qrCodeClient<
      $Result.GetResult<
        Prisma.$qrCodePayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one QrCode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {qrCodeFindUniqueOrThrowArgs} args - Arguments to find a QrCode
     * @example
     * // Get one QrCode
     * const qrCode = await prisma.qrCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends qrCodeFindUniqueOrThrowArgs>(
      args: SelectSubset<T, qrCodeFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__qrCodeClient<
      $Result.GetResult<
        Prisma.$qrCodePayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first QrCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qrCodeFindFirstArgs} args - Arguments to find a QrCode
     * @example
     * // Get one QrCode
     * const qrCode = await prisma.qrCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends qrCodeFindFirstArgs>(
      args?: SelectSubset<T, qrCodeFindFirstArgs<ExtArgs>>,
    ): Prisma__qrCodeClient<
      $Result.GetResult<
        Prisma.$qrCodePayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first QrCode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qrCodeFindFirstOrThrowArgs} args - Arguments to find a QrCode
     * @example
     * // Get one QrCode
     * const qrCode = await prisma.qrCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends qrCodeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, qrCodeFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__qrCodeClient<
      $Result.GetResult<
        Prisma.$qrCodePayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more QrCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qrCodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QrCodes
     * const qrCodes = await prisma.qrCode.findMany()
     *
     * // Get first 10 QrCodes
     * const qrCodes = await prisma.qrCode.findMany({ take: 10 })
     *
     * // Only select the `qrCodeId`
     * const qrCodeWithQrCodeIdOnly = await prisma.qrCode.findMany({ select: { qrCodeId: true } })
     *
     */
    findMany<T extends qrCodeFindManyArgs>(
      args?: SelectSubset<T, qrCodeFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$qrCodePayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a QrCode.
     * @param {qrCodeCreateArgs} args - Arguments to create a QrCode.
     * @example
     * // Create one QrCode
     * const QrCode = await prisma.qrCode.create({
     *   data: {
     *     // ... data to create a QrCode
     *   }
     * })
     *
     */
    create<T extends qrCodeCreateArgs>(
      args: SelectSubset<T, qrCodeCreateArgs<ExtArgs>>,
    ): Prisma__qrCodeClient<
      $Result.GetResult<
        Prisma.$qrCodePayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many QrCodes.
     * @param {qrCodeCreateManyArgs} args - Arguments to create many QrCodes.
     * @example
     * // Create many QrCodes
     * const qrCode = await prisma.qrCode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends qrCodeCreateManyArgs>(
      args?: SelectSubset<T, qrCodeCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many QrCodes and returns the data saved in the database.
     * @param {qrCodeCreateManyAndReturnArgs} args - Arguments to create many QrCodes.
     * @example
     * // Create many QrCodes
     * const qrCode = await prisma.qrCode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many QrCodes and only return the `qrCodeId`
     * const qrCodeWithQrCodeIdOnly = await prisma.qrCode.createManyAndReturn({
     *   select: { qrCodeId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends qrCodeCreateManyAndReturnArgs>(
      args?: SelectSubset<T, qrCodeCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$qrCodePayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a QrCode.
     * @param {qrCodeDeleteArgs} args - Arguments to delete one QrCode.
     * @example
     * // Delete one QrCode
     * const QrCode = await prisma.qrCode.delete({
     *   where: {
     *     // ... filter to delete one QrCode
     *   }
     * })
     *
     */
    delete<T extends qrCodeDeleteArgs>(
      args: SelectSubset<T, qrCodeDeleteArgs<ExtArgs>>,
    ): Prisma__qrCodeClient<
      $Result.GetResult<
        Prisma.$qrCodePayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one QrCode.
     * @param {qrCodeUpdateArgs} args - Arguments to update one QrCode.
     * @example
     * // Update one QrCode
     * const qrCode = await prisma.qrCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends qrCodeUpdateArgs>(
      args: SelectSubset<T, qrCodeUpdateArgs<ExtArgs>>,
    ): Prisma__qrCodeClient<
      $Result.GetResult<
        Prisma.$qrCodePayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more QrCodes.
     * @param {qrCodeDeleteManyArgs} args - Arguments to filter QrCodes to delete.
     * @example
     * // Delete a few QrCodes
     * const { count } = await prisma.qrCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends qrCodeDeleteManyArgs>(
      args?: SelectSubset<T, qrCodeDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more QrCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qrCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QrCodes
     * const qrCode = await prisma.qrCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends qrCodeUpdateManyArgs>(
      args: SelectSubset<T, qrCodeUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more QrCodes and returns the data updated in the database.
     * @param {qrCodeUpdateManyAndReturnArgs} args - Arguments to update many QrCodes.
     * @example
     * // Update many QrCodes
     * const qrCode = await prisma.qrCode.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more QrCodes and only return the `qrCodeId`
     * const qrCodeWithQrCodeIdOnly = await prisma.qrCode.updateManyAndReturn({
     *   select: { qrCodeId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends qrCodeUpdateManyAndReturnArgs>(
      args: SelectSubset<T, qrCodeUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$qrCodePayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one QrCode.
     * @param {qrCodeUpsertArgs} args - Arguments to update or create a QrCode.
     * @example
     * // Update or create a QrCode
     * const qrCode = await prisma.qrCode.upsert({
     *   create: {
     *     // ... data to create a QrCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QrCode we want to update
     *   }
     * })
     */
    upsert<T extends qrCodeUpsertArgs>(
      args: SelectSubset<T, qrCodeUpsertArgs<ExtArgs>>,
    ): Prisma__qrCodeClient<
      $Result.GetResult<
        Prisma.$qrCodePayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of QrCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qrCodeCountArgs} args - Arguments to filter QrCodes to count.
     * @example
     * // Count the number of QrCodes
     * const count = await prisma.qrCode.count({
     *   where: {
     *     // ... the filter for the QrCodes we want to count
     *   }
     * })
     **/
    count<T extends qrCodeCountArgs>(
      args?: Subset<T, qrCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], QrCodeCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a QrCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QrCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends QrCodeAggregateArgs>(
      args: Subset<T, QrCodeAggregateArgs>,
    ): Prisma.PrismaPromise<GetQrCodeAggregateType<T>>;

    /**
     * Group by QrCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qrCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends qrCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: qrCodeGroupByArgs["orderBy"] }
        : { orderBy?: qrCodeGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, qrCodeGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetQrCodeGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the qrCode model
     */
    readonly fields: qrCodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for qrCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__qrCodeClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    exhibit<T extends qrCode$exhibitArgs<ExtArgs> = {}>(
      args?: Subset<T, qrCode$exhibitArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$exhibitPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    status<T extends statusDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, statusDefaultArgs<ExtArgs>>,
    ): Prisma__statusClient<
      | $Result.GetResult<
          Prisma.$statusPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the qrCode model
   */
  interface qrCodeFieldRefs {
    readonly qrCodeId: FieldRef<"qrCode", "String">;
    readonly qrLink: FieldRef<"qrCode", "String">;
    readonly createdBy: FieldRef<"qrCode", "String">;
    readonly createdAt: FieldRef<"qrCode", "DateTime">;
    readonly statusCode: FieldRef<"qrCode", "String">;
  }

  // Custom InputTypes
  /**
   * qrCode findUnique
   */
  export type qrCodeFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the qrCode
     */
    select?: qrCodeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the qrCode
     */
    omit?: qrCodeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qrCodeInclude<ExtArgs> | null;
    /**
     * Filter, which qrCode to fetch.
     */
    where: qrCodeWhereUniqueInput;
  };

  /**
   * qrCode findUniqueOrThrow
   */
  export type qrCodeFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the qrCode
     */
    select?: qrCodeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the qrCode
     */
    omit?: qrCodeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qrCodeInclude<ExtArgs> | null;
    /**
     * Filter, which qrCode to fetch.
     */
    where: qrCodeWhereUniqueInput;
  };

  /**
   * qrCode findFirst
   */
  export type qrCodeFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the qrCode
     */
    select?: qrCodeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the qrCode
     */
    omit?: qrCodeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qrCodeInclude<ExtArgs> | null;
    /**
     * Filter, which qrCode to fetch.
     */
    where?: qrCodeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of qrCodes to fetch.
     */
    orderBy?: qrCodeOrderByWithRelationInput | qrCodeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for qrCodes.
     */
    cursor?: qrCodeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` qrCodes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` qrCodes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of qrCodes.
     */
    distinct?: QrCodeScalarFieldEnum | QrCodeScalarFieldEnum[];
  };

  /**
   * qrCode findFirstOrThrow
   */
  export type qrCodeFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the qrCode
     */
    select?: qrCodeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the qrCode
     */
    omit?: qrCodeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qrCodeInclude<ExtArgs> | null;
    /**
     * Filter, which qrCode to fetch.
     */
    where?: qrCodeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of qrCodes to fetch.
     */
    orderBy?: qrCodeOrderByWithRelationInput | qrCodeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for qrCodes.
     */
    cursor?: qrCodeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` qrCodes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` qrCodes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of qrCodes.
     */
    distinct?: QrCodeScalarFieldEnum | QrCodeScalarFieldEnum[];
  };

  /**
   * qrCode findMany
   */
  export type qrCodeFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the qrCode
     */
    select?: qrCodeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the qrCode
     */
    omit?: qrCodeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qrCodeInclude<ExtArgs> | null;
    /**
     * Filter, which qrCodes to fetch.
     */
    where?: qrCodeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of qrCodes to fetch.
     */
    orderBy?: qrCodeOrderByWithRelationInput | qrCodeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing qrCodes.
     */
    cursor?: qrCodeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` qrCodes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` qrCodes.
     */
    skip?: number;
    distinct?: QrCodeScalarFieldEnum | QrCodeScalarFieldEnum[];
  };

  /**
   * qrCode create
   */
  export type qrCodeCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the qrCode
     */
    select?: qrCodeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the qrCode
     */
    omit?: qrCodeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qrCodeInclude<ExtArgs> | null;
    /**
     * The data needed to create a qrCode.
     */
    data: XOR<qrCodeCreateInput, qrCodeUncheckedCreateInput>;
  };

  /**
   * qrCode createMany
   */
  export type qrCodeCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many qrCodes.
     */
    data: qrCodeCreateManyInput | qrCodeCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * qrCode createManyAndReturn
   */
  export type qrCodeCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the qrCode
     */
    select?: qrCodeSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the qrCode
     */
    omit?: qrCodeOmit<ExtArgs> | null;
    /**
     * The data used to create many qrCodes.
     */
    data: qrCodeCreateManyInput | qrCodeCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qrCodeIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * qrCode update
   */
  export type qrCodeUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the qrCode
     */
    select?: qrCodeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the qrCode
     */
    omit?: qrCodeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qrCodeInclude<ExtArgs> | null;
    /**
     * The data needed to update a qrCode.
     */
    data: XOR<qrCodeUpdateInput, qrCodeUncheckedUpdateInput>;
    /**
     * Choose, which qrCode to update.
     */
    where: qrCodeWhereUniqueInput;
  };

  /**
   * qrCode updateMany
   */
  export type qrCodeUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update qrCodes.
     */
    data: XOR<qrCodeUpdateManyMutationInput, qrCodeUncheckedUpdateManyInput>;
    /**
     * Filter which qrCodes to update
     */
    where?: qrCodeWhereInput;
    /**
     * Limit how many qrCodes to update.
     */
    limit?: number;
  };

  /**
   * qrCode updateManyAndReturn
   */
  export type qrCodeUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the qrCode
     */
    select?: qrCodeSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the qrCode
     */
    omit?: qrCodeOmit<ExtArgs> | null;
    /**
     * The data used to update qrCodes.
     */
    data: XOR<qrCodeUpdateManyMutationInput, qrCodeUncheckedUpdateManyInput>;
    /**
     * Filter which qrCodes to update
     */
    where?: qrCodeWhereInput;
    /**
     * Limit how many qrCodes to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qrCodeIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * qrCode upsert
   */
  export type qrCodeUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the qrCode
     */
    select?: qrCodeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the qrCode
     */
    omit?: qrCodeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qrCodeInclude<ExtArgs> | null;
    /**
     * The filter to search for the qrCode to update in case it exists.
     */
    where: qrCodeWhereUniqueInput;
    /**
     * In case the qrCode found by the `where` argument doesn't exist, create a new qrCode with this data.
     */
    create: XOR<qrCodeCreateInput, qrCodeUncheckedCreateInput>;
    /**
     * In case the qrCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<qrCodeUpdateInput, qrCodeUncheckedUpdateInput>;
  };

  /**
   * qrCode delete
   */
  export type qrCodeDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the qrCode
     */
    select?: qrCodeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the qrCode
     */
    omit?: qrCodeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qrCodeInclude<ExtArgs> | null;
    /**
     * Filter which qrCode to delete.
     */
    where: qrCodeWhereUniqueInput;
  };

  /**
   * qrCode deleteMany
   */
  export type qrCodeDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which qrCodes to delete
     */
    where?: qrCodeWhereInput;
    /**
     * Limit how many qrCodes to delete.
     */
    limit?: number;
  };

  /**
   * qrCode.exhibit
   */
  export type qrCode$exhibitArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the exhibit
     */
    select?: exhibitSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the exhibit
     */
    omit?: exhibitOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exhibitInclude<ExtArgs> | null;
    where?: exhibitWhereInput;
    orderBy?:
      | exhibitOrderByWithRelationInput
      | exhibitOrderByWithRelationInput[];
    cursor?: exhibitWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ExhibitScalarFieldEnum | ExhibitScalarFieldEnum[];
  };

  /**
   * qrCode without action
   */
  export type qrCodeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the qrCode
     */
    select?: qrCodeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the qrCode
     */
    omit?: qrCodeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: qrCodeInclude<ExtArgs> | null;
  };

  /**
   * Model image
   */

  export type AggregateImage = {
    _count: ImageCountAggregateOutputType | null;
    _min: ImageMinAggregateOutputType | null;
    _max: ImageMaxAggregateOutputType | null;
  };

  export type ImageMinAggregateOutputType = {
    imageId: string | null;
    description: string | null;
    createdBy: string | null;
    createdAt: Date | null;
    statusCode: string | null;
  };

  export type ImageMaxAggregateOutputType = {
    imageId: string | null;
    description: string | null;
    createdBy: string | null;
    createdAt: Date | null;
    statusCode: string | null;
  };

  export type ImageCountAggregateOutputType = {
    imageId: number;
    description: number;
    createdBy: number;
    createdAt: number;
    statusCode: number;
    _all: number;
  };

  export type ImageMinAggregateInputType = {
    imageId?: true;
    description?: true;
    createdBy?: true;
    createdAt?: true;
    statusCode?: true;
  };

  export type ImageMaxAggregateInputType = {
    imageId?: true;
    description?: true;
    createdBy?: true;
    createdAt?: true;
    statusCode?: true;
  };

  export type ImageCountAggregateInputType = {
    imageId?: true;
    description?: true;
    createdBy?: true;
    createdAt?: true;
    statusCode?: true;
    _all?: true;
  };

  export type ImageAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which image to aggregate.
     */
    where?: imageWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of images to fetch.
     */
    orderBy?: imageOrderByWithRelationInput | imageOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: imageWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` images from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` images.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned images
     **/
    _count?: true | ImageCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ImageMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ImageMaxAggregateInputType;
  };

  export type GetImageAggregateType<T extends ImageAggregateArgs> = {
    [P in keyof T & keyof AggregateImage]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImage[P]>
      : GetScalarType<T[P], AggregateImage[P]>;
  };

  export type imageGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: imageWhereInput;
    orderBy?:
      | imageOrderByWithAggregationInput
      | imageOrderByWithAggregationInput[];
    by: ImageScalarFieldEnum[] | ImageScalarFieldEnum;
    having?: imageScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ImageCountAggregateInputType | true;
    _min?: ImageMinAggregateInputType;
    _max?: ImageMaxAggregateInputType;
  };

  export type ImageGroupByOutputType = {
    imageId: string;
    description: string;
    createdBy: string;
    createdAt: Date;
    statusCode: string;
    _count: ImageCountAggregateOutputType | null;
    _min: ImageMinAggregateOutputType | null;
    _max: ImageMaxAggregateOutputType | null;
  };

  type GetImageGroupByPayload<T extends imageGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ImageGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof ImageGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImageGroupByOutputType[P]>
            : GetScalarType<T[P], ImageGroupByOutputType[P]>;
        }
      >
    >;

  export type imageSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      imageId?: boolean;
      description?: boolean;
      createdBy?: boolean;
      createdAt?: boolean;
      statusCode?: boolean;
      exhibit?: boolean | image$exhibitArgs<ExtArgs>;
      status?: boolean | statusDefaultArgs<ExtArgs>;
      _count?: boolean | ImageCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["image"]
  >;

  export type imageSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      imageId?: boolean;
      description?: boolean;
      createdBy?: boolean;
      createdAt?: boolean;
      statusCode?: boolean;
      status?: boolean | statusDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["image"]
  >;

  export type imageSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      imageId?: boolean;
      description?: boolean;
      createdBy?: boolean;
      createdAt?: boolean;
      statusCode?: boolean;
      status?: boolean | statusDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["image"]
  >;

  export type imageSelectScalar = {
    imageId?: boolean;
    description?: boolean;
    createdBy?: boolean;
    createdAt?: boolean;
    statusCode?: boolean;
  };

  export type imageOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "imageId" | "description" | "createdBy" | "createdAt" | "statusCode",
    ExtArgs["result"]["image"]
  >;
  export type imageInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    exhibit?: boolean | image$exhibitArgs<ExtArgs>;
    status?: boolean | statusDefaultArgs<ExtArgs>;
    _count?: boolean | ImageCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type imageIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    status?: boolean | statusDefaultArgs<ExtArgs>;
  };
  export type imageIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    status?: boolean | statusDefaultArgs<ExtArgs>;
  };

  export type $imagePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "image";
    objects: {
      exhibit: Prisma.$exhibitPayload<ExtArgs>[];
      status: Prisma.$statusPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        imageId: string;
        description: string;
        createdBy: string;
        createdAt: Date;
        statusCode: string;
      },
      ExtArgs["result"]["image"]
    >;
    composites: {};
  };

  type imageGetPayload<
    S extends boolean | null | undefined | imageDefaultArgs,
  > = $Result.GetResult<Prisma.$imagePayload, S>;

  type imageCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<imageFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: ImageCountAggregateInputType | true;
  };

  export interface imageDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["image"];
      meta: { name: "image" };
    };
    /**
     * Find zero or one Image that matches the filter.
     * @param {imageFindUniqueArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends imageFindUniqueArgs>(
      args: SelectSubset<T, imageFindUniqueArgs<ExtArgs>>,
    ): Prisma__imageClient<
      $Result.GetResult<
        Prisma.$imagePayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Image that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {imageFindUniqueOrThrowArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends imageFindUniqueOrThrowArgs>(
      args: SelectSubset<T, imageFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__imageClient<
      $Result.GetResult<
        Prisma.$imagePayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Image that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {imageFindFirstArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends imageFindFirstArgs>(
      args?: SelectSubset<T, imageFindFirstArgs<ExtArgs>>,
    ): Prisma__imageClient<
      $Result.GetResult<
        Prisma.$imagePayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Image that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {imageFindFirstOrThrowArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends imageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, imageFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__imageClient<
      $Result.GetResult<
        Prisma.$imagePayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {imageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Images
     * const images = await prisma.image.findMany()
     *
     * // Get first 10 Images
     * const images = await prisma.image.findMany({ take: 10 })
     *
     * // Only select the `imageId`
     * const imageWithImageIdOnly = await prisma.image.findMany({ select: { imageId: true } })
     *
     */
    findMany<T extends imageFindManyArgs>(
      args?: SelectSubset<T, imageFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$imagePayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Image.
     * @param {imageCreateArgs} args - Arguments to create a Image.
     * @example
     * // Create one Image
     * const Image = await prisma.image.create({
     *   data: {
     *     // ... data to create a Image
     *   }
     * })
     *
     */
    create<T extends imageCreateArgs>(
      args: SelectSubset<T, imageCreateArgs<ExtArgs>>,
    ): Prisma__imageClient<
      $Result.GetResult<
        Prisma.$imagePayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Images.
     * @param {imageCreateManyArgs} args - Arguments to create many Images.
     * @example
     * // Create many Images
     * const image = await prisma.image.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends imageCreateManyArgs>(
      args?: SelectSubset<T, imageCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Images and returns the data saved in the database.
     * @param {imageCreateManyAndReturnArgs} args - Arguments to create many Images.
     * @example
     * // Create many Images
     * const image = await prisma.image.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Images and only return the `imageId`
     * const imageWithImageIdOnly = await prisma.image.createManyAndReturn({
     *   select: { imageId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends imageCreateManyAndReturnArgs>(
      args?: SelectSubset<T, imageCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$imagePayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Image.
     * @param {imageDeleteArgs} args - Arguments to delete one Image.
     * @example
     * // Delete one Image
     * const Image = await prisma.image.delete({
     *   where: {
     *     // ... filter to delete one Image
     *   }
     * })
     *
     */
    delete<T extends imageDeleteArgs>(
      args: SelectSubset<T, imageDeleteArgs<ExtArgs>>,
    ): Prisma__imageClient<
      $Result.GetResult<
        Prisma.$imagePayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Image.
     * @param {imageUpdateArgs} args - Arguments to update one Image.
     * @example
     * // Update one Image
     * const image = await prisma.image.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends imageUpdateArgs>(
      args: SelectSubset<T, imageUpdateArgs<ExtArgs>>,
    ): Prisma__imageClient<
      $Result.GetResult<
        Prisma.$imagePayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Images.
     * @param {imageDeleteManyArgs} args - Arguments to filter Images to delete.
     * @example
     * // Delete a few Images
     * const { count } = await prisma.image.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends imageDeleteManyArgs>(
      args?: SelectSubset<T, imageDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {imageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Images
     * const image = await prisma.image.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends imageUpdateManyArgs>(
      args: SelectSubset<T, imageUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Images and returns the data updated in the database.
     * @param {imageUpdateManyAndReturnArgs} args - Arguments to update many Images.
     * @example
     * // Update many Images
     * const image = await prisma.image.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Images and only return the `imageId`
     * const imageWithImageIdOnly = await prisma.image.updateManyAndReturn({
     *   select: { imageId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends imageUpdateManyAndReturnArgs>(
      args: SelectSubset<T, imageUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$imagePayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Image.
     * @param {imageUpsertArgs} args - Arguments to update or create a Image.
     * @example
     * // Update or create a Image
     * const image = await prisma.image.upsert({
     *   create: {
     *     // ... data to create a Image
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Image we want to update
     *   }
     * })
     */
    upsert<T extends imageUpsertArgs>(
      args: SelectSubset<T, imageUpsertArgs<ExtArgs>>,
    ): Prisma__imageClient<
      $Result.GetResult<
        Prisma.$imagePayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {imageCountArgs} args - Arguments to filter Images to count.
     * @example
     * // Count the number of Images
     * const count = await prisma.image.count({
     *   where: {
     *     // ... the filter for the Images we want to count
     *   }
     * })
     **/
    count<T extends imageCountArgs>(
      args?: Subset<T, imageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], ImageCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ImageAggregateArgs>(
      args: Subset<T, ImageAggregateArgs>,
    ): Prisma.PrismaPromise<GetImageAggregateType<T>>;

    /**
     * Group by Image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {imageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends imageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: imageGroupByArgs["orderBy"] }
        : { orderBy?: imageGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, imageGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetImageGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the image model
     */
    readonly fields: imageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for image.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__imageClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    exhibit<T extends image$exhibitArgs<ExtArgs> = {}>(
      args?: Subset<T, image$exhibitArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$exhibitPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    status<T extends statusDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, statusDefaultArgs<ExtArgs>>,
    ): Prisma__statusClient<
      | $Result.GetResult<
          Prisma.$statusPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the image model
   */
  interface imageFieldRefs {
    readonly imageId: FieldRef<"image", "String">;
    readonly description: FieldRef<"image", "String">;
    readonly createdBy: FieldRef<"image", "String">;
    readonly createdAt: FieldRef<"image", "DateTime">;
    readonly statusCode: FieldRef<"image", "String">;
  }

  // Custom InputTypes
  /**
   * image findUnique
   */
  export type imageFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the image
     */
    select?: imageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the image
     */
    omit?: imageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: imageInclude<ExtArgs> | null;
    /**
     * Filter, which image to fetch.
     */
    where: imageWhereUniqueInput;
  };

  /**
   * image findUniqueOrThrow
   */
  export type imageFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the image
     */
    select?: imageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the image
     */
    omit?: imageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: imageInclude<ExtArgs> | null;
    /**
     * Filter, which image to fetch.
     */
    where: imageWhereUniqueInput;
  };

  /**
   * image findFirst
   */
  export type imageFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the image
     */
    select?: imageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the image
     */
    omit?: imageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: imageInclude<ExtArgs> | null;
    /**
     * Filter, which image to fetch.
     */
    where?: imageWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of images to fetch.
     */
    orderBy?: imageOrderByWithRelationInput | imageOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for images.
     */
    cursor?: imageWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` images from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` images.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of images.
     */
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[];
  };

  /**
   * image findFirstOrThrow
   */
  export type imageFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the image
     */
    select?: imageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the image
     */
    omit?: imageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: imageInclude<ExtArgs> | null;
    /**
     * Filter, which image to fetch.
     */
    where?: imageWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of images to fetch.
     */
    orderBy?: imageOrderByWithRelationInput | imageOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for images.
     */
    cursor?: imageWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` images from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` images.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of images.
     */
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[];
  };

  /**
   * image findMany
   */
  export type imageFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the image
     */
    select?: imageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the image
     */
    omit?: imageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: imageInclude<ExtArgs> | null;
    /**
     * Filter, which images to fetch.
     */
    where?: imageWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of images to fetch.
     */
    orderBy?: imageOrderByWithRelationInput | imageOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing images.
     */
    cursor?: imageWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` images from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` images.
     */
    skip?: number;
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[];
  };

  /**
   * image create
   */
  export type imageCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the image
     */
    select?: imageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the image
     */
    omit?: imageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: imageInclude<ExtArgs> | null;
    /**
     * The data needed to create a image.
     */
    data: XOR<imageCreateInput, imageUncheckedCreateInput>;
  };

  /**
   * image createMany
   */
  export type imageCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many images.
     */
    data: imageCreateManyInput | imageCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * image createManyAndReturn
   */
  export type imageCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the image
     */
    select?: imageSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the image
     */
    omit?: imageOmit<ExtArgs> | null;
    /**
     * The data used to create many images.
     */
    data: imageCreateManyInput | imageCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: imageIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * image update
   */
  export type imageUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the image
     */
    select?: imageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the image
     */
    omit?: imageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: imageInclude<ExtArgs> | null;
    /**
     * The data needed to update a image.
     */
    data: XOR<imageUpdateInput, imageUncheckedUpdateInput>;
    /**
     * Choose, which image to update.
     */
    where: imageWhereUniqueInput;
  };

  /**
   * image updateMany
   */
  export type imageUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update images.
     */
    data: XOR<imageUpdateManyMutationInput, imageUncheckedUpdateManyInput>;
    /**
     * Filter which images to update
     */
    where?: imageWhereInput;
    /**
     * Limit how many images to update.
     */
    limit?: number;
  };

  /**
   * image updateManyAndReturn
   */
  export type imageUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the image
     */
    select?: imageSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the image
     */
    omit?: imageOmit<ExtArgs> | null;
    /**
     * The data used to update images.
     */
    data: XOR<imageUpdateManyMutationInput, imageUncheckedUpdateManyInput>;
    /**
     * Filter which images to update
     */
    where?: imageWhereInput;
    /**
     * Limit how many images to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: imageIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * image upsert
   */
  export type imageUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the image
     */
    select?: imageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the image
     */
    omit?: imageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: imageInclude<ExtArgs> | null;
    /**
     * The filter to search for the image to update in case it exists.
     */
    where: imageWhereUniqueInput;
    /**
     * In case the image found by the `where` argument doesn't exist, create a new image with this data.
     */
    create: XOR<imageCreateInput, imageUncheckedCreateInput>;
    /**
     * In case the image was found with the provided `where` argument, update it with this data.
     */
    update: XOR<imageUpdateInput, imageUncheckedUpdateInput>;
  };

  /**
   * image delete
   */
  export type imageDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the image
     */
    select?: imageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the image
     */
    omit?: imageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: imageInclude<ExtArgs> | null;
    /**
     * Filter which image to delete.
     */
    where: imageWhereUniqueInput;
  };

  /**
   * image deleteMany
   */
  export type imageDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which images to delete
     */
    where?: imageWhereInput;
    /**
     * Limit how many images to delete.
     */
    limit?: number;
  };

  /**
   * image.exhibit
   */
  export type image$exhibitArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the exhibit
     */
    select?: exhibitSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the exhibit
     */
    omit?: exhibitOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exhibitInclude<ExtArgs> | null;
    where?: exhibitWhereInput;
    orderBy?:
      | exhibitOrderByWithRelationInput
      | exhibitOrderByWithRelationInput[];
    cursor?: exhibitWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ExhibitScalarFieldEnum | ExhibitScalarFieldEnum[];
  };

  /**
   * image without action
   */
  export type imageDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the image
     */
    select?: imageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the image
     */
    omit?: imageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: imageInclude<ExtArgs> | null;
  };

  /**
   * Model event
   */

  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null;
    _avg: EventAvgAggregateOutputType | null;
    _sum: EventSumAggregateOutputType | null;
    _min: EventMinAggregateOutputType | null;
    _max: EventMaxAggregateOutputType | null;
  };

  export type EventAvgAggregateOutputType = {
    entityId: number | null;
  };

  export type EventSumAggregateOutputType = {
    entityId: number | null;
  };

  export type EventMinAggregateOutputType = {
    eventId: string | null;
    sessionId: string | null;
    entityId: number | null;
    entityName: string | null;
    timestamp: Date | null;
    usersUserId: string | null;
  };

  export type EventMaxAggregateOutputType = {
    eventId: string | null;
    sessionId: string | null;
    entityId: number | null;
    entityName: string | null;
    timestamp: Date | null;
    usersUserId: string | null;
  };

  export type EventCountAggregateOutputType = {
    eventId: number;
    sessionId: number;
    entityId: number;
    entityName: number;
    timestamp: number;
    usersUserId: number;
    _all: number;
  };

  export type EventAvgAggregateInputType = {
    entityId?: true;
  };

  export type EventSumAggregateInputType = {
    entityId?: true;
  };

  export type EventMinAggregateInputType = {
    eventId?: true;
    sessionId?: true;
    entityId?: true;
    entityName?: true;
    timestamp?: true;
    usersUserId?: true;
  };

  export type EventMaxAggregateInputType = {
    eventId?: true;
    sessionId?: true;
    entityId?: true;
    entityName?: true;
    timestamp?: true;
    usersUserId?: true;
  };

  export type EventCountAggregateInputType = {
    eventId?: true;
    sessionId?: true;
    entityId?: true;
    entityName?: true;
    timestamp?: true;
    usersUserId?: true;
    _all?: true;
  };

  export type EventAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which event to aggregate.
     */
    where?: eventWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of events to fetch.
     */
    orderBy?: eventOrderByWithRelationInput | eventOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: eventWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` events from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` events.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned events
     **/
    _count?: true | EventCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: EventAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: EventSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: EventMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: EventMaxAggregateInputType;
  };

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
    [P in keyof T & keyof AggregateEvent]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>;
  };

  export type eventGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: eventWhereInput;
    orderBy?:
      | eventOrderByWithAggregationInput
      | eventOrderByWithAggregationInput[];
    by: EventScalarFieldEnum[] | EventScalarFieldEnum;
    having?: eventScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: EventCountAggregateInputType | true;
    _avg?: EventAvgAggregateInputType;
    _sum?: EventSumAggregateInputType;
    _min?: EventMinAggregateInputType;
    _max?: EventMaxAggregateInputType;
  };

  export type EventGroupByOutputType = {
    eventId: string;
    sessionId: string;
    entityId: number;
    entityName: string;
    timestamp: Date;
    usersUserId: string | null;
    _count: EventCountAggregateOutputType | null;
    _avg: EventAvgAggregateOutputType | null;
    _sum: EventSumAggregateOutputType | null;
    _min: EventMinAggregateOutputType | null;
    _max: EventMaxAggregateOutputType | null;
  };

  type GetEventGroupByPayload<T extends eventGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<EventGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof EventGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>;
        }
      >
    >;

  export type eventSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      eventId?: boolean;
      sessionId?: boolean;
      entityId?: boolean;
      entityName?: boolean;
      timestamp?: boolean;
      usersUserId?: boolean;
      session?: boolean | sessionDefaultArgs<ExtArgs>;
      users?: boolean | event$usersArgs<ExtArgs>;
    },
    ExtArgs["result"]["event"]
  >;

  export type eventSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      eventId?: boolean;
      sessionId?: boolean;
      entityId?: boolean;
      entityName?: boolean;
      timestamp?: boolean;
      usersUserId?: boolean;
      session?: boolean | sessionDefaultArgs<ExtArgs>;
      users?: boolean | event$usersArgs<ExtArgs>;
    },
    ExtArgs["result"]["event"]
  >;

  export type eventSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      eventId?: boolean;
      sessionId?: boolean;
      entityId?: boolean;
      entityName?: boolean;
      timestamp?: boolean;
      usersUserId?: boolean;
      session?: boolean | sessionDefaultArgs<ExtArgs>;
      users?: boolean | event$usersArgs<ExtArgs>;
    },
    ExtArgs["result"]["event"]
  >;

  export type eventSelectScalar = {
    eventId?: boolean;
    sessionId?: boolean;
    entityId?: boolean;
    entityName?: boolean;
    timestamp?: boolean;
    usersUserId?: boolean;
  };

  export type eventOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "eventId"
    | "sessionId"
    | "entityId"
    | "entityName"
    | "timestamp"
    | "usersUserId",
    ExtArgs["result"]["event"]
  >;
  export type eventInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    session?: boolean | sessionDefaultArgs<ExtArgs>;
    users?: boolean | event$usersArgs<ExtArgs>;
  };
  export type eventIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    session?: boolean | sessionDefaultArgs<ExtArgs>;
    users?: boolean | event$usersArgs<ExtArgs>;
  };
  export type eventIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    session?: boolean | sessionDefaultArgs<ExtArgs>;
    users?: boolean | event$usersArgs<ExtArgs>;
  };

  export type $eventPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "event";
    objects: {
      session: Prisma.$sessionPayload<ExtArgs>;
      users: Prisma.$usersPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        eventId: string;
        sessionId: string;
        entityId: number;
        entityName: string;
        timestamp: Date;
        usersUserId: string | null;
      },
      ExtArgs["result"]["event"]
    >;
    composites: {};
  };

  type eventGetPayload<
    S extends boolean | null | undefined | eventDefaultArgs,
  > = $Result.GetResult<Prisma.$eventPayload, S>;

  type eventCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<eventFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: EventCountAggregateInputType | true;
  };

  export interface eventDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["event"];
      meta: { name: "event" };
    };
    /**
     * Find zero or one Event that matches the filter.
     * @param {eventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends eventFindUniqueArgs>(
      args: SelectSubset<T, eventFindUniqueArgs<ExtArgs>>,
    ): Prisma__eventClient<
      $Result.GetResult<
        Prisma.$eventPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Event that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {eventFindUniqueOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends eventFindUniqueOrThrowArgs>(
      args: SelectSubset<T, eventFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__eventClient<
      $Result.GetResult<
        Prisma.$eventPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends eventFindFirstArgs>(
      args?: SelectSubset<T, eventFindFirstArgs<ExtArgs>>,
    ): Prisma__eventClient<
      $Result.GetResult<
        Prisma.$eventPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventFindFirstOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends eventFindFirstOrThrowArgs>(
      args?: SelectSubset<T, eventFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__eventClient<
      $Result.GetResult<
        Prisma.$eventPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     *
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     *
     * // Only select the `eventId`
     * const eventWithEventIdOnly = await prisma.event.findMany({ select: { eventId: true } })
     *
     */
    findMany<T extends eventFindManyArgs>(
      args?: SelectSubset<T, eventFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$eventPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Event.
     * @param {eventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     *
     */
    create<T extends eventCreateArgs>(
      args: SelectSubset<T, eventCreateArgs<ExtArgs>>,
    ): Prisma__eventClient<
      $Result.GetResult<
        Prisma.$eventPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Events.
     * @param {eventCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends eventCreateManyArgs>(
      args?: SelectSubset<T, eventCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Events and returns the data saved in the database.
     * @param {eventCreateManyAndReturnArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Events and only return the `eventId`
     * const eventWithEventIdOnly = await prisma.event.createManyAndReturn({
     *   select: { eventId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends eventCreateManyAndReturnArgs>(
      args?: SelectSubset<T, eventCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$eventPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Event.
     * @param {eventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     *
     */
    delete<T extends eventDeleteArgs>(
      args: SelectSubset<T, eventDeleteArgs<ExtArgs>>,
    ): Prisma__eventClient<
      $Result.GetResult<
        Prisma.$eventPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Event.
     * @param {eventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends eventUpdateArgs>(
      args: SelectSubset<T, eventUpdateArgs<ExtArgs>>,
    ): Prisma__eventClient<
      $Result.GetResult<
        Prisma.$eventPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Events.
     * @param {eventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends eventDeleteManyArgs>(
      args?: SelectSubset<T, eventDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends eventUpdateManyArgs>(
      args: SelectSubset<T, eventUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Events and returns the data updated in the database.
     * @param {eventUpdateManyAndReturnArgs} args - Arguments to update many Events.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Events and only return the `eventId`
     * const eventWithEventIdOnly = await prisma.event.updateManyAndReturn({
     *   select: { eventId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends eventUpdateManyAndReturnArgs>(
      args: SelectSubset<T, eventUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$eventPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Event.
     * @param {eventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
     */
    upsert<T extends eventUpsertArgs>(
      args: SelectSubset<T, eventUpsertArgs<ExtArgs>>,
    ): Prisma__eventClient<
      $Result.GetResult<
        Prisma.$eventPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
     **/
    count<T extends eventCountArgs>(
      args?: Subset<T, eventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], EventCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends EventAggregateArgs>(
      args: Subset<T, EventAggregateArgs>,
    ): Prisma.PrismaPromise<GetEventAggregateType<T>>;

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {eventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends eventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: eventGroupByArgs["orderBy"] }
        : { orderBy?: eventGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, eventGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetEventGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the event model
     */
    readonly fields: eventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__eventClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    session<T extends sessionDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, sessionDefaultArgs<ExtArgs>>,
    ): Prisma__sessionClient<
      | $Result.GetResult<
          Prisma.$sessionPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    users<T extends event$usersArgs<ExtArgs> = {}>(
      args?: Subset<T, event$usersArgs<ExtArgs>>,
    ): Prisma__usersClient<
      $Result.GetResult<
        Prisma.$usersPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the event model
   */
  interface eventFieldRefs {
    readonly eventId: FieldRef<"event", "String">;
    readonly sessionId: FieldRef<"event", "String">;
    readonly entityId: FieldRef<"event", "Int">;
    readonly entityName: FieldRef<"event", "String">;
    readonly timestamp: FieldRef<"event", "DateTime">;
    readonly usersUserId: FieldRef<"event", "String">;
  }

  // Custom InputTypes
  /**
   * event findUnique
   */
  export type eventFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the event
     */
    omit?: eventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventInclude<ExtArgs> | null;
    /**
     * Filter, which event to fetch.
     */
    where: eventWhereUniqueInput;
  };

  /**
   * event findUniqueOrThrow
   */
  export type eventFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the event
     */
    omit?: eventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventInclude<ExtArgs> | null;
    /**
     * Filter, which event to fetch.
     */
    where: eventWhereUniqueInput;
  };

  /**
   * event findFirst
   */
  export type eventFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the event
     */
    omit?: eventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventInclude<ExtArgs> | null;
    /**
     * Filter, which event to fetch.
     */
    where?: eventWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of events to fetch.
     */
    orderBy?: eventOrderByWithRelationInput | eventOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for events.
     */
    cursor?: eventWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` events from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` events.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[];
  };

  /**
   * event findFirstOrThrow
   */
  export type eventFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the event
     */
    omit?: eventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventInclude<ExtArgs> | null;
    /**
     * Filter, which event to fetch.
     */
    where?: eventWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of events to fetch.
     */
    orderBy?: eventOrderByWithRelationInput | eventOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for events.
     */
    cursor?: eventWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` events from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` events.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[];
  };

  /**
   * event findMany
   */
  export type eventFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the event
     */
    omit?: eventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventInclude<ExtArgs> | null;
    /**
     * Filter, which events to fetch.
     */
    where?: eventWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of events to fetch.
     */
    orderBy?: eventOrderByWithRelationInput | eventOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing events.
     */
    cursor?: eventWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` events from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` events.
     */
    skip?: number;
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[];
  };

  /**
   * event create
   */
  export type eventCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the event
     */
    omit?: eventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventInclude<ExtArgs> | null;
    /**
     * The data needed to create a event.
     */
    data: XOR<eventCreateInput, eventUncheckedCreateInput>;
  };

  /**
   * event createMany
   */
  export type eventCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many events.
     */
    data: eventCreateManyInput | eventCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * event createManyAndReturn
   */
  export type eventCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the event
     */
    omit?: eventOmit<ExtArgs> | null;
    /**
     * The data used to create many events.
     */
    data: eventCreateManyInput | eventCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * event update
   */
  export type eventUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the event
     */
    omit?: eventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventInclude<ExtArgs> | null;
    /**
     * The data needed to update a event.
     */
    data: XOR<eventUpdateInput, eventUncheckedUpdateInput>;
    /**
     * Choose, which event to update.
     */
    where: eventWhereUniqueInput;
  };

  /**
   * event updateMany
   */
  export type eventUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update events.
     */
    data: XOR<eventUpdateManyMutationInput, eventUncheckedUpdateManyInput>;
    /**
     * Filter which events to update
     */
    where?: eventWhereInput;
    /**
     * Limit how many events to update.
     */
    limit?: number;
  };

  /**
   * event updateManyAndReturn
   */
  export type eventUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the event
     */
    omit?: eventOmit<ExtArgs> | null;
    /**
     * The data used to update events.
     */
    data: XOR<eventUpdateManyMutationInput, eventUncheckedUpdateManyInput>;
    /**
     * Filter which events to update
     */
    where?: eventWhereInput;
    /**
     * Limit how many events to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * event upsert
   */
  export type eventUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the event
     */
    omit?: eventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventInclude<ExtArgs> | null;
    /**
     * The filter to search for the event to update in case it exists.
     */
    where: eventWhereUniqueInput;
    /**
     * In case the event found by the `where` argument doesn't exist, create a new event with this data.
     */
    create: XOR<eventCreateInput, eventUncheckedCreateInput>;
    /**
     * In case the event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<eventUpdateInput, eventUncheckedUpdateInput>;
  };

  /**
   * event delete
   */
  export type eventDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the event
     */
    omit?: eventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventInclude<ExtArgs> | null;
    /**
     * Filter which event to delete.
     */
    where: eventWhereUniqueInput;
  };

  /**
   * event deleteMany
   */
  export type eventDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which events to delete
     */
    where?: eventWhereInput;
    /**
     * Limit how many events to delete.
     */
    limit?: number;
  };

  /**
   * event.users
   */
  export type event$usersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null;
    where?: usersWhereInput;
  };

  /**
   * event without action
   */
  export type eventDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the event
     */
    omit?: eventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventInclude<ExtArgs> | null;
  };

  /**
   * Model session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null;
    _min: SessionMinAggregateOutputType | null;
    _max: SessionMaxAggregateOutputType | null;
  };

  export type SessionMinAggregateOutputType = {
    sessionId: string | null;
    userId: string | null;
    deviceInfo: string | null;
    isActive: boolean | null;
    createdAt: Date | null;
  };

  export type SessionMaxAggregateOutputType = {
    sessionId: string | null;
    userId: string | null;
    deviceInfo: string | null;
    isActive: boolean | null;
    createdAt: Date | null;
  };

  export type SessionCountAggregateOutputType = {
    sessionId: number;
    userId: number;
    deviceInfo: number;
    isActive: number;
    createdAt: number;
    _all: number;
  };

  export type SessionMinAggregateInputType = {
    sessionId?: true;
    userId?: true;
    deviceInfo?: true;
    isActive?: true;
    createdAt?: true;
  };

  export type SessionMaxAggregateInputType = {
    sessionId?: true;
    userId?: true;
    deviceInfo?: true;
    isActive?: true;
    createdAt?: true;
  };

  export type SessionCountAggregateInputType = {
    sessionId?: true;
    userId?: true;
    deviceInfo?: true;
    isActive?: true;
    createdAt?: true;
    _all?: true;
  };

  export type SessionAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which session to aggregate.
     */
    where?: sessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of sessions to fetch.
     */
    orderBy?:
      | sessionOrderByWithRelationInput
      | sessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: sessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` sessions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned sessions
     **/
    _count?: true | SessionCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: SessionMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: SessionMaxAggregateInputType;
  };

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
    [P in keyof T & keyof AggregateSession]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>;
  };

  export type sessionGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: sessionWhereInput;
    orderBy?:
      | sessionOrderByWithAggregationInput
      | sessionOrderByWithAggregationInput[];
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum;
    having?: sessionScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: SessionCountAggregateInputType | true;
    _min?: SessionMinAggregateInputType;
    _max?: SessionMaxAggregateInputType;
  };

  export type SessionGroupByOutputType = {
    sessionId: string;
    userId: string;
    deviceInfo: string;
    isActive: boolean;
    createdAt: Date;
    _count: SessionCountAggregateOutputType | null;
    _min: SessionMinAggregateOutputType | null;
    _max: SessionMaxAggregateOutputType | null;
  };

  type GetSessionGroupByPayload<T extends sessionGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<SessionGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof SessionGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>;
        }
      >
    >;

  export type sessionSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      sessionId?: boolean;
      userId?: boolean;
      deviceInfo?: boolean;
      isActive?: boolean;
      createdAt?: boolean;
      user?: boolean | usersDefaultArgs<ExtArgs>;
      events?: boolean | session$eventsArgs<ExtArgs>;
      _count?: boolean | SessionCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["session"]
  >;

  export type sessionSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      sessionId?: boolean;
      userId?: boolean;
      deviceInfo?: boolean;
      isActive?: boolean;
      createdAt?: boolean;
      user?: boolean | usersDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["session"]
  >;

  export type sessionSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      sessionId?: boolean;
      userId?: boolean;
      deviceInfo?: boolean;
      isActive?: boolean;
      createdAt?: boolean;
      user?: boolean | usersDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["session"]
  >;

  export type sessionSelectScalar = {
    sessionId?: boolean;
    userId?: boolean;
    deviceInfo?: boolean;
    isActive?: boolean;
    createdAt?: boolean;
  };

  export type sessionOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "sessionId" | "userId" | "deviceInfo" | "isActive" | "createdAt",
    ExtArgs["result"]["session"]
  >;
  export type sessionInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | usersDefaultArgs<ExtArgs>;
    events?: boolean | session$eventsArgs<ExtArgs>;
    _count?: boolean | SessionCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type sessionIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | usersDefaultArgs<ExtArgs>;
  };
  export type sessionIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | usersDefaultArgs<ExtArgs>;
  };

  export type $sessionPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "session";
    objects: {
      user: Prisma.$usersPayload<ExtArgs>;
      events: Prisma.$eventPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        sessionId: string;
        userId: string;
        deviceInfo: string;
        isActive: boolean;
        createdAt: Date;
      },
      ExtArgs["result"]["session"]
    >;
    composites: {};
  };

  type sessionGetPayload<
    S extends boolean | null | undefined | sessionDefaultArgs,
  > = $Result.GetResult<Prisma.$sessionPayload, S>;

  type sessionCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<sessionFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: SessionCountAggregateInputType | true;
  };

  export interface sessionDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["session"];
      meta: { name: "session" };
    };
    /**
     * Find zero or one Session that matches the filter.
     * @param {sessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sessionFindUniqueArgs>(
      args: SelectSubset<T, sessionFindUniqueArgs<ExtArgs>>,
    ): Prisma__sessionClient<
      $Result.GetResult<
        Prisma.$sessionPayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sessionFindUniqueOrThrowArgs>(
      args: SelectSubset<T, sessionFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__sessionClient<
      $Result.GetResult<
        Prisma.$sessionPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sessionFindFirstArgs>(
      args?: SelectSubset<T, sessionFindFirstArgs<ExtArgs>>,
    ): Prisma__sessionClient<
      $Result.GetResult<
        Prisma.$sessionPayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sessionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, sessionFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__sessionClient<
      $Result.GetResult<
        Prisma.$sessionPayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     *
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     *
     * // Only select the `sessionId`
     * const sessionWithSessionIdOnly = await prisma.session.findMany({ select: { sessionId: true } })
     *
     */
    findMany<T extends sessionFindManyArgs>(
      args?: SelectSubset<T, sessionFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$sessionPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Session.
     * @param {sessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     *
     */
    create<T extends sessionCreateArgs>(
      args: SelectSubset<T, sessionCreateArgs<ExtArgs>>,
    ): Prisma__sessionClient<
      $Result.GetResult<
        Prisma.$sessionPayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Sessions.
     * @param {sessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends sessionCreateManyArgs>(
      args?: SelectSubset<T, sessionCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {sessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Sessions and only return the `sessionId`
     * const sessionWithSessionIdOnly = await prisma.session.createManyAndReturn({
     *   select: { sessionId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends sessionCreateManyAndReturnArgs>(
      args?: SelectSubset<T, sessionCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$sessionPayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Session.
     * @param {sessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     *
     */
    delete<T extends sessionDeleteArgs>(
      args: SelectSubset<T, sessionDeleteArgs<ExtArgs>>,
    ): Prisma__sessionClient<
      $Result.GetResult<
        Prisma.$sessionPayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Session.
     * @param {sessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends sessionUpdateArgs>(
      args: SelectSubset<T, sessionUpdateArgs<ExtArgs>>,
    ): Prisma__sessionClient<
      $Result.GetResult<
        Prisma.$sessionPayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Sessions.
     * @param {sessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends sessionDeleteManyArgs>(
      args?: SelectSubset<T, sessionDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends sessionUpdateManyArgs>(
      args: SelectSubset<T, sessionUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {sessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Sessions and only return the `sessionId`
     * const sessionWithSessionIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { sessionId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends sessionUpdateManyAndReturnArgs>(
      args: SelectSubset<T, sessionUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$sessionPayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Session.
     * @param {sessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends sessionUpsertArgs>(
      args: SelectSubset<T, sessionUpsertArgs<ExtArgs>>,
    ): Prisma__sessionClient<
      $Result.GetResult<
        Prisma.$sessionPayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
     **/
    count<T extends sessionCountArgs>(
      args?: Subset<T, sessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], SessionCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends SessionAggregateArgs>(
      args: Subset<T, SessionAggregateArgs>,
    ): Prisma.PrismaPromise<GetSessionAggregateType<T>>;

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends sessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sessionGroupByArgs["orderBy"] }
        : { orderBy?: sessionGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, sessionGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetSessionGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the session model
     */
    readonly fields: sessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sessionClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    user<T extends usersDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, usersDefaultArgs<ExtArgs>>,
    ): Prisma__usersClient<
      | $Result.GetResult<
          Prisma.$usersPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    events<T extends session$eventsArgs<ExtArgs> = {}>(
      args?: Subset<T, session$eventsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$eventPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the session model
   */
  interface sessionFieldRefs {
    readonly sessionId: FieldRef<"session", "String">;
    readonly userId: FieldRef<"session", "String">;
    readonly deviceInfo: FieldRef<"session", "String">;
    readonly isActive: FieldRef<"session", "Boolean">;
    readonly createdAt: FieldRef<"session", "DateTime">;
  }

  // Custom InputTypes
  /**
   * session findUnique
   */
  export type sessionFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null;
    /**
     * Filter, which session to fetch.
     */
    where: sessionWhereUniqueInput;
  };

  /**
   * session findUniqueOrThrow
   */
  export type sessionFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null;
    /**
     * Filter, which session to fetch.
     */
    where: sessionWhereUniqueInput;
  };

  /**
   * session findFirst
   */
  export type sessionFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null;
    /**
     * Filter, which session to fetch.
     */
    where?: sessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of sessions to fetch.
     */
    orderBy?:
      | sessionOrderByWithRelationInput
      | sessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for sessions.
     */
    cursor?: sessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` sessions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[];
  };

  /**
   * session findFirstOrThrow
   */
  export type sessionFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null;
    /**
     * Filter, which session to fetch.
     */
    where?: sessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of sessions to fetch.
     */
    orderBy?:
      | sessionOrderByWithRelationInput
      | sessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for sessions.
     */
    cursor?: sessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` sessions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[];
  };

  /**
   * session findMany
   */
  export type sessionFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null;
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of sessions to fetch.
     */
    orderBy?:
      | sessionOrderByWithRelationInput
      | sessionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing sessions.
     */
    cursor?: sessionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` sessions.
     */
    skip?: number;
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[];
  };

  /**
   * session create
   */
  export type sessionCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null;
    /**
     * The data needed to create a session.
     */
    data: XOR<sessionCreateInput, sessionUncheckedCreateInput>;
  };

  /**
   * session createMany
   */
  export type sessionCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many sessions.
     */
    data: sessionCreateManyInput | sessionCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * session createManyAndReturn
   */
  export type sessionCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null;
    /**
     * The data used to create many sessions.
     */
    data: sessionCreateManyInput | sessionCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * session update
   */
  export type sessionUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null;
    /**
     * The data needed to update a session.
     */
    data: XOR<sessionUpdateInput, sessionUncheckedUpdateInput>;
    /**
     * Choose, which session to update.
     */
    where: sessionWhereUniqueInput;
  };

  /**
   * session updateMany
   */
  export type sessionUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update sessions.
     */
    data: XOR<sessionUpdateManyMutationInput, sessionUncheckedUpdateManyInput>;
    /**
     * Filter which sessions to update
     */
    where?: sessionWhereInput;
    /**
     * Limit how many sessions to update.
     */
    limit?: number;
  };

  /**
   * session updateManyAndReturn
   */
  export type sessionUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null;
    /**
     * The data used to update sessions.
     */
    data: XOR<sessionUpdateManyMutationInput, sessionUncheckedUpdateManyInput>;
    /**
     * Filter which sessions to update
     */
    where?: sessionWhereInput;
    /**
     * Limit how many sessions to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * session upsert
   */
  export type sessionUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null;
    /**
     * The filter to search for the session to update in case it exists.
     */
    where: sessionWhereUniqueInput;
    /**
     * In case the session found by the `where` argument doesn't exist, create a new session with this data.
     */
    create: XOR<sessionCreateInput, sessionUncheckedCreateInput>;
    /**
     * In case the session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sessionUpdateInput, sessionUncheckedUpdateInput>;
  };

  /**
   * session delete
   */
  export type sessionDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null;
    /**
     * Filter which session to delete.
     */
    where: sessionWhereUniqueInput;
  };

  /**
   * session deleteMany
   */
  export type sessionDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which sessions to delete
     */
    where?: sessionWhereInput;
    /**
     * Limit how many sessions to delete.
     */
    limit?: number;
  };

  /**
   * session.events
   */
  export type session$eventsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the event
     */
    select?: eventSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the event
     */
    omit?: eventOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: eventInclude<ExtArgs> | null;
    where?: eventWhereInput;
    orderBy?: eventOrderByWithRelationInput | eventOrderByWithRelationInput[];
    cursor?: eventWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[];
  };

  /**
   * session without action
   */
  export type sessionDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the session
     */
    omit?: sessionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionInclude<ExtArgs> | null;
  };

  /**
   * Model userProfile
   */

  export type AggregateUserProfile = {
    _count: UserProfileCountAggregateOutputType | null;
    _min: UserProfileMinAggregateOutputType | null;
    _max: UserProfileMaxAggregateOutputType | null;
  };

  export type UserProfileMinAggregateOutputType = {
    userProfileId: string | null;
    userId: string | null;
    fName: string | null;
    lName: string | null;
    languageCode: string | null;
    gender: string | null;
    dob: Date | null;
    modifiedBy: string | null;
    createdBy: string | null;
    createdAt: Date | null;
    modifiedAt: Date | null;
    statusCode: string | null;
  };

  export type UserProfileMaxAggregateOutputType = {
    userProfileId: string | null;
    userId: string | null;
    fName: string | null;
    lName: string | null;
    languageCode: string | null;
    gender: string | null;
    dob: Date | null;
    modifiedBy: string | null;
    createdBy: string | null;
    createdAt: Date | null;
    modifiedAt: Date | null;
    statusCode: string | null;
  };

  export type UserProfileCountAggregateOutputType = {
    userProfileId: number;
    userId: number;
    fName: number;
    lName: number;
    languageCode: number;
    gender: number;
    dob: number;
    modifiedBy: number;
    createdBy: number;
    createdAt: number;
    modifiedAt: number;
    statusCode: number;
    _all: number;
  };

  export type UserProfileMinAggregateInputType = {
    userProfileId?: true;
    userId?: true;
    fName?: true;
    lName?: true;
    languageCode?: true;
    gender?: true;
    dob?: true;
    modifiedBy?: true;
    createdBy?: true;
    createdAt?: true;
    modifiedAt?: true;
    statusCode?: true;
  };

  export type UserProfileMaxAggregateInputType = {
    userProfileId?: true;
    userId?: true;
    fName?: true;
    lName?: true;
    languageCode?: true;
    gender?: true;
    dob?: true;
    modifiedBy?: true;
    createdBy?: true;
    createdAt?: true;
    modifiedAt?: true;
    statusCode?: true;
  };

  export type UserProfileCountAggregateInputType = {
    userProfileId?: true;
    userId?: true;
    fName?: true;
    lName?: true;
    languageCode?: true;
    gender?: true;
    dob?: true;
    modifiedBy?: true;
    createdBy?: true;
    createdAt?: true;
    modifiedAt?: true;
    statusCode?: true;
    _all?: true;
  };

  export type UserProfileAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which userProfile to aggregate.
     */
    where?: userProfileWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of userProfiles to fetch.
     */
    orderBy?:
      | userProfileOrderByWithRelationInput
      | userProfileOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: userProfileWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` userProfiles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` userProfiles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned userProfiles
     **/
    _count?: true | UserProfileCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: UserProfileMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: UserProfileMaxAggregateInputType;
  };

  export type GetUserProfileAggregateType<T extends UserProfileAggregateArgs> =
    {
      [P in keyof T & keyof AggregateUserProfile]: P extends "_count" | "count"
        ? T[P] extends true
          ? number
          : GetScalarType<T[P], AggregateUserProfile[P]>
        : GetScalarType<T[P], AggregateUserProfile[P]>;
    };

  export type userProfileGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: userProfileWhereInput;
    orderBy?:
      | userProfileOrderByWithAggregationInput
      | userProfileOrderByWithAggregationInput[];
    by: UserProfileScalarFieldEnum[] | UserProfileScalarFieldEnum;
    having?: userProfileScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: UserProfileCountAggregateInputType | true;
    _min?: UserProfileMinAggregateInputType;
    _max?: UserProfileMaxAggregateInputType;
  };

  export type UserProfileGroupByOutputType = {
    userProfileId: string;
    userId: string;
    fName: string;
    lName: string;
    languageCode: string;
    gender: string;
    dob: Date;
    modifiedBy: string;
    createdBy: string;
    createdAt: Date;
    modifiedAt: Date;
    statusCode: string;
    _count: UserProfileCountAggregateOutputType | null;
    _min: UserProfileMinAggregateOutputType | null;
    _max: UserProfileMaxAggregateOutputType | null;
  };

  type GetUserProfileGroupByPayload<T extends userProfileGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<UserProfileGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof UserProfileGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
            : GetScalarType<T[P], UserProfileGroupByOutputType[P]>;
        }
      >
    >;

  export type userProfileSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      userProfileId?: boolean;
      userId?: boolean;
      fName?: boolean;
      lName?: boolean;
      languageCode?: boolean;
      gender?: boolean;
      dob?: boolean;
      modifiedBy?: boolean;
      createdBy?: boolean;
      createdAt?: boolean;
      modifiedAt?: boolean;
      statusCode?: boolean;
      user?: boolean | usersDefaultArgs<ExtArgs>;
      language?: boolean | languageDefaultArgs<ExtArgs>;
      status?: boolean | statusDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["userProfile"]
  >;

  export type userProfileSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      userProfileId?: boolean;
      userId?: boolean;
      fName?: boolean;
      lName?: boolean;
      languageCode?: boolean;
      gender?: boolean;
      dob?: boolean;
      modifiedBy?: boolean;
      createdBy?: boolean;
      createdAt?: boolean;
      modifiedAt?: boolean;
      statusCode?: boolean;
      user?: boolean | usersDefaultArgs<ExtArgs>;
      language?: boolean | languageDefaultArgs<ExtArgs>;
      status?: boolean | statusDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["userProfile"]
  >;

  export type userProfileSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      userProfileId?: boolean;
      userId?: boolean;
      fName?: boolean;
      lName?: boolean;
      languageCode?: boolean;
      gender?: boolean;
      dob?: boolean;
      modifiedBy?: boolean;
      createdBy?: boolean;
      createdAt?: boolean;
      modifiedAt?: boolean;
      statusCode?: boolean;
      user?: boolean | usersDefaultArgs<ExtArgs>;
      language?: boolean | languageDefaultArgs<ExtArgs>;
      status?: boolean | statusDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["userProfile"]
  >;

  export type userProfileSelectScalar = {
    userProfileId?: boolean;
    userId?: boolean;
    fName?: boolean;
    lName?: boolean;
    languageCode?: boolean;
    gender?: boolean;
    dob?: boolean;
    modifiedBy?: boolean;
    createdBy?: boolean;
    createdAt?: boolean;
    modifiedAt?: boolean;
    statusCode?: boolean;
  };

  export type userProfileOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "userProfileId"
    | "userId"
    | "fName"
    | "lName"
    | "languageCode"
    | "gender"
    | "dob"
    | "modifiedBy"
    | "createdBy"
    | "createdAt"
    | "modifiedAt"
    | "statusCode",
    ExtArgs["result"]["userProfile"]
  >;
  export type userProfileInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | usersDefaultArgs<ExtArgs>;
    language?: boolean | languageDefaultArgs<ExtArgs>;
    status?: boolean | statusDefaultArgs<ExtArgs>;
  };
  export type userProfileIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | usersDefaultArgs<ExtArgs>;
    language?: boolean | languageDefaultArgs<ExtArgs>;
    status?: boolean | statusDefaultArgs<ExtArgs>;
  };
  export type userProfileIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | usersDefaultArgs<ExtArgs>;
    language?: boolean | languageDefaultArgs<ExtArgs>;
    status?: boolean | statusDefaultArgs<ExtArgs>;
  };

  export type $userProfilePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "userProfile";
    objects: {
      user: Prisma.$usersPayload<ExtArgs>;
      language: Prisma.$languagePayload<ExtArgs>;
      status: Prisma.$statusPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        userProfileId: string;
        userId: string;
        fName: string;
        lName: string;
        languageCode: string;
        gender: string;
        dob: Date;
        modifiedBy: string;
        createdBy: string;
        createdAt: Date;
        modifiedAt: Date;
        statusCode: string;
      },
      ExtArgs["result"]["userProfile"]
    >;
    composites: {};
  };

  type userProfileGetPayload<
    S extends boolean | null | undefined | userProfileDefaultArgs,
  > = $Result.GetResult<Prisma.$userProfilePayload, S>;

  type userProfileCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    userProfileFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: UserProfileCountAggregateInputType | true;
  };

  export interface userProfileDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["userProfile"];
      meta: { name: "userProfile" };
    };
    /**
     * Find zero or one UserProfile that matches the filter.
     * @param {userProfileFindUniqueArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userProfileFindUniqueArgs>(
      args: SelectSubset<T, userProfileFindUniqueArgs<ExtArgs>>,
    ): Prisma__userProfileClient<
      $Result.GetResult<
        Prisma.$userProfilePayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one UserProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userProfileFindUniqueOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userProfileFindUniqueOrThrowArgs>(
      args: SelectSubset<T, userProfileFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__userProfileClient<
      $Result.GetResult<
        Prisma.$userProfilePayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first UserProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userProfileFindFirstArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userProfileFindFirstArgs>(
      args?: SelectSubset<T, userProfileFindFirstArgs<ExtArgs>>,
    ): Prisma__userProfileClient<
      $Result.GetResult<
        Prisma.$userProfilePayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first UserProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userProfileFindFirstOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userProfileFindFirstOrThrowArgs>(
      args?: SelectSubset<T, userProfileFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__userProfileClient<
      $Result.GetResult<
        Prisma.$userProfilePayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more UserProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserProfiles
     * const userProfiles = await prisma.userProfile.findMany()
     *
     * // Get first 10 UserProfiles
     * const userProfiles = await prisma.userProfile.findMany({ take: 10 })
     *
     * // Only select the `userProfileId`
     * const userProfileWithUserProfileIdOnly = await prisma.userProfile.findMany({ select: { userProfileId: true } })
     *
     */
    findMany<T extends userProfileFindManyArgs>(
      args?: SelectSubset<T, userProfileFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$userProfilePayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a UserProfile.
     * @param {userProfileCreateArgs} args - Arguments to create a UserProfile.
     * @example
     * // Create one UserProfile
     * const UserProfile = await prisma.userProfile.create({
     *   data: {
     *     // ... data to create a UserProfile
     *   }
     * })
     *
     */
    create<T extends userProfileCreateArgs>(
      args: SelectSubset<T, userProfileCreateArgs<ExtArgs>>,
    ): Prisma__userProfileClient<
      $Result.GetResult<
        Prisma.$userProfilePayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many UserProfiles.
     * @param {userProfileCreateManyArgs} args - Arguments to create many UserProfiles.
     * @example
     * // Create many UserProfiles
     * const userProfile = await prisma.userProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends userProfileCreateManyArgs>(
      args?: SelectSubset<T, userProfileCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many UserProfiles and returns the data saved in the database.
     * @param {userProfileCreateManyAndReturnArgs} args - Arguments to create many UserProfiles.
     * @example
     * // Create many UserProfiles
     * const userProfile = await prisma.userProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many UserProfiles and only return the `userProfileId`
     * const userProfileWithUserProfileIdOnly = await prisma.userProfile.createManyAndReturn({
     *   select: { userProfileId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends userProfileCreateManyAndReturnArgs>(
      args?: SelectSubset<T, userProfileCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$userProfilePayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a UserProfile.
     * @param {userProfileDeleteArgs} args - Arguments to delete one UserProfile.
     * @example
     * // Delete one UserProfile
     * const UserProfile = await prisma.userProfile.delete({
     *   where: {
     *     // ... filter to delete one UserProfile
     *   }
     * })
     *
     */
    delete<T extends userProfileDeleteArgs>(
      args: SelectSubset<T, userProfileDeleteArgs<ExtArgs>>,
    ): Prisma__userProfileClient<
      $Result.GetResult<
        Prisma.$userProfilePayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one UserProfile.
     * @param {userProfileUpdateArgs} args - Arguments to update one UserProfile.
     * @example
     * // Update one UserProfile
     * const userProfile = await prisma.userProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends userProfileUpdateArgs>(
      args: SelectSubset<T, userProfileUpdateArgs<ExtArgs>>,
    ): Prisma__userProfileClient<
      $Result.GetResult<
        Prisma.$userProfilePayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more UserProfiles.
     * @param {userProfileDeleteManyArgs} args - Arguments to filter UserProfiles to delete.
     * @example
     * // Delete a few UserProfiles
     * const { count } = await prisma.userProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends userProfileDeleteManyArgs>(
      args?: SelectSubset<T, userProfileDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserProfiles
     * const userProfile = await prisma.userProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends userProfileUpdateManyArgs>(
      args: SelectSubset<T, userProfileUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more UserProfiles and returns the data updated in the database.
     * @param {userProfileUpdateManyAndReturnArgs} args - Arguments to update many UserProfiles.
     * @example
     * // Update many UserProfiles
     * const userProfile = await prisma.userProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more UserProfiles and only return the `userProfileId`
     * const userProfileWithUserProfileIdOnly = await prisma.userProfile.updateManyAndReturn({
     *   select: { userProfileId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends userProfileUpdateManyAndReturnArgs>(
      args: SelectSubset<T, userProfileUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$userProfilePayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one UserProfile.
     * @param {userProfileUpsertArgs} args - Arguments to update or create a UserProfile.
     * @example
     * // Update or create a UserProfile
     * const userProfile = await prisma.userProfile.upsert({
     *   create: {
     *     // ... data to create a UserProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserProfile we want to update
     *   }
     * })
     */
    upsert<T extends userProfileUpsertArgs>(
      args: SelectSubset<T, userProfileUpsertArgs<ExtArgs>>,
    ): Prisma__userProfileClient<
      $Result.GetResult<
        Prisma.$userProfilePayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userProfileCountArgs} args - Arguments to filter UserProfiles to count.
     * @example
     * // Count the number of UserProfiles
     * const count = await prisma.userProfile.count({
     *   where: {
     *     // ... the filter for the UserProfiles we want to count
     *   }
     * })
     **/
    count<T extends userProfileCountArgs>(
      args?: Subset<T, userProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], UserProfileCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends UserProfileAggregateArgs>(
      args: Subset<T, UserProfileAggregateArgs>,
    ): Prisma.PrismaPromise<GetUserProfileAggregateType<T>>;

    /**
     * Group by UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends userProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userProfileGroupByArgs["orderBy"] }
        : { orderBy?: userProfileGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, userProfileGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetUserProfileGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the userProfile model
     */
    readonly fields: userProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for userProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userProfileClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    user<T extends usersDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, usersDefaultArgs<ExtArgs>>,
    ): Prisma__usersClient<
      | $Result.GetResult<
          Prisma.$usersPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    language<T extends languageDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, languageDefaultArgs<ExtArgs>>,
    ): Prisma__languageClient<
      | $Result.GetResult<
          Prisma.$languagePayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    status<T extends statusDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, statusDefaultArgs<ExtArgs>>,
    ): Prisma__statusClient<
      | $Result.GetResult<
          Prisma.$statusPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the userProfile model
   */
  interface userProfileFieldRefs {
    readonly userProfileId: FieldRef<"userProfile", "String">;
    readonly userId: FieldRef<"userProfile", "String">;
    readonly fName: FieldRef<"userProfile", "String">;
    readonly lName: FieldRef<"userProfile", "String">;
    readonly languageCode: FieldRef<"userProfile", "String">;
    readonly gender: FieldRef<"userProfile", "String">;
    readonly dob: FieldRef<"userProfile", "DateTime">;
    readonly modifiedBy: FieldRef<"userProfile", "String">;
    readonly createdBy: FieldRef<"userProfile", "String">;
    readonly createdAt: FieldRef<"userProfile", "DateTime">;
    readonly modifiedAt: FieldRef<"userProfile", "DateTime">;
    readonly statusCode: FieldRef<"userProfile", "String">;
  }

  // Custom InputTypes
  /**
   * userProfile findUnique
   */
  export type userProfileFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the userProfile
     */
    select?: userProfileSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the userProfile
     */
    omit?: userProfileOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userProfileInclude<ExtArgs> | null;
    /**
     * Filter, which userProfile to fetch.
     */
    where: userProfileWhereUniqueInput;
  };

  /**
   * userProfile findUniqueOrThrow
   */
  export type userProfileFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the userProfile
     */
    select?: userProfileSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the userProfile
     */
    omit?: userProfileOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userProfileInclude<ExtArgs> | null;
    /**
     * Filter, which userProfile to fetch.
     */
    where: userProfileWhereUniqueInput;
  };

  /**
   * userProfile findFirst
   */
  export type userProfileFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the userProfile
     */
    select?: userProfileSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the userProfile
     */
    omit?: userProfileOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userProfileInclude<ExtArgs> | null;
    /**
     * Filter, which userProfile to fetch.
     */
    where?: userProfileWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of userProfiles to fetch.
     */
    orderBy?:
      | userProfileOrderByWithRelationInput
      | userProfileOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for userProfiles.
     */
    cursor?: userProfileWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` userProfiles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` userProfiles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of userProfiles.
     */
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[];
  };

  /**
   * userProfile findFirstOrThrow
   */
  export type userProfileFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the userProfile
     */
    select?: userProfileSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the userProfile
     */
    omit?: userProfileOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userProfileInclude<ExtArgs> | null;
    /**
     * Filter, which userProfile to fetch.
     */
    where?: userProfileWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of userProfiles to fetch.
     */
    orderBy?:
      | userProfileOrderByWithRelationInput
      | userProfileOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for userProfiles.
     */
    cursor?: userProfileWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` userProfiles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` userProfiles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of userProfiles.
     */
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[];
  };

  /**
   * userProfile findMany
   */
  export type userProfileFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the userProfile
     */
    select?: userProfileSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the userProfile
     */
    omit?: userProfileOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userProfileInclude<ExtArgs> | null;
    /**
     * Filter, which userProfiles to fetch.
     */
    where?: userProfileWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of userProfiles to fetch.
     */
    orderBy?:
      | userProfileOrderByWithRelationInput
      | userProfileOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing userProfiles.
     */
    cursor?: userProfileWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` userProfiles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` userProfiles.
     */
    skip?: number;
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[];
  };

  /**
   * userProfile create
   */
  export type userProfileCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the userProfile
     */
    select?: userProfileSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the userProfile
     */
    omit?: userProfileOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userProfileInclude<ExtArgs> | null;
    /**
     * The data needed to create a userProfile.
     */
    data: XOR<userProfileCreateInput, userProfileUncheckedCreateInput>;
  };

  /**
   * userProfile createMany
   */
  export type userProfileCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many userProfiles.
     */
    data: userProfileCreateManyInput | userProfileCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * userProfile createManyAndReturn
   */
  export type userProfileCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the userProfile
     */
    select?: userProfileSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the userProfile
     */
    omit?: userProfileOmit<ExtArgs> | null;
    /**
     * The data used to create many userProfiles.
     */
    data: userProfileCreateManyInput | userProfileCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userProfileIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * userProfile update
   */
  export type userProfileUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the userProfile
     */
    select?: userProfileSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the userProfile
     */
    omit?: userProfileOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userProfileInclude<ExtArgs> | null;
    /**
     * The data needed to update a userProfile.
     */
    data: XOR<userProfileUpdateInput, userProfileUncheckedUpdateInput>;
    /**
     * Choose, which userProfile to update.
     */
    where: userProfileWhereUniqueInput;
  };

  /**
   * userProfile updateMany
   */
  export type userProfileUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update userProfiles.
     */
    data: XOR<
      userProfileUpdateManyMutationInput,
      userProfileUncheckedUpdateManyInput
    >;
    /**
     * Filter which userProfiles to update
     */
    where?: userProfileWhereInput;
    /**
     * Limit how many userProfiles to update.
     */
    limit?: number;
  };

  /**
   * userProfile updateManyAndReturn
   */
  export type userProfileUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the userProfile
     */
    select?: userProfileSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the userProfile
     */
    omit?: userProfileOmit<ExtArgs> | null;
    /**
     * The data used to update userProfiles.
     */
    data: XOR<
      userProfileUpdateManyMutationInput,
      userProfileUncheckedUpdateManyInput
    >;
    /**
     * Filter which userProfiles to update
     */
    where?: userProfileWhereInput;
    /**
     * Limit how many userProfiles to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userProfileIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * userProfile upsert
   */
  export type userProfileUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the userProfile
     */
    select?: userProfileSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the userProfile
     */
    omit?: userProfileOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userProfileInclude<ExtArgs> | null;
    /**
     * The filter to search for the userProfile to update in case it exists.
     */
    where: userProfileWhereUniqueInput;
    /**
     * In case the userProfile found by the `where` argument doesn't exist, create a new userProfile with this data.
     */
    create: XOR<userProfileCreateInput, userProfileUncheckedCreateInput>;
    /**
     * In case the userProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userProfileUpdateInput, userProfileUncheckedUpdateInput>;
  };

  /**
   * userProfile delete
   */
  export type userProfileDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the userProfile
     */
    select?: userProfileSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the userProfile
     */
    omit?: userProfileOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userProfileInclude<ExtArgs> | null;
    /**
     * Filter which userProfile to delete.
     */
    where: userProfileWhereUniqueInput;
  };

  /**
   * userProfile deleteMany
   */
  export type userProfileDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which userProfiles to delete
     */
    where?: userProfileWhereInput;
    /**
     * Limit how many userProfiles to delete.
     */
    limit?: number;
  };

  /**
   * userProfile without action
   */
  export type userProfileDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the userProfile
     */
    select?: userProfileSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the userProfile
     */
    omit?: userProfileOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userProfileInclude<ExtArgs> | null;
  };

  /**
   * Model language
   */

  export type AggregateLanguage = {
    _count: LanguageCountAggregateOutputType | null;
    _min: LanguageMinAggregateOutputType | null;
    _max: LanguageMaxAggregateOutputType | null;
  };

  export type LanguageMinAggregateOutputType = {
    languageCode: string | null;
    languageName: string | null;
    statusCode: string | null;
  };

  export type LanguageMaxAggregateOutputType = {
    languageCode: string | null;
    languageName: string | null;
    statusCode: string | null;
  };

  export type LanguageCountAggregateOutputType = {
    languageCode: number;
    languageName: number;
    statusCode: number;
    _all: number;
  };

  export type LanguageMinAggregateInputType = {
    languageCode?: true;
    languageName?: true;
    statusCode?: true;
  };

  export type LanguageMaxAggregateInputType = {
    languageCode?: true;
    languageName?: true;
    statusCode?: true;
  };

  export type LanguageCountAggregateInputType = {
    languageCode?: true;
    languageName?: true;
    statusCode?: true;
    _all?: true;
  };

  export type LanguageAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which language to aggregate.
     */
    where?: languageWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of languages to fetch.
     */
    orderBy?:
      | languageOrderByWithRelationInput
      | languageOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: languageWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` languages from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` languages.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned languages
     **/
    _count?: true | LanguageCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: LanguageMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: LanguageMaxAggregateInputType;
  };

  export type GetLanguageAggregateType<T extends LanguageAggregateArgs> = {
    [P in keyof T & keyof AggregateLanguage]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLanguage[P]>
      : GetScalarType<T[P], AggregateLanguage[P]>;
  };

  export type languageGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: languageWhereInput;
    orderBy?:
      | languageOrderByWithAggregationInput
      | languageOrderByWithAggregationInput[];
    by: LanguageScalarFieldEnum[] | LanguageScalarFieldEnum;
    having?: languageScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: LanguageCountAggregateInputType | true;
    _min?: LanguageMinAggregateInputType;
    _max?: LanguageMaxAggregateInputType;
  };

  export type LanguageGroupByOutputType = {
    languageCode: string;
    languageName: string;
    statusCode: string;
    _count: LanguageCountAggregateOutputType | null;
    _min: LanguageMinAggregateOutputType | null;
    _max: LanguageMaxAggregateOutputType | null;
  };

  type GetLanguageGroupByPayload<T extends languageGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<LanguageGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof LanguageGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LanguageGroupByOutputType[P]>
            : GetScalarType<T[P], LanguageGroupByOutputType[P]>;
        }
      >
    >;

  export type languageSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      languageCode?: boolean;
      languageName?: boolean;
      statusCode?: boolean;
      audios?: boolean | language$audiosArgs<ExtArgs>;
      profiles?: boolean | language$profilesArgs<ExtArgs>;
      subtitles?: boolean | language$subtitlesArgs<ExtArgs>;
      status?: boolean | statusDefaultArgs<ExtArgs>;
      _count?: boolean | LanguageCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["language"]
  >;

  export type languageSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      languageCode?: boolean;
      languageName?: boolean;
      statusCode?: boolean;
      status?: boolean | statusDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["language"]
  >;

  export type languageSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      languageCode?: boolean;
      languageName?: boolean;
      statusCode?: boolean;
      status?: boolean | statusDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["language"]
  >;

  export type languageSelectScalar = {
    languageCode?: boolean;
    languageName?: boolean;
    statusCode?: boolean;
  };

  export type languageOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "languageCode" | "languageName" | "statusCode",
    ExtArgs["result"]["language"]
  >;
  export type languageInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    audios?: boolean | language$audiosArgs<ExtArgs>;
    profiles?: boolean | language$profilesArgs<ExtArgs>;
    subtitles?: boolean | language$subtitlesArgs<ExtArgs>;
    status?: boolean | statusDefaultArgs<ExtArgs>;
    _count?: boolean | LanguageCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type languageIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    status?: boolean | statusDefaultArgs<ExtArgs>;
  };
  export type languageIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    status?: boolean | statusDefaultArgs<ExtArgs>;
  };

  export type $languagePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "language";
    objects: {
      audios: Prisma.$audioPayload<ExtArgs>[];
      profiles: Prisma.$userProfilePayload<ExtArgs>[];
      subtitles: Prisma.$subtitlePayload<ExtArgs>[];
      status: Prisma.$statusPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        languageCode: string;
        languageName: string;
        statusCode: string;
      },
      ExtArgs["result"]["language"]
    >;
    composites: {};
  };

  type languageGetPayload<
    S extends boolean | null | undefined | languageDefaultArgs,
  > = $Result.GetResult<Prisma.$languagePayload, S>;

  type languageCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<languageFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: LanguageCountAggregateInputType | true;
  };

  export interface languageDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["language"];
      meta: { name: "language" };
    };
    /**
     * Find zero or one Language that matches the filter.
     * @param {languageFindUniqueArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends languageFindUniqueArgs>(
      args: SelectSubset<T, languageFindUniqueArgs<ExtArgs>>,
    ): Prisma__languageClient<
      $Result.GetResult<
        Prisma.$languagePayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Language that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {languageFindUniqueOrThrowArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends languageFindUniqueOrThrowArgs>(
      args: SelectSubset<T, languageFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__languageClient<
      $Result.GetResult<
        Prisma.$languagePayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Language that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {languageFindFirstArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends languageFindFirstArgs>(
      args?: SelectSubset<T, languageFindFirstArgs<ExtArgs>>,
    ): Prisma__languageClient<
      $Result.GetResult<
        Prisma.$languagePayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Language that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {languageFindFirstOrThrowArgs} args - Arguments to find a Language
     * @example
     * // Get one Language
     * const language = await prisma.language.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends languageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, languageFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__languageClient<
      $Result.GetResult<
        Prisma.$languagePayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Languages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {languageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Languages
     * const languages = await prisma.language.findMany()
     *
     * // Get first 10 Languages
     * const languages = await prisma.language.findMany({ take: 10 })
     *
     * // Only select the `languageCode`
     * const languageWithLanguageCodeOnly = await prisma.language.findMany({ select: { languageCode: true } })
     *
     */
    findMany<T extends languageFindManyArgs>(
      args?: SelectSubset<T, languageFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$languagePayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Language.
     * @param {languageCreateArgs} args - Arguments to create a Language.
     * @example
     * // Create one Language
     * const Language = await prisma.language.create({
     *   data: {
     *     // ... data to create a Language
     *   }
     * })
     *
     */
    create<T extends languageCreateArgs>(
      args: SelectSubset<T, languageCreateArgs<ExtArgs>>,
    ): Prisma__languageClient<
      $Result.GetResult<
        Prisma.$languagePayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Languages.
     * @param {languageCreateManyArgs} args - Arguments to create many Languages.
     * @example
     * // Create many Languages
     * const language = await prisma.language.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends languageCreateManyArgs>(
      args?: SelectSubset<T, languageCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Languages and returns the data saved in the database.
     * @param {languageCreateManyAndReturnArgs} args - Arguments to create many Languages.
     * @example
     * // Create many Languages
     * const language = await prisma.language.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Languages and only return the `languageCode`
     * const languageWithLanguageCodeOnly = await prisma.language.createManyAndReturn({
     *   select: { languageCode: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends languageCreateManyAndReturnArgs>(
      args?: SelectSubset<T, languageCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$languagePayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Language.
     * @param {languageDeleteArgs} args - Arguments to delete one Language.
     * @example
     * // Delete one Language
     * const Language = await prisma.language.delete({
     *   where: {
     *     // ... filter to delete one Language
     *   }
     * })
     *
     */
    delete<T extends languageDeleteArgs>(
      args: SelectSubset<T, languageDeleteArgs<ExtArgs>>,
    ): Prisma__languageClient<
      $Result.GetResult<
        Prisma.$languagePayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Language.
     * @param {languageUpdateArgs} args - Arguments to update one Language.
     * @example
     * // Update one Language
     * const language = await prisma.language.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends languageUpdateArgs>(
      args: SelectSubset<T, languageUpdateArgs<ExtArgs>>,
    ): Prisma__languageClient<
      $Result.GetResult<
        Prisma.$languagePayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Languages.
     * @param {languageDeleteManyArgs} args - Arguments to filter Languages to delete.
     * @example
     * // Delete a few Languages
     * const { count } = await prisma.language.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends languageDeleteManyArgs>(
      args?: SelectSubset<T, languageDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {languageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Languages
     * const language = await prisma.language.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends languageUpdateManyArgs>(
      args: SelectSubset<T, languageUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Languages and returns the data updated in the database.
     * @param {languageUpdateManyAndReturnArgs} args - Arguments to update many Languages.
     * @example
     * // Update many Languages
     * const language = await prisma.language.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Languages and only return the `languageCode`
     * const languageWithLanguageCodeOnly = await prisma.language.updateManyAndReturn({
     *   select: { languageCode: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends languageUpdateManyAndReturnArgs>(
      args: SelectSubset<T, languageUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$languagePayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Language.
     * @param {languageUpsertArgs} args - Arguments to update or create a Language.
     * @example
     * // Update or create a Language
     * const language = await prisma.language.upsert({
     *   create: {
     *     // ... data to create a Language
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Language we want to update
     *   }
     * })
     */
    upsert<T extends languageUpsertArgs>(
      args: SelectSubset<T, languageUpsertArgs<ExtArgs>>,
    ): Prisma__languageClient<
      $Result.GetResult<
        Prisma.$languagePayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {languageCountArgs} args - Arguments to filter Languages to count.
     * @example
     * // Count the number of Languages
     * const count = await prisma.language.count({
     *   where: {
     *     // ... the filter for the Languages we want to count
     *   }
     * })
     **/
    count<T extends languageCountArgs>(
      args?: Subset<T, languageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], LanguageCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends LanguageAggregateArgs>(
      args: Subset<T, LanguageAggregateArgs>,
    ): Prisma.PrismaPromise<GetLanguageAggregateType<T>>;

    /**
     * Group by Language.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {languageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends languageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: languageGroupByArgs["orderBy"] }
        : { orderBy?: languageGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, languageGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetLanguageGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the language model
     */
    readonly fields: languageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for language.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__languageClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    audios<T extends language$audiosArgs<ExtArgs> = {}>(
      args?: Subset<T, language$audiosArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$audioPayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    profiles<T extends language$profilesArgs<ExtArgs> = {}>(
      args?: Subset<T, language$profilesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$userProfilePayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    subtitles<T extends language$subtitlesArgs<ExtArgs> = {}>(
      args?: Subset<T, language$subtitlesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$subtitlePayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    status<T extends statusDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, statusDefaultArgs<ExtArgs>>,
    ): Prisma__statusClient<
      | $Result.GetResult<
          Prisma.$statusPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the language model
   */
  interface languageFieldRefs {
    readonly languageCode: FieldRef<"language", "String">;
    readonly languageName: FieldRef<"language", "String">;
    readonly statusCode: FieldRef<"language", "String">;
  }

  // Custom InputTypes
  /**
   * language findUnique
   */
  export type languageFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the language
     */
    select?: languageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the language
     */
    omit?: languageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: languageInclude<ExtArgs> | null;
    /**
     * Filter, which language to fetch.
     */
    where: languageWhereUniqueInput;
  };

  /**
   * language findUniqueOrThrow
   */
  export type languageFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the language
     */
    select?: languageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the language
     */
    omit?: languageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: languageInclude<ExtArgs> | null;
    /**
     * Filter, which language to fetch.
     */
    where: languageWhereUniqueInput;
  };

  /**
   * language findFirst
   */
  export type languageFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the language
     */
    select?: languageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the language
     */
    omit?: languageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: languageInclude<ExtArgs> | null;
    /**
     * Filter, which language to fetch.
     */
    where?: languageWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of languages to fetch.
     */
    orderBy?:
      | languageOrderByWithRelationInput
      | languageOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for languages.
     */
    cursor?: languageWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` languages from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` languages.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of languages.
     */
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[];
  };

  /**
   * language findFirstOrThrow
   */
  export type languageFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the language
     */
    select?: languageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the language
     */
    omit?: languageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: languageInclude<ExtArgs> | null;
    /**
     * Filter, which language to fetch.
     */
    where?: languageWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of languages to fetch.
     */
    orderBy?:
      | languageOrderByWithRelationInput
      | languageOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for languages.
     */
    cursor?: languageWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` languages from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` languages.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of languages.
     */
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[];
  };

  /**
   * language findMany
   */
  export type languageFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the language
     */
    select?: languageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the language
     */
    omit?: languageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: languageInclude<ExtArgs> | null;
    /**
     * Filter, which languages to fetch.
     */
    where?: languageWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of languages to fetch.
     */
    orderBy?:
      | languageOrderByWithRelationInput
      | languageOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing languages.
     */
    cursor?: languageWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` languages from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` languages.
     */
    skip?: number;
    distinct?: LanguageScalarFieldEnum | LanguageScalarFieldEnum[];
  };

  /**
   * language create
   */
  export type languageCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the language
     */
    select?: languageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the language
     */
    omit?: languageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: languageInclude<ExtArgs> | null;
    /**
     * The data needed to create a language.
     */
    data: XOR<languageCreateInput, languageUncheckedCreateInput>;
  };

  /**
   * language createMany
   */
  export type languageCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many languages.
     */
    data: languageCreateManyInput | languageCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * language createManyAndReturn
   */
  export type languageCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the language
     */
    select?: languageSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the language
     */
    omit?: languageOmit<ExtArgs> | null;
    /**
     * The data used to create many languages.
     */
    data: languageCreateManyInput | languageCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: languageIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * language update
   */
  export type languageUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the language
     */
    select?: languageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the language
     */
    omit?: languageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: languageInclude<ExtArgs> | null;
    /**
     * The data needed to update a language.
     */
    data: XOR<languageUpdateInput, languageUncheckedUpdateInput>;
    /**
     * Choose, which language to update.
     */
    where: languageWhereUniqueInput;
  };

  /**
   * language updateMany
   */
  export type languageUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update languages.
     */
    data: XOR<
      languageUpdateManyMutationInput,
      languageUncheckedUpdateManyInput
    >;
    /**
     * Filter which languages to update
     */
    where?: languageWhereInput;
    /**
     * Limit how many languages to update.
     */
    limit?: number;
  };

  /**
   * language updateManyAndReturn
   */
  export type languageUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the language
     */
    select?: languageSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the language
     */
    omit?: languageOmit<ExtArgs> | null;
    /**
     * The data used to update languages.
     */
    data: XOR<
      languageUpdateManyMutationInput,
      languageUncheckedUpdateManyInput
    >;
    /**
     * Filter which languages to update
     */
    where?: languageWhereInput;
    /**
     * Limit how many languages to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: languageIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * language upsert
   */
  export type languageUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the language
     */
    select?: languageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the language
     */
    omit?: languageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: languageInclude<ExtArgs> | null;
    /**
     * The filter to search for the language to update in case it exists.
     */
    where: languageWhereUniqueInput;
    /**
     * In case the language found by the `where` argument doesn't exist, create a new language with this data.
     */
    create: XOR<languageCreateInput, languageUncheckedCreateInput>;
    /**
     * In case the language was found with the provided `where` argument, update it with this data.
     */
    update: XOR<languageUpdateInput, languageUncheckedUpdateInput>;
  };

  /**
   * language delete
   */
  export type languageDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the language
     */
    select?: languageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the language
     */
    omit?: languageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: languageInclude<ExtArgs> | null;
    /**
     * Filter which language to delete.
     */
    where: languageWhereUniqueInput;
  };

  /**
   * language deleteMany
   */
  export type languageDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which languages to delete
     */
    where?: languageWhereInput;
    /**
     * Limit how many languages to delete.
     */
    limit?: number;
  };

  /**
   * language.audios
   */
  export type language$audiosArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the audio
     */
    select?: audioSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the audio
     */
    omit?: audioOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: audioInclude<ExtArgs> | null;
    where?: audioWhereInput;
    orderBy?: audioOrderByWithRelationInput | audioOrderByWithRelationInput[];
    cursor?: audioWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AudioScalarFieldEnum | AudioScalarFieldEnum[];
  };

  /**
   * language.profiles
   */
  export type language$profilesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the userProfile
     */
    select?: userProfileSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the userProfile
     */
    omit?: userProfileOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userProfileInclude<ExtArgs> | null;
    where?: userProfileWhereInput;
    orderBy?:
      | userProfileOrderByWithRelationInput
      | userProfileOrderByWithRelationInput[];
    cursor?: userProfileWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[];
  };

  /**
   * language.subtitles
   */
  export type language$subtitlesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the subtitle
     */
    select?: subtitleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the subtitle
     */
    omit?: subtitleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subtitleInclude<ExtArgs> | null;
    where?: subtitleWhereInput;
    orderBy?:
      | subtitleOrderByWithRelationInput
      | subtitleOrderByWithRelationInput[];
    cursor?: subtitleWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: SubtitleScalarFieldEnum | SubtitleScalarFieldEnum[];
  };

  /**
   * language without action
   */
  export type languageDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the language
     */
    select?: languageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the language
     */
    omit?: languageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: languageInclude<ExtArgs> | null;
  };

  /**
   * Model subtitle
   */

  export type AggregateSubtitle = {
    _count: SubtitleCountAggregateOutputType | null;
    _min: SubtitleMinAggregateOutputType | null;
    _max: SubtitleMaxAggregateOutputType | null;
  };

  export type SubtitleMinAggregateOutputType = {
    subtitleId: string | null;
    subtitleText: string | null;
    languageCode: string | null;
    createdBy: string | null;
    modifiedBy: string | null;
    createdAt: Date | null;
    modifiedAt: Date | null;
    statusCode: string | null;
  };

  export type SubtitleMaxAggregateOutputType = {
    subtitleId: string | null;
    subtitleText: string | null;
    languageCode: string | null;
    createdBy: string | null;
    modifiedBy: string | null;
    createdAt: Date | null;
    modifiedAt: Date | null;
    statusCode: string | null;
  };

  export type SubtitleCountAggregateOutputType = {
    subtitleId: number;
    subtitleText: number;
    languageCode: number;
    createdBy: number;
    modifiedBy: number;
    createdAt: number;
    modifiedAt: number;
    statusCode: number;
    _all: number;
  };

  export type SubtitleMinAggregateInputType = {
    subtitleId?: true;
    subtitleText?: true;
    languageCode?: true;
    createdBy?: true;
    modifiedBy?: true;
    createdAt?: true;
    modifiedAt?: true;
    statusCode?: true;
  };

  export type SubtitleMaxAggregateInputType = {
    subtitleId?: true;
    subtitleText?: true;
    languageCode?: true;
    createdBy?: true;
    modifiedBy?: true;
    createdAt?: true;
    modifiedAt?: true;
    statusCode?: true;
  };

  export type SubtitleCountAggregateInputType = {
    subtitleId?: true;
    subtitleText?: true;
    languageCode?: true;
    createdBy?: true;
    modifiedBy?: true;
    createdAt?: true;
    modifiedAt?: true;
    statusCode?: true;
    _all?: true;
  };

  export type SubtitleAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which subtitle to aggregate.
     */
    where?: subtitleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of subtitles to fetch.
     */
    orderBy?:
      | subtitleOrderByWithRelationInput
      | subtitleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: subtitleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` subtitles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` subtitles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned subtitles
     **/
    _count?: true | SubtitleCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: SubtitleMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: SubtitleMaxAggregateInputType;
  };

  export type GetSubtitleAggregateType<T extends SubtitleAggregateArgs> = {
    [P in keyof T & keyof AggregateSubtitle]: P extends "_count" | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubtitle[P]>
      : GetScalarType<T[P], AggregateSubtitle[P]>;
  };

  export type subtitleGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: subtitleWhereInput;
    orderBy?:
      | subtitleOrderByWithAggregationInput
      | subtitleOrderByWithAggregationInput[];
    by: SubtitleScalarFieldEnum[] | SubtitleScalarFieldEnum;
    having?: subtitleScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: SubtitleCountAggregateInputType | true;
    _min?: SubtitleMinAggregateInputType;
    _max?: SubtitleMaxAggregateInputType;
  };

  export type SubtitleGroupByOutputType = {
    subtitleId: string;
    subtitleText: string;
    languageCode: string;
    createdBy: string;
    modifiedBy: string;
    createdAt: Date;
    modifiedAt: Date;
    statusCode: string;
    _count: SubtitleCountAggregateOutputType | null;
    _min: SubtitleMinAggregateOutputType | null;
    _max: SubtitleMaxAggregateOutputType | null;
  };

  type GetSubtitleGroupByPayload<T extends subtitleGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<SubtitleGroupByOutputType, T["by"]> & {
          [P in keyof T & keyof SubtitleGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubtitleGroupByOutputType[P]>
            : GetScalarType<T[P], SubtitleGroupByOutputType[P]>;
        }
      >
    >;

  export type subtitleSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      subtitleId?: boolean;
      subtitleText?: boolean;
      languageCode?: boolean;
      createdBy?: boolean;
      modifiedBy?: boolean;
      createdAt?: boolean;
      modifiedAt?: boolean;
      statusCode?: boolean;
      language?: boolean | languageDefaultArgs<ExtArgs>;
      status?: boolean | statusDefaultArgs<ExtArgs>;
      exhibits?: boolean | subtitle$exhibitsArgs<ExtArgs>;
      _count?: boolean | SubtitleCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["subtitle"]
  >;

  export type subtitleSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      subtitleId?: boolean;
      subtitleText?: boolean;
      languageCode?: boolean;
      createdBy?: boolean;
      modifiedBy?: boolean;
      createdAt?: boolean;
      modifiedAt?: boolean;
      statusCode?: boolean;
      language?: boolean | languageDefaultArgs<ExtArgs>;
      status?: boolean | statusDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["subtitle"]
  >;

  export type subtitleSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      subtitleId?: boolean;
      subtitleText?: boolean;
      languageCode?: boolean;
      createdBy?: boolean;
      modifiedBy?: boolean;
      createdAt?: boolean;
      modifiedAt?: boolean;
      statusCode?: boolean;
      language?: boolean | languageDefaultArgs<ExtArgs>;
      status?: boolean | statusDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["subtitle"]
  >;

  export type subtitleSelectScalar = {
    subtitleId?: boolean;
    subtitleText?: boolean;
    languageCode?: boolean;
    createdBy?: boolean;
    modifiedBy?: boolean;
    createdAt?: boolean;
    modifiedAt?: boolean;
    statusCode?: boolean;
  };

  export type subtitleOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | "subtitleId"
    | "subtitleText"
    | "languageCode"
    | "createdBy"
    | "modifiedBy"
    | "createdAt"
    | "modifiedAt"
    | "statusCode",
    ExtArgs["result"]["subtitle"]
  >;
  export type subtitleInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    language?: boolean | languageDefaultArgs<ExtArgs>;
    status?: boolean | statusDefaultArgs<ExtArgs>;
    exhibits?: boolean | subtitle$exhibitsArgs<ExtArgs>;
    _count?: boolean | SubtitleCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type subtitleIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    language?: boolean | languageDefaultArgs<ExtArgs>;
    status?: boolean | statusDefaultArgs<ExtArgs>;
  };
  export type subtitleIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    language?: boolean | languageDefaultArgs<ExtArgs>;
    status?: boolean | statusDefaultArgs<ExtArgs>;
  };

  export type $subtitlePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "subtitle";
    objects: {
      language: Prisma.$languagePayload<ExtArgs>;
      status: Prisma.$statusPayload<ExtArgs>;
      exhibits: Prisma.$exhibitSubtitlePayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        subtitleId: string;
        subtitleText: string;
        languageCode: string;
        createdBy: string;
        modifiedBy: string;
        createdAt: Date;
        modifiedAt: Date;
        statusCode: string;
      },
      ExtArgs["result"]["subtitle"]
    >;
    composites: {};
  };

  type subtitleGetPayload<
    S extends boolean | null | undefined | subtitleDefaultArgs,
  > = $Result.GetResult<Prisma.$subtitlePayload, S>;

  type subtitleCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<subtitleFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
    select?: SubtitleCountAggregateInputType | true;
  };

  export interface subtitleDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["subtitle"];
      meta: { name: "subtitle" };
    };
    /**
     * Find zero or one Subtitle that matches the filter.
     * @param {subtitleFindUniqueArgs} args - Arguments to find a Subtitle
     * @example
     * // Get one Subtitle
     * const subtitle = await prisma.subtitle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends subtitleFindUniqueArgs>(
      args: SelectSubset<T, subtitleFindUniqueArgs<ExtArgs>>,
    ): Prisma__subtitleClient<
      $Result.GetResult<
        Prisma.$subtitlePayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Subtitle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {subtitleFindUniqueOrThrowArgs} args - Arguments to find a Subtitle
     * @example
     * // Get one Subtitle
     * const subtitle = await prisma.subtitle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends subtitleFindUniqueOrThrowArgs>(
      args: SelectSubset<T, subtitleFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__subtitleClient<
      $Result.GetResult<
        Prisma.$subtitlePayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Subtitle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subtitleFindFirstArgs} args - Arguments to find a Subtitle
     * @example
     * // Get one Subtitle
     * const subtitle = await prisma.subtitle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends subtitleFindFirstArgs>(
      args?: SelectSubset<T, subtitleFindFirstArgs<ExtArgs>>,
    ): Prisma__subtitleClient<
      $Result.GetResult<
        Prisma.$subtitlePayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Subtitle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subtitleFindFirstOrThrowArgs} args - Arguments to find a Subtitle
     * @example
     * // Get one Subtitle
     * const subtitle = await prisma.subtitle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends subtitleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, subtitleFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__subtitleClient<
      $Result.GetResult<
        Prisma.$subtitlePayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Subtitles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subtitleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subtitles
     * const subtitles = await prisma.subtitle.findMany()
     *
     * // Get first 10 Subtitles
     * const subtitles = await prisma.subtitle.findMany({ take: 10 })
     *
     * // Only select the `subtitleId`
     * const subtitleWithSubtitleIdOnly = await prisma.subtitle.findMany({ select: { subtitleId: true } })
     *
     */
    findMany<T extends subtitleFindManyArgs>(
      args?: SelectSubset<T, subtitleFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$subtitlePayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Subtitle.
     * @param {subtitleCreateArgs} args - Arguments to create a Subtitle.
     * @example
     * // Create one Subtitle
     * const Subtitle = await prisma.subtitle.create({
     *   data: {
     *     // ... data to create a Subtitle
     *   }
     * })
     *
     */
    create<T extends subtitleCreateArgs>(
      args: SelectSubset<T, subtitleCreateArgs<ExtArgs>>,
    ): Prisma__subtitleClient<
      $Result.GetResult<
        Prisma.$subtitlePayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Subtitles.
     * @param {subtitleCreateManyArgs} args - Arguments to create many Subtitles.
     * @example
     * // Create many Subtitles
     * const subtitle = await prisma.subtitle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends subtitleCreateManyArgs>(
      args?: SelectSubset<T, subtitleCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Subtitles and returns the data saved in the database.
     * @param {subtitleCreateManyAndReturnArgs} args - Arguments to create many Subtitles.
     * @example
     * // Create many Subtitles
     * const subtitle = await prisma.subtitle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Subtitles and only return the `subtitleId`
     * const subtitleWithSubtitleIdOnly = await prisma.subtitle.createManyAndReturn({
     *   select: { subtitleId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends subtitleCreateManyAndReturnArgs>(
      args?: SelectSubset<T, subtitleCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$subtitlePayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Subtitle.
     * @param {subtitleDeleteArgs} args - Arguments to delete one Subtitle.
     * @example
     * // Delete one Subtitle
     * const Subtitle = await prisma.subtitle.delete({
     *   where: {
     *     // ... filter to delete one Subtitle
     *   }
     * })
     *
     */
    delete<T extends subtitleDeleteArgs>(
      args: SelectSubset<T, subtitleDeleteArgs<ExtArgs>>,
    ): Prisma__subtitleClient<
      $Result.GetResult<
        Prisma.$subtitlePayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Subtitle.
     * @param {subtitleUpdateArgs} args - Arguments to update one Subtitle.
     * @example
     * // Update one Subtitle
     * const subtitle = await prisma.subtitle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends subtitleUpdateArgs>(
      args: SelectSubset<T, subtitleUpdateArgs<ExtArgs>>,
    ): Prisma__subtitleClient<
      $Result.GetResult<
        Prisma.$subtitlePayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Subtitles.
     * @param {subtitleDeleteManyArgs} args - Arguments to filter Subtitles to delete.
     * @example
     * // Delete a few Subtitles
     * const { count } = await prisma.subtitle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends subtitleDeleteManyArgs>(
      args?: SelectSubset<T, subtitleDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Subtitles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subtitleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subtitles
     * const subtitle = await prisma.subtitle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends subtitleUpdateManyArgs>(
      args: SelectSubset<T, subtitleUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Subtitles and returns the data updated in the database.
     * @param {subtitleUpdateManyAndReturnArgs} args - Arguments to update many Subtitles.
     * @example
     * // Update many Subtitles
     * const subtitle = await prisma.subtitle.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Subtitles and only return the `subtitleId`
     * const subtitleWithSubtitleIdOnly = await prisma.subtitle.updateManyAndReturn({
     *   select: { subtitleId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends subtitleUpdateManyAndReturnArgs>(
      args: SelectSubset<T, subtitleUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$subtitlePayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Subtitle.
     * @param {subtitleUpsertArgs} args - Arguments to update or create a Subtitle.
     * @example
     * // Update or create a Subtitle
     * const subtitle = await prisma.subtitle.upsert({
     *   create: {
     *     // ... data to create a Subtitle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subtitle we want to update
     *   }
     * })
     */
    upsert<T extends subtitleUpsertArgs>(
      args: SelectSubset<T, subtitleUpsertArgs<ExtArgs>>,
    ): Prisma__subtitleClient<
      $Result.GetResult<
        Prisma.$subtitlePayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Subtitles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subtitleCountArgs} args - Arguments to filter Subtitles to count.
     * @example
     * // Count the number of Subtitles
     * const count = await prisma.subtitle.count({
     *   where: {
     *     // ... the filter for the Subtitles we want to count
     *   }
     * })
     **/
    count<T extends subtitleCountArgs>(
      args?: Subset<T, subtitleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], SubtitleCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Subtitle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtitleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends SubtitleAggregateArgs>(
      args: Subset<T, SubtitleAggregateArgs>,
    ): Prisma.PrismaPromise<GetSubtitleAggregateType<T>>;

    /**
     * Group by Subtitle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subtitleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends subtitleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: subtitleGroupByArgs["orderBy"] }
        : { orderBy?: subtitleGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, subtitleGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetSubtitleGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the subtitle model
     */
    readonly fields: subtitleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for subtitle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__subtitleClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    language<T extends languageDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, languageDefaultArgs<ExtArgs>>,
    ): Prisma__languageClient<
      | $Result.GetResult<
          Prisma.$languagePayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    status<T extends statusDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, statusDefaultArgs<ExtArgs>>,
    ): Prisma__statusClient<
      | $Result.GetResult<
          Prisma.$statusPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    exhibits<T extends subtitle$exhibitsArgs<ExtArgs> = {}>(
      args?: Subset<T, subtitle$exhibitsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$exhibitSubtitlePayload<ExtArgs>,
          T,
          "findMany",
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the subtitle model
   */
  interface subtitleFieldRefs {
    readonly subtitleId: FieldRef<"subtitle", "String">;
    readonly subtitleText: FieldRef<"subtitle", "String">;
    readonly languageCode: FieldRef<"subtitle", "String">;
    readonly createdBy: FieldRef<"subtitle", "String">;
    readonly modifiedBy: FieldRef<"subtitle", "String">;
    readonly createdAt: FieldRef<"subtitle", "DateTime">;
    readonly modifiedAt: FieldRef<"subtitle", "DateTime">;
    readonly statusCode: FieldRef<"subtitle", "String">;
  }

  // Custom InputTypes
  /**
   * subtitle findUnique
   */
  export type subtitleFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the subtitle
     */
    select?: subtitleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the subtitle
     */
    omit?: subtitleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subtitleInclude<ExtArgs> | null;
    /**
     * Filter, which subtitle to fetch.
     */
    where: subtitleWhereUniqueInput;
  };

  /**
   * subtitle findUniqueOrThrow
   */
  export type subtitleFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the subtitle
     */
    select?: subtitleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the subtitle
     */
    omit?: subtitleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subtitleInclude<ExtArgs> | null;
    /**
     * Filter, which subtitle to fetch.
     */
    where: subtitleWhereUniqueInput;
  };

  /**
   * subtitle findFirst
   */
  export type subtitleFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the subtitle
     */
    select?: subtitleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the subtitle
     */
    omit?: subtitleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subtitleInclude<ExtArgs> | null;
    /**
     * Filter, which subtitle to fetch.
     */
    where?: subtitleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of subtitles to fetch.
     */
    orderBy?:
      | subtitleOrderByWithRelationInput
      | subtitleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for subtitles.
     */
    cursor?: subtitleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` subtitles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` subtitles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of subtitles.
     */
    distinct?: SubtitleScalarFieldEnum | SubtitleScalarFieldEnum[];
  };

  /**
   * subtitle findFirstOrThrow
   */
  export type subtitleFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the subtitle
     */
    select?: subtitleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the subtitle
     */
    omit?: subtitleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subtitleInclude<ExtArgs> | null;
    /**
     * Filter, which subtitle to fetch.
     */
    where?: subtitleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of subtitles to fetch.
     */
    orderBy?:
      | subtitleOrderByWithRelationInput
      | subtitleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for subtitles.
     */
    cursor?: subtitleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` subtitles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` subtitles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of subtitles.
     */
    distinct?: SubtitleScalarFieldEnum | SubtitleScalarFieldEnum[];
  };

  /**
   * subtitle findMany
   */
  export type subtitleFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the subtitle
     */
    select?: subtitleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the subtitle
     */
    omit?: subtitleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subtitleInclude<ExtArgs> | null;
    /**
     * Filter, which subtitles to fetch.
     */
    where?: subtitleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of subtitles to fetch.
     */
    orderBy?:
      | subtitleOrderByWithRelationInput
      | subtitleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing subtitles.
     */
    cursor?: subtitleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` subtitles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` subtitles.
     */
    skip?: number;
    distinct?: SubtitleScalarFieldEnum | SubtitleScalarFieldEnum[];
  };

  /**
   * subtitle create
   */
  export type subtitleCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the subtitle
     */
    select?: subtitleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the subtitle
     */
    omit?: subtitleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subtitleInclude<ExtArgs> | null;
    /**
     * The data needed to create a subtitle.
     */
    data: XOR<subtitleCreateInput, subtitleUncheckedCreateInput>;
  };

  /**
   * subtitle createMany
   */
  export type subtitleCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many subtitles.
     */
    data: subtitleCreateManyInput | subtitleCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * subtitle createManyAndReturn
   */
  export type subtitleCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the subtitle
     */
    select?: subtitleSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the subtitle
     */
    omit?: subtitleOmit<ExtArgs> | null;
    /**
     * The data used to create many subtitles.
     */
    data: subtitleCreateManyInput | subtitleCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subtitleIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * subtitle update
   */
  export type subtitleUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the subtitle
     */
    select?: subtitleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the subtitle
     */
    omit?: subtitleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subtitleInclude<ExtArgs> | null;
    /**
     * The data needed to update a subtitle.
     */
    data: XOR<subtitleUpdateInput, subtitleUncheckedUpdateInput>;
    /**
     * Choose, which subtitle to update.
     */
    where: subtitleWhereUniqueInput;
  };

  /**
   * subtitle updateMany
   */
  export type subtitleUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update subtitles.
     */
    data: XOR<
      subtitleUpdateManyMutationInput,
      subtitleUncheckedUpdateManyInput
    >;
    /**
     * Filter which subtitles to update
     */
    where?: subtitleWhereInput;
    /**
     * Limit how many subtitles to update.
     */
    limit?: number;
  };

  /**
   * subtitle updateManyAndReturn
   */
  export type subtitleUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the subtitle
     */
    select?: subtitleSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the subtitle
     */
    omit?: subtitleOmit<ExtArgs> | null;
    /**
     * The data used to update subtitles.
     */
    data: XOR<
      subtitleUpdateManyMutationInput,
      subtitleUncheckedUpdateManyInput
    >;
    /**
     * Filter which subtitles to update
     */
    where?: subtitleWhereInput;
    /**
     * Limit how many subtitles to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subtitleIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * subtitle upsert
   */
  export type subtitleUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the subtitle
     */
    select?: subtitleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the subtitle
     */
    omit?: subtitleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subtitleInclude<ExtArgs> | null;
    /**
     * The filter to search for the subtitle to update in case it exists.
     */
    where: subtitleWhereUniqueInput;
    /**
     * In case the subtitle found by the `where` argument doesn't exist, create a new subtitle with this data.
     */
    create: XOR<subtitleCreateInput, subtitleUncheckedCreateInput>;
    /**
     * In case the subtitle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<subtitleUpdateInput, subtitleUncheckedUpdateInput>;
  };

  /**
   * subtitle delete
   */
  export type subtitleDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the subtitle
     */
    select?: subtitleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the subtitle
     */
    omit?: subtitleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subtitleInclude<ExtArgs> | null;
    /**
     * Filter which subtitle to delete.
     */
    where: subtitleWhereUniqueInput;
  };

  /**
   * subtitle deleteMany
   */
  export type subtitleDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which subtitles to delete
     */
    where?: subtitleWhereInput;
    /**
     * Limit how many subtitles to delete.
     */
    limit?: number;
  };

  /**
   * subtitle.exhibits
   */
  export type subtitle$exhibitsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the exhibitSubtitle
     */
    select?: exhibitSubtitleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the exhibitSubtitle
     */
    omit?: exhibitSubtitleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exhibitSubtitleInclude<ExtArgs> | null;
    where?: exhibitSubtitleWhereInput;
    orderBy?:
      | exhibitSubtitleOrderByWithRelationInput
      | exhibitSubtitleOrderByWithRelationInput[];
    cursor?: exhibitSubtitleWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | ExhibitSubtitleScalarFieldEnum
      | ExhibitSubtitleScalarFieldEnum[];
  };

  /**
   * subtitle without action
   */
  export type subtitleDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the subtitle
     */
    select?: subtitleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the subtitle
     */
    omit?: subtitleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subtitleInclude<ExtArgs> | null;
  };

  /**
   * Model exhibitSubtitle
   */

  export type AggregateExhibitSubtitle = {
    _count: ExhibitSubtitleCountAggregateOutputType | null;
    _min: ExhibitSubtitleMinAggregateOutputType | null;
    _max: ExhibitSubtitleMaxAggregateOutputType | null;
  };

  export type ExhibitSubtitleMinAggregateOutputType = {
    exhibitId: string | null;
    subtitleId: string | null;
    createdAt: Date | null;
  };

  export type ExhibitSubtitleMaxAggregateOutputType = {
    exhibitId: string | null;
    subtitleId: string | null;
    createdAt: Date | null;
  };

  export type ExhibitSubtitleCountAggregateOutputType = {
    exhibitId: number;
    subtitleId: number;
    createdAt: number;
    _all: number;
  };

  export type ExhibitSubtitleMinAggregateInputType = {
    exhibitId?: true;
    subtitleId?: true;
    createdAt?: true;
  };

  export type ExhibitSubtitleMaxAggregateInputType = {
    exhibitId?: true;
    subtitleId?: true;
    createdAt?: true;
  };

  export type ExhibitSubtitleCountAggregateInputType = {
    exhibitId?: true;
    subtitleId?: true;
    createdAt?: true;
    _all?: true;
  };

  export type ExhibitSubtitleAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which exhibitSubtitle to aggregate.
     */
    where?: exhibitSubtitleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of exhibitSubtitles to fetch.
     */
    orderBy?:
      | exhibitSubtitleOrderByWithRelationInput
      | exhibitSubtitleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: exhibitSubtitleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` exhibitSubtitles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` exhibitSubtitles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned exhibitSubtitles
     **/
    _count?: true | ExhibitSubtitleCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ExhibitSubtitleMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ExhibitSubtitleMaxAggregateInputType;
  };

  export type GetExhibitSubtitleAggregateType<
    T extends ExhibitSubtitleAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateExhibitSubtitle]: P extends
      | "_count"
      | "count"
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExhibitSubtitle[P]>
      : GetScalarType<T[P], AggregateExhibitSubtitle[P]>;
  };

  export type exhibitSubtitleGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: exhibitSubtitleWhereInput;
    orderBy?:
      | exhibitSubtitleOrderByWithAggregationInput
      | exhibitSubtitleOrderByWithAggregationInput[];
    by: ExhibitSubtitleScalarFieldEnum[] | ExhibitSubtitleScalarFieldEnum;
    having?: exhibitSubtitleScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ExhibitSubtitleCountAggregateInputType | true;
    _min?: ExhibitSubtitleMinAggregateInputType;
    _max?: ExhibitSubtitleMaxAggregateInputType;
  };

  export type ExhibitSubtitleGroupByOutputType = {
    exhibitId: string;
    subtitleId: string;
    createdAt: Date;
    _count: ExhibitSubtitleCountAggregateOutputType | null;
    _min: ExhibitSubtitleMinAggregateOutputType | null;
    _max: ExhibitSubtitleMaxAggregateOutputType | null;
  };

  type GetExhibitSubtitleGroupByPayload<T extends exhibitSubtitleGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ExhibitSubtitleGroupByOutputType, T["by"]> & {
          [P in keyof T &
            keyof ExhibitSubtitleGroupByOutputType]: P extends "_count"
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExhibitSubtitleGroupByOutputType[P]>
            : GetScalarType<T[P], ExhibitSubtitleGroupByOutputType[P]>;
        }
      >
    >;

  export type exhibitSubtitleSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      exhibitId?: boolean;
      subtitleId?: boolean;
      createdAt?: boolean;
      exhibit?: boolean | exhibitDefaultArgs<ExtArgs>;
      subtitle?: boolean | subtitleDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["exhibitSubtitle"]
  >;

  export type exhibitSubtitleSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      exhibitId?: boolean;
      subtitleId?: boolean;
      createdAt?: boolean;
      exhibit?: boolean | exhibitDefaultArgs<ExtArgs>;
      subtitle?: boolean | subtitleDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["exhibitSubtitle"]
  >;

  export type exhibitSubtitleSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      exhibitId?: boolean;
      subtitleId?: boolean;
      createdAt?: boolean;
      exhibit?: boolean | exhibitDefaultArgs<ExtArgs>;
      subtitle?: boolean | subtitleDefaultArgs<ExtArgs>;
    },
    ExtArgs["result"]["exhibitSubtitle"]
  >;

  export type exhibitSubtitleSelectScalar = {
    exhibitId?: boolean;
    subtitleId?: boolean;
    createdAt?: boolean;
  };

  export type exhibitSubtitleOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    "exhibitId" | "subtitleId" | "createdAt",
    ExtArgs["result"]["exhibitSubtitle"]
  >;
  export type exhibitSubtitleInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    exhibit?: boolean | exhibitDefaultArgs<ExtArgs>;
    subtitle?: boolean | subtitleDefaultArgs<ExtArgs>;
  };
  export type exhibitSubtitleIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    exhibit?: boolean | exhibitDefaultArgs<ExtArgs>;
    subtitle?: boolean | subtitleDefaultArgs<ExtArgs>;
  };
  export type exhibitSubtitleIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    exhibit?: boolean | exhibitDefaultArgs<ExtArgs>;
    subtitle?: boolean | subtitleDefaultArgs<ExtArgs>;
  };

  export type $exhibitSubtitlePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: "exhibitSubtitle";
    objects: {
      exhibit: Prisma.$exhibitPayload<ExtArgs>;
      subtitle: Prisma.$subtitlePayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        exhibitId: string;
        subtitleId: string;
        createdAt: Date;
      },
      ExtArgs["result"]["exhibitSubtitle"]
    >;
    composites: {};
  };

  type exhibitSubtitleGetPayload<
    S extends boolean | null | undefined | exhibitSubtitleDefaultArgs,
  > = $Result.GetResult<Prisma.$exhibitSubtitlePayload, S>;

  type exhibitSubtitleCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    exhibitSubtitleFindManyArgs,
    "select" | "include" | "distinct" | "omit"
  > & {
    select?: ExhibitSubtitleCountAggregateInputType | true;
  };

  export interface exhibitSubtitleDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>["model"]["exhibitSubtitle"];
      meta: { name: "exhibitSubtitle" };
    };
    /**
     * Find zero or one ExhibitSubtitle that matches the filter.
     * @param {exhibitSubtitleFindUniqueArgs} args - Arguments to find a ExhibitSubtitle
     * @example
     * // Get one ExhibitSubtitle
     * const exhibitSubtitle = await prisma.exhibitSubtitle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends exhibitSubtitleFindUniqueArgs>(
      args: SelectSubset<T, exhibitSubtitleFindUniqueArgs<ExtArgs>>,
    ): Prisma__exhibitSubtitleClient<
      $Result.GetResult<
        Prisma.$exhibitSubtitlePayload<ExtArgs>,
        T,
        "findUnique",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one ExhibitSubtitle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {exhibitSubtitleFindUniqueOrThrowArgs} args - Arguments to find a ExhibitSubtitle
     * @example
     * // Get one ExhibitSubtitle
     * const exhibitSubtitle = await prisma.exhibitSubtitle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends exhibitSubtitleFindUniqueOrThrowArgs>(
      args: SelectSubset<T, exhibitSubtitleFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__exhibitSubtitleClient<
      $Result.GetResult<
        Prisma.$exhibitSubtitlePayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ExhibitSubtitle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exhibitSubtitleFindFirstArgs} args - Arguments to find a ExhibitSubtitle
     * @example
     * // Get one ExhibitSubtitle
     * const exhibitSubtitle = await prisma.exhibitSubtitle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends exhibitSubtitleFindFirstArgs>(
      args?: SelectSubset<T, exhibitSubtitleFindFirstArgs<ExtArgs>>,
    ): Prisma__exhibitSubtitleClient<
      $Result.GetResult<
        Prisma.$exhibitSubtitlePayload<ExtArgs>,
        T,
        "findFirst",
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ExhibitSubtitle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exhibitSubtitleFindFirstOrThrowArgs} args - Arguments to find a ExhibitSubtitle
     * @example
     * // Get one ExhibitSubtitle
     * const exhibitSubtitle = await prisma.exhibitSubtitle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends exhibitSubtitleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, exhibitSubtitleFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__exhibitSubtitleClient<
      $Result.GetResult<
        Prisma.$exhibitSubtitlePayload<ExtArgs>,
        T,
        "findFirstOrThrow",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ExhibitSubtitles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exhibitSubtitleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExhibitSubtitles
     * const exhibitSubtitles = await prisma.exhibitSubtitle.findMany()
     *
     * // Get first 10 ExhibitSubtitles
     * const exhibitSubtitles = await prisma.exhibitSubtitle.findMany({ take: 10 })
     *
     * // Only select the `exhibitId`
     * const exhibitSubtitleWithExhibitIdOnly = await prisma.exhibitSubtitle.findMany({ select: { exhibitId: true } })
     *
     */
    findMany<T extends exhibitSubtitleFindManyArgs>(
      args?: SelectSubset<T, exhibitSubtitleFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$exhibitSubtitlePayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    >;

    /**
     * Create a ExhibitSubtitle.
     * @param {exhibitSubtitleCreateArgs} args - Arguments to create a ExhibitSubtitle.
     * @example
     * // Create one ExhibitSubtitle
     * const ExhibitSubtitle = await prisma.exhibitSubtitle.create({
     *   data: {
     *     // ... data to create a ExhibitSubtitle
     *   }
     * })
     *
     */
    create<T extends exhibitSubtitleCreateArgs>(
      args: SelectSubset<T, exhibitSubtitleCreateArgs<ExtArgs>>,
    ): Prisma__exhibitSubtitleClient<
      $Result.GetResult<
        Prisma.$exhibitSubtitlePayload<ExtArgs>,
        T,
        "create",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many ExhibitSubtitles.
     * @param {exhibitSubtitleCreateManyArgs} args - Arguments to create many ExhibitSubtitles.
     * @example
     * // Create many ExhibitSubtitles
     * const exhibitSubtitle = await prisma.exhibitSubtitle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends exhibitSubtitleCreateManyArgs>(
      args?: SelectSubset<T, exhibitSubtitleCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many ExhibitSubtitles and returns the data saved in the database.
     * @param {exhibitSubtitleCreateManyAndReturnArgs} args - Arguments to create many ExhibitSubtitles.
     * @example
     * // Create many ExhibitSubtitles
     * const exhibitSubtitle = await prisma.exhibitSubtitle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ExhibitSubtitles and only return the `exhibitId`
     * const exhibitSubtitleWithExhibitIdOnly = await prisma.exhibitSubtitle.createManyAndReturn({
     *   select: { exhibitId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends exhibitSubtitleCreateManyAndReturnArgs>(
      args?: SelectSubset<T, exhibitSubtitleCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$exhibitSubtitlePayload<ExtArgs>,
        T,
        "createManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a ExhibitSubtitle.
     * @param {exhibitSubtitleDeleteArgs} args - Arguments to delete one ExhibitSubtitle.
     * @example
     * // Delete one ExhibitSubtitle
     * const ExhibitSubtitle = await prisma.exhibitSubtitle.delete({
     *   where: {
     *     // ... filter to delete one ExhibitSubtitle
     *   }
     * })
     *
     */
    delete<T extends exhibitSubtitleDeleteArgs>(
      args: SelectSubset<T, exhibitSubtitleDeleteArgs<ExtArgs>>,
    ): Prisma__exhibitSubtitleClient<
      $Result.GetResult<
        Prisma.$exhibitSubtitlePayload<ExtArgs>,
        T,
        "delete",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one ExhibitSubtitle.
     * @param {exhibitSubtitleUpdateArgs} args - Arguments to update one ExhibitSubtitle.
     * @example
     * // Update one ExhibitSubtitle
     * const exhibitSubtitle = await prisma.exhibitSubtitle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends exhibitSubtitleUpdateArgs>(
      args: SelectSubset<T, exhibitSubtitleUpdateArgs<ExtArgs>>,
    ): Prisma__exhibitSubtitleClient<
      $Result.GetResult<
        Prisma.$exhibitSubtitlePayload<ExtArgs>,
        T,
        "update",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more ExhibitSubtitles.
     * @param {exhibitSubtitleDeleteManyArgs} args - Arguments to filter ExhibitSubtitles to delete.
     * @example
     * // Delete a few ExhibitSubtitles
     * const { count } = await prisma.exhibitSubtitle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends exhibitSubtitleDeleteManyArgs>(
      args?: SelectSubset<T, exhibitSubtitleDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ExhibitSubtitles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exhibitSubtitleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExhibitSubtitles
     * const exhibitSubtitle = await prisma.exhibitSubtitle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends exhibitSubtitleUpdateManyArgs>(
      args: SelectSubset<T, exhibitSubtitleUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ExhibitSubtitles and returns the data updated in the database.
     * @param {exhibitSubtitleUpdateManyAndReturnArgs} args - Arguments to update many ExhibitSubtitles.
     * @example
     * // Update many ExhibitSubtitles
     * const exhibitSubtitle = await prisma.exhibitSubtitle.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more ExhibitSubtitles and only return the `exhibitId`
     * const exhibitSubtitleWithExhibitIdOnly = await prisma.exhibitSubtitle.updateManyAndReturn({
     *   select: { exhibitId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends exhibitSubtitleUpdateManyAndReturnArgs>(
      args: SelectSubset<T, exhibitSubtitleUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$exhibitSubtitlePayload<ExtArgs>,
        T,
        "updateManyAndReturn",
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one ExhibitSubtitle.
     * @param {exhibitSubtitleUpsertArgs} args - Arguments to update or create a ExhibitSubtitle.
     * @example
     * // Update or create a ExhibitSubtitle
     * const exhibitSubtitle = await prisma.exhibitSubtitle.upsert({
     *   create: {
     *     // ... data to create a ExhibitSubtitle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExhibitSubtitle we want to update
     *   }
     * })
     */
    upsert<T extends exhibitSubtitleUpsertArgs>(
      args: SelectSubset<T, exhibitSubtitleUpsertArgs<ExtArgs>>,
    ): Prisma__exhibitSubtitleClient<
      $Result.GetResult<
        Prisma.$exhibitSubtitlePayload<ExtArgs>,
        T,
        "upsert",
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of ExhibitSubtitles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exhibitSubtitleCountArgs} args - Arguments to filter ExhibitSubtitles to count.
     * @example
     * // Count the number of ExhibitSubtitles
     * const count = await prisma.exhibitSubtitle.count({
     *   where: {
     *     // ... the filter for the ExhibitSubtitles we want to count
     *   }
     * })
     **/
    count<T extends exhibitSubtitleCountArgs>(
      args?: Subset<T, exhibitSubtitleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<"select", any>
        ? T["select"] extends true
          ? number
          : GetScalarType<T["select"], ExhibitSubtitleCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ExhibitSubtitle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExhibitSubtitleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ExhibitSubtitleAggregateArgs>(
      args: Subset<T, ExhibitSubtitleAggregateArgs>,
    ): Prisma.PrismaPromise<GetExhibitSubtitleAggregateType<T>>;

    /**
     * Group by ExhibitSubtitle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exhibitSubtitleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends exhibitSubtitleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<"skip", Keys<T>>,
        Extends<"take", Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: exhibitSubtitleGroupByArgs["orderBy"] }
        : { orderBy?: exhibitSubtitleGroupByArgs["orderBy"] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T["orderBy"]>>
      >,
      ByFields extends MaybeTupleToUnion<T["by"]>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T["having"]>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T["by"] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      "Field ",
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : "take" extends Keys<T>
            ? "orderBy" extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : "skip" extends Keys<T>
              ? "orderBy" extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, exhibitSubtitleGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetExhibitSubtitleGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the exhibitSubtitle model
     */
    readonly fields: exhibitSubtitleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for exhibitSubtitle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__exhibitSubtitleClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise";
    exhibit<T extends exhibitDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, exhibitDefaultArgs<ExtArgs>>,
    ): Prisma__exhibitClient<
      | $Result.GetResult<
          Prisma.$exhibitPayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    subtitle<T extends subtitleDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, subtitleDefaultArgs<ExtArgs>>,
    ): Prisma__subtitleClient<
      | $Result.GetResult<
          Prisma.$subtitlePayload<ExtArgs>,
          T,
          "findUniqueOrThrow",
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the exhibitSubtitle model
   */
  interface exhibitSubtitleFieldRefs {
    readonly exhibitId: FieldRef<"exhibitSubtitle", "String">;
    readonly subtitleId: FieldRef<"exhibitSubtitle", "String">;
    readonly createdAt: FieldRef<"exhibitSubtitle", "DateTime">;
  }

  // Custom InputTypes
  /**
   * exhibitSubtitle findUnique
   */
  export type exhibitSubtitleFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the exhibitSubtitle
     */
    select?: exhibitSubtitleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the exhibitSubtitle
     */
    omit?: exhibitSubtitleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exhibitSubtitleInclude<ExtArgs> | null;
    /**
     * Filter, which exhibitSubtitle to fetch.
     */
    where: exhibitSubtitleWhereUniqueInput;
  };

  /**
   * exhibitSubtitle findUniqueOrThrow
   */
  export type exhibitSubtitleFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the exhibitSubtitle
     */
    select?: exhibitSubtitleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the exhibitSubtitle
     */
    omit?: exhibitSubtitleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exhibitSubtitleInclude<ExtArgs> | null;
    /**
     * Filter, which exhibitSubtitle to fetch.
     */
    where: exhibitSubtitleWhereUniqueInput;
  };

  /**
   * exhibitSubtitle findFirst
   */
  export type exhibitSubtitleFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the exhibitSubtitle
     */
    select?: exhibitSubtitleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the exhibitSubtitle
     */
    omit?: exhibitSubtitleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exhibitSubtitleInclude<ExtArgs> | null;
    /**
     * Filter, which exhibitSubtitle to fetch.
     */
    where?: exhibitSubtitleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of exhibitSubtitles to fetch.
     */
    orderBy?:
      | exhibitSubtitleOrderByWithRelationInput
      | exhibitSubtitleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for exhibitSubtitles.
     */
    cursor?: exhibitSubtitleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` exhibitSubtitles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` exhibitSubtitles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of exhibitSubtitles.
     */
    distinct?:
      | ExhibitSubtitleScalarFieldEnum
      | ExhibitSubtitleScalarFieldEnum[];
  };

  /**
   * exhibitSubtitle findFirstOrThrow
   */
  export type exhibitSubtitleFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the exhibitSubtitle
     */
    select?: exhibitSubtitleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the exhibitSubtitle
     */
    omit?: exhibitSubtitleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exhibitSubtitleInclude<ExtArgs> | null;
    /**
     * Filter, which exhibitSubtitle to fetch.
     */
    where?: exhibitSubtitleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of exhibitSubtitles to fetch.
     */
    orderBy?:
      | exhibitSubtitleOrderByWithRelationInput
      | exhibitSubtitleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for exhibitSubtitles.
     */
    cursor?: exhibitSubtitleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` exhibitSubtitles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` exhibitSubtitles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of exhibitSubtitles.
     */
    distinct?:
      | ExhibitSubtitleScalarFieldEnum
      | ExhibitSubtitleScalarFieldEnum[];
  };

  /**
   * exhibitSubtitle findMany
   */
  export type exhibitSubtitleFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the exhibitSubtitle
     */
    select?: exhibitSubtitleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the exhibitSubtitle
     */
    omit?: exhibitSubtitleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exhibitSubtitleInclude<ExtArgs> | null;
    /**
     * Filter, which exhibitSubtitles to fetch.
     */
    where?: exhibitSubtitleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of exhibitSubtitles to fetch.
     */
    orderBy?:
      | exhibitSubtitleOrderByWithRelationInput
      | exhibitSubtitleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing exhibitSubtitles.
     */
    cursor?: exhibitSubtitleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` exhibitSubtitles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` exhibitSubtitles.
     */
    skip?: number;
    distinct?:
      | ExhibitSubtitleScalarFieldEnum
      | ExhibitSubtitleScalarFieldEnum[];
  };

  /**
   * exhibitSubtitle create
   */
  export type exhibitSubtitleCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the exhibitSubtitle
     */
    select?: exhibitSubtitleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the exhibitSubtitle
     */
    omit?: exhibitSubtitleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exhibitSubtitleInclude<ExtArgs> | null;
    /**
     * The data needed to create a exhibitSubtitle.
     */
    data: XOR<exhibitSubtitleCreateInput, exhibitSubtitleUncheckedCreateInput>;
  };

  /**
   * exhibitSubtitle createMany
   */
  export type exhibitSubtitleCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many exhibitSubtitles.
     */
    data: exhibitSubtitleCreateManyInput | exhibitSubtitleCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * exhibitSubtitle createManyAndReturn
   */
  export type exhibitSubtitleCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the exhibitSubtitle
     */
    select?: exhibitSubtitleSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the exhibitSubtitle
     */
    omit?: exhibitSubtitleOmit<ExtArgs> | null;
    /**
     * The data used to create many exhibitSubtitles.
     */
    data: exhibitSubtitleCreateManyInput | exhibitSubtitleCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exhibitSubtitleIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * exhibitSubtitle update
   */
  export type exhibitSubtitleUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the exhibitSubtitle
     */
    select?: exhibitSubtitleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the exhibitSubtitle
     */
    omit?: exhibitSubtitleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exhibitSubtitleInclude<ExtArgs> | null;
    /**
     * The data needed to update a exhibitSubtitle.
     */
    data: XOR<exhibitSubtitleUpdateInput, exhibitSubtitleUncheckedUpdateInput>;
    /**
     * Choose, which exhibitSubtitle to update.
     */
    where: exhibitSubtitleWhereUniqueInput;
  };

  /**
   * exhibitSubtitle updateMany
   */
  export type exhibitSubtitleUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update exhibitSubtitles.
     */
    data: XOR<
      exhibitSubtitleUpdateManyMutationInput,
      exhibitSubtitleUncheckedUpdateManyInput
    >;
    /**
     * Filter which exhibitSubtitles to update
     */
    where?: exhibitSubtitleWhereInput;
    /**
     * Limit how many exhibitSubtitles to update.
     */
    limit?: number;
  };

  /**
   * exhibitSubtitle updateManyAndReturn
   */
  export type exhibitSubtitleUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the exhibitSubtitle
     */
    select?: exhibitSubtitleSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the exhibitSubtitle
     */
    omit?: exhibitSubtitleOmit<ExtArgs> | null;
    /**
     * The data used to update exhibitSubtitles.
     */
    data: XOR<
      exhibitSubtitleUpdateManyMutationInput,
      exhibitSubtitleUncheckedUpdateManyInput
    >;
    /**
     * Filter which exhibitSubtitles to update
     */
    where?: exhibitSubtitleWhereInput;
    /**
     * Limit how many exhibitSubtitles to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exhibitSubtitleIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * exhibitSubtitle upsert
   */
  export type exhibitSubtitleUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the exhibitSubtitle
     */
    select?: exhibitSubtitleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the exhibitSubtitle
     */
    omit?: exhibitSubtitleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exhibitSubtitleInclude<ExtArgs> | null;
    /**
     * The filter to search for the exhibitSubtitle to update in case it exists.
     */
    where: exhibitSubtitleWhereUniqueInput;
    /**
     * In case the exhibitSubtitle found by the `where` argument doesn't exist, create a new exhibitSubtitle with this data.
     */
    create: XOR<
      exhibitSubtitleCreateInput,
      exhibitSubtitleUncheckedCreateInput
    >;
    /**
     * In case the exhibitSubtitle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      exhibitSubtitleUpdateInput,
      exhibitSubtitleUncheckedUpdateInput
    >;
  };

  /**
   * exhibitSubtitle delete
   */
  export type exhibitSubtitleDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the exhibitSubtitle
     */
    select?: exhibitSubtitleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the exhibitSubtitle
     */
    omit?: exhibitSubtitleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exhibitSubtitleInclude<ExtArgs> | null;
    /**
     * Filter which exhibitSubtitle to delete.
     */
    where: exhibitSubtitleWhereUniqueInput;
  };

  /**
   * exhibitSubtitle deleteMany
   */
  export type exhibitSubtitleDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which exhibitSubtitles to delete
     */
    where?: exhibitSubtitleWhereInput;
    /**
     * Limit how many exhibitSubtitles to delete.
     */
    limit?: number;
  };

  /**
   * exhibitSubtitle without action
   */
  export type exhibitSubtitleDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the exhibitSubtitle
     */
    select?: exhibitSubtitleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the exhibitSubtitle
     */
    omit?: exhibitSubtitleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exhibitSubtitleInclude<ExtArgs> | null;
  };

  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: "ReadUncommitted";
    ReadCommitted: "ReadCommitted";
    RepeatableRead: "RepeatableRead";
    Serializable: "Serializable";
  };

  export type TransactionIsolationLevel =
    (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel];

  export const UsersScalarFieldEnum: {
    userId: "userId";
    username: "username";
    password: "password";
    createdAt: "createdAt";
    modifiedAt: "modifiedAt";
    statusCode: "statusCode";
  };

  export type UsersScalarFieldEnum =
    (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum];

  export const StatusScalarFieldEnum: {
    statusCode: "statusCode";
    description: "description";
  };

  export type StatusScalarFieldEnum =
    (typeof StatusScalarFieldEnum)[keyof typeof StatusScalarFieldEnum];

  export const AudioScalarFieldEnum: {
    audioId: "audioId";
    fileUrl: "fileUrl";
    description: "description";
    createdBy: "createdBy";
    languageId: "languageId";
    createdAt: "createdAt";
    statusCode: "statusCode";
  };

  export type AudioScalarFieldEnum =
    (typeof AudioScalarFieldEnum)[keyof typeof AudioScalarFieldEnum];

  export const ExhibitAudioRelationScalarFieldEnum: {
    audioId: "audioId";
    exhibitId: "exhibitId";
  };

  export type ExhibitAudioRelationScalarFieldEnum =
    (typeof ExhibitAudioRelationScalarFieldEnum)[keyof typeof ExhibitAudioRelationScalarFieldEnum];

  export const ExhibitScalarFieldEnum: {
    exhibitId: "exhibitId";
    title: "title";
    description: "description";
    audioId: "audioId";
    createdBy: "createdBy";
    modifiedBy: "modifiedBy";
    qrCodeId: "qrCodeId";
    imageId: "imageId";
    createdAt: "createdAt";
    modifiedAt: "modifiedAt";
    statusCode: "statusCode";
  };

  export type ExhibitScalarFieldEnum =
    (typeof ExhibitScalarFieldEnum)[keyof typeof ExhibitScalarFieldEnum];

  export const AuditLogScalarFieldEnum: {
    auditLogId: "auditLogId";
    userId: "userId";
    ipAddress: "ipAddress";
    entityName: "entityName";
    entityId: "entityId";
    actionType: "actionType";
    oldValue: "oldValue";
    newValue: "newValue";
    timestamp: "timestamp";
    statusCode: "statusCode";
  };

  export type AuditLogScalarFieldEnum =
    (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum];

  export const PhoneNumberScalarFieldEnum: {
    phoneNumberId: "phoneNumberId";
    userId: "userId";
    phoneNumber: "phoneNumber";
    verified: "verified";
    isPrimary: "isPrimary";
    createdAt: "createdAt";
    statusCode: "statusCode";
  };

  export type PhoneNumberScalarFieldEnum =
    (typeof PhoneNumberScalarFieldEnum)[keyof typeof PhoneNumberScalarFieldEnum];

  export const EmailScalarFieldEnum: {
    emailId: "emailId";
    userId: "userId";
    email: "email";
    verified: "verified";
    isPrimary: "isPrimary";
    createdAt: "createdAt";
    statusCode: "statusCode";
  };

  export type EmailScalarFieldEnum =
    (typeof EmailScalarFieldEnum)[keyof typeof EmailScalarFieldEnum];

  export const UserRoleScalarFieldEnum: {
    userId: "userId";
    roleId: "roleId";
  };

  export type UserRoleScalarFieldEnum =
    (typeof UserRoleScalarFieldEnum)[keyof typeof UserRoleScalarFieldEnum];

  export const RoleScalarFieldEnum: {
    roleId: "roleId";
    roleName: "roleName";
    description: "description";
    statusCode: "statusCode";
  };

  export type RoleScalarFieldEnum =
    (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum];

  export const QrCodeScalarFieldEnum: {
    qrCodeId: "qrCodeId";
    qrLink: "qrLink";
    createdBy: "createdBy";
    createdAt: "createdAt";
    statusCode: "statusCode";
  };

  export type QrCodeScalarFieldEnum =
    (typeof QrCodeScalarFieldEnum)[keyof typeof QrCodeScalarFieldEnum];

  export const ImageScalarFieldEnum: {
    imageId: "imageId";
    description: "description";
    createdBy: "createdBy";
    createdAt: "createdAt";
    statusCode: "statusCode";
  };

  export type ImageScalarFieldEnum =
    (typeof ImageScalarFieldEnum)[keyof typeof ImageScalarFieldEnum];

  export const EventScalarFieldEnum: {
    eventId: "eventId";
    sessionId: "sessionId";
    entityId: "entityId";
    entityName: "entityName";
    timestamp: "timestamp";
    usersUserId: "usersUserId";
  };

  export type EventScalarFieldEnum =
    (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum];

  export const SessionScalarFieldEnum: {
    sessionId: "sessionId";
    userId: "userId";
    deviceInfo: "deviceInfo";
    isActive: "isActive";
    createdAt: "createdAt";
  };

  export type SessionScalarFieldEnum =
    (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum];

  export const UserProfileScalarFieldEnum: {
    userProfileId: "userProfileId";
    userId: "userId";
    fName: "fName";
    lName: "lName";
    languageCode: "languageCode";
    gender: "gender";
    dob: "dob";
    modifiedBy: "modifiedBy";
    createdBy: "createdBy";
    createdAt: "createdAt";
    modifiedAt: "modifiedAt";
    statusCode: "statusCode";
  };

  export type UserProfileScalarFieldEnum =
    (typeof UserProfileScalarFieldEnum)[keyof typeof UserProfileScalarFieldEnum];

  export const LanguageScalarFieldEnum: {
    languageCode: "languageCode";
    languageName: "languageName";
    statusCode: "statusCode";
  };

  export type LanguageScalarFieldEnum =
    (typeof LanguageScalarFieldEnum)[keyof typeof LanguageScalarFieldEnum];

  export const SubtitleScalarFieldEnum: {
    subtitleId: "subtitleId";
    subtitleText: "subtitleText";
    languageCode: "languageCode";
    createdBy: "createdBy";
    modifiedBy: "modifiedBy";
    createdAt: "createdAt";
    modifiedAt: "modifiedAt";
    statusCode: "statusCode";
  };

  export type SubtitleScalarFieldEnum =
    (typeof SubtitleScalarFieldEnum)[keyof typeof SubtitleScalarFieldEnum];

  export const ExhibitSubtitleScalarFieldEnum: {
    exhibitId: "exhibitId";
    subtitleId: "subtitleId";
    createdAt: "createdAt";
  };

  export type ExhibitSubtitleScalarFieldEnum =
    (typeof ExhibitSubtitleScalarFieldEnum)[keyof typeof ExhibitSubtitleScalarFieldEnum];

  export const SortOrder: {
    asc: "asc";
    desc: "desc";
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder];

  export const QueryMode: {
    default: "default";
    insensitive: "insensitive";
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode];

  export const NullsOrder: {
    first: "first";
    last: "last";
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder];

  /**
   * Field references
   */

  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "String"
  >;

  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "String[]"
  >;

  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "DateTime"
  >;

  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "DateTime[]"
  >;

  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Boolean"
  >;

  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Int"
  >;

  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Int[]"
  >;

  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Float"
  >;

  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    "Float[]"
  >;

  /**
   * Deep Input Types
   */

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[];
    OR?: usersWhereInput[];
    NOT?: usersWhereInput | usersWhereInput[];
    userId?: UuidFilter<"users"> | string;
    username?: StringFilter<"users"> | string;
    password?: StringFilter<"users"> | string;
    createdAt?: DateTimeFilter<"users"> | Date | string;
    modifiedAt?: DateTimeFilter<"users"> | Date | string;
    statusCode?: StringFilter<"users"> | string;
    phoneNumbers?: PhoneNumberListRelationFilter;
    emails?: EmailListRelationFilter;
    userProfile?: XOR<
      UserProfileNullableScalarRelationFilter,
      userProfileWhereInput
    > | null;
    sessions?: SessionListRelationFilter;
    auditLogs?: AuditLogListRelationFilter;
    events?: EventListRelationFilter;
    userRoles?: UserRoleListRelationFilter;
    status?: XOR<StatusScalarRelationFilter, statusWhereInput>;
  };

  export type usersOrderByWithRelationInput = {
    userId?: SortOrder;
    username?: SortOrder;
    password?: SortOrder;
    createdAt?: SortOrder;
    modifiedAt?: SortOrder;
    statusCode?: SortOrder;
    phoneNumbers?: phoneNumberOrderByRelationAggregateInput;
    emails?: emailOrderByRelationAggregateInput;
    userProfile?: userProfileOrderByWithRelationInput;
    sessions?: sessionOrderByRelationAggregateInput;
    auditLogs?: auditLogOrderByRelationAggregateInput;
    events?: eventOrderByRelationAggregateInput;
    userRoles?: userRoleOrderByRelationAggregateInput;
    status?: statusOrderByWithRelationInput;
  };

  export type usersWhereUniqueInput = Prisma.AtLeast<
    {
      userId?: string;
      AND?: usersWhereInput | usersWhereInput[];
      OR?: usersWhereInput[];
      NOT?: usersWhereInput | usersWhereInput[];
      username?: StringFilter<"users"> | string;
      password?: StringFilter<"users"> | string;
      createdAt?: DateTimeFilter<"users"> | Date | string;
      modifiedAt?: DateTimeFilter<"users"> | Date | string;
      statusCode?: StringFilter<"users"> | string;
      phoneNumbers?: PhoneNumberListRelationFilter;
      emails?: EmailListRelationFilter;
      userProfile?: XOR<
        UserProfileNullableScalarRelationFilter,
        userProfileWhereInput
      > | null;
      sessions?: SessionListRelationFilter;
      auditLogs?: AuditLogListRelationFilter;
      events?: EventListRelationFilter;
      userRoles?: UserRoleListRelationFilter;
      status?: XOR<StatusScalarRelationFilter, statusWhereInput>;
    },
    "userId"
  >;

  export type usersOrderByWithAggregationInput = {
    userId?: SortOrder;
    username?: SortOrder;
    password?: SortOrder;
    createdAt?: SortOrder;
    modifiedAt?: SortOrder;
    statusCode?: SortOrder;
    _count?: usersCountOrderByAggregateInput;
    _max?: usersMaxOrderByAggregateInput;
    _min?: usersMinOrderByAggregateInput;
  };

  export type usersScalarWhereWithAggregatesInput = {
    AND?:
      | usersScalarWhereWithAggregatesInput
      | usersScalarWhereWithAggregatesInput[];
    OR?: usersScalarWhereWithAggregatesInput[];
    NOT?:
      | usersScalarWhereWithAggregatesInput
      | usersScalarWhereWithAggregatesInput[];
    userId?: UuidWithAggregatesFilter<"users"> | string;
    username?: StringWithAggregatesFilter<"users"> | string;
    password?: StringWithAggregatesFilter<"users"> | string;
    createdAt?: DateTimeWithAggregatesFilter<"users"> | Date | string;
    modifiedAt?: DateTimeWithAggregatesFilter<"users"> | Date | string;
    statusCode?: StringWithAggregatesFilter<"users"> | string;
  };

  export type statusWhereInput = {
    AND?: statusWhereInput | statusWhereInput[];
    OR?: statusWhereInput[];
    NOT?: statusWhereInput | statusWhereInput[];
    statusCode?: StringFilter<"status"> | string;
    description?: StringFilter<"status"> | string;
    users?: UsersListRelationFilter;
    audios?: AudioListRelationFilter;
    exhibits?: ExhibitListRelationFilter;
    phoneNumbers?: PhoneNumberListRelationFilter;
    emails?: EmailListRelationFilter;
    roles?: RoleListRelationFilter;
    qrcodes?: QrCodeListRelationFilter;
    images?: ImageListRelationFilter;
    subtitles?: SubtitleListRelationFilter;
    languages?: LanguageListRelationFilter;
    auditLogs?: AuditLogListRelationFilter;
    userProfiles?: UserProfileListRelationFilter;
  };

  export type statusOrderByWithRelationInput = {
    statusCode?: SortOrder;
    description?: SortOrder;
    users?: usersOrderByRelationAggregateInput;
    audios?: audioOrderByRelationAggregateInput;
    exhibits?: exhibitOrderByRelationAggregateInput;
    phoneNumbers?: phoneNumberOrderByRelationAggregateInput;
    emails?: emailOrderByRelationAggregateInput;
    roles?: roleOrderByRelationAggregateInput;
    qrcodes?: qrCodeOrderByRelationAggregateInput;
    images?: imageOrderByRelationAggregateInput;
    subtitles?: subtitleOrderByRelationAggregateInput;
    languages?: languageOrderByRelationAggregateInput;
    auditLogs?: auditLogOrderByRelationAggregateInput;
    userProfiles?: userProfileOrderByRelationAggregateInput;
  };

  export type statusWhereUniqueInput = Prisma.AtLeast<
    {
      statusCode?: string;
      AND?: statusWhereInput | statusWhereInput[];
      OR?: statusWhereInput[];
      NOT?: statusWhereInput | statusWhereInput[];
      description?: StringFilter<"status"> | string;
      users?: UsersListRelationFilter;
      audios?: AudioListRelationFilter;
      exhibits?: ExhibitListRelationFilter;
      phoneNumbers?: PhoneNumberListRelationFilter;
      emails?: EmailListRelationFilter;
      roles?: RoleListRelationFilter;
      qrcodes?: QrCodeListRelationFilter;
      images?: ImageListRelationFilter;
      subtitles?: SubtitleListRelationFilter;
      languages?: LanguageListRelationFilter;
      auditLogs?: AuditLogListRelationFilter;
      userProfiles?: UserProfileListRelationFilter;
    },
    "statusCode"
  >;

  export type statusOrderByWithAggregationInput = {
    statusCode?: SortOrder;
    description?: SortOrder;
    _count?: statusCountOrderByAggregateInput;
    _max?: statusMaxOrderByAggregateInput;
    _min?: statusMinOrderByAggregateInput;
  };

  export type statusScalarWhereWithAggregatesInput = {
    AND?:
      | statusScalarWhereWithAggregatesInput
      | statusScalarWhereWithAggregatesInput[];
    OR?: statusScalarWhereWithAggregatesInput[];
    NOT?:
      | statusScalarWhereWithAggregatesInput
      | statusScalarWhereWithAggregatesInput[];
    statusCode?: StringWithAggregatesFilter<"status"> | string;
    description?: StringWithAggregatesFilter<"status"> | string;
  };

  export type audioWhereInput = {
    AND?: audioWhereInput | audioWhereInput[];
    OR?: audioWhereInput[];
    NOT?: audioWhereInput | audioWhereInput[];
    audioId?: UuidFilter<"audio"> | string;
    fileUrl?: StringFilter<"audio"> | string;
    description?: StringFilter<"audio"> | string;
    createdBy?: UuidFilter<"audio"> | string;
    languageId?: StringFilter<"audio"> | string;
    createdAt?: DateTimeFilter<"audio"> | Date | string;
    statusCode?: StringFilter<"audio"> | string;
    language?: XOR<LanguageScalarRelationFilter, languageWhereInput>;
    status?: XOR<StatusScalarRelationFilter, statusWhereInput>;
    exhibits?: ExhibitAudioRelationListRelationFilter;
    exhibit?: ExhibitListRelationFilter;
  };

  export type audioOrderByWithRelationInput = {
    audioId?: SortOrder;
    fileUrl?: SortOrder;
    description?: SortOrder;
    createdBy?: SortOrder;
    languageId?: SortOrder;
    createdAt?: SortOrder;
    statusCode?: SortOrder;
    language?: languageOrderByWithRelationInput;
    status?: statusOrderByWithRelationInput;
    exhibits?: exhibitAudioRelationOrderByRelationAggregateInput;
    exhibit?: exhibitOrderByRelationAggregateInput;
  };

  export type audioWhereUniqueInput = Prisma.AtLeast<
    {
      audioId?: string;
      AND?: audioWhereInput | audioWhereInput[];
      OR?: audioWhereInput[];
      NOT?: audioWhereInput | audioWhereInput[];
      fileUrl?: StringFilter<"audio"> | string;
      description?: StringFilter<"audio"> | string;
      createdBy?: UuidFilter<"audio"> | string;
      languageId?: StringFilter<"audio"> | string;
      createdAt?: DateTimeFilter<"audio"> | Date | string;
      statusCode?: StringFilter<"audio"> | string;
      language?: XOR<LanguageScalarRelationFilter, languageWhereInput>;
      status?: XOR<StatusScalarRelationFilter, statusWhereInput>;
      exhibits?: ExhibitAudioRelationListRelationFilter;
      exhibit?: ExhibitListRelationFilter;
    },
    "audioId"
  >;

  export type audioOrderByWithAggregationInput = {
    audioId?: SortOrder;
    fileUrl?: SortOrder;
    description?: SortOrder;
    createdBy?: SortOrder;
    languageId?: SortOrder;
    createdAt?: SortOrder;
    statusCode?: SortOrder;
    _count?: audioCountOrderByAggregateInput;
    _max?: audioMaxOrderByAggregateInput;
    _min?: audioMinOrderByAggregateInput;
  };

  export type audioScalarWhereWithAggregatesInput = {
    AND?:
      | audioScalarWhereWithAggregatesInput
      | audioScalarWhereWithAggregatesInput[];
    OR?: audioScalarWhereWithAggregatesInput[];
    NOT?:
      | audioScalarWhereWithAggregatesInput
      | audioScalarWhereWithAggregatesInput[];
    audioId?: UuidWithAggregatesFilter<"audio"> | string;
    fileUrl?: StringWithAggregatesFilter<"audio"> | string;
    description?: StringWithAggregatesFilter<"audio"> | string;
    createdBy?: UuidWithAggregatesFilter<"audio"> | string;
    languageId?: StringWithAggregatesFilter<"audio"> | string;
    createdAt?: DateTimeWithAggregatesFilter<"audio"> | Date | string;
    statusCode?: StringWithAggregatesFilter<"audio"> | string;
  };

  export type exhibitAudioRelationWhereInput = {
    AND?: exhibitAudioRelationWhereInput | exhibitAudioRelationWhereInput[];
    OR?: exhibitAudioRelationWhereInput[];
    NOT?: exhibitAudioRelationWhereInput | exhibitAudioRelationWhereInput[];
    audioId?: UuidFilter<"exhibitAudioRelation"> | string;
    exhibitId?: UuidFilter<"exhibitAudioRelation"> | string;
    audio?: XOR<AudioScalarRelationFilter, audioWhereInput>;
    exhibit?: XOR<ExhibitScalarRelationFilter, exhibitWhereInput>;
  };

  export type exhibitAudioRelationOrderByWithRelationInput = {
    audioId?: SortOrder;
    exhibitId?: SortOrder;
    audio?: audioOrderByWithRelationInput;
    exhibit?: exhibitOrderByWithRelationInput;
  };

  export type exhibitAudioRelationWhereUniqueInput = Prisma.AtLeast<
    {
      audioId_exhibitId?: exhibitAudioRelationAudioIdExhibitIdCompoundUniqueInput;
      AND?: exhibitAudioRelationWhereInput | exhibitAudioRelationWhereInput[];
      OR?: exhibitAudioRelationWhereInput[];
      NOT?: exhibitAudioRelationWhereInput | exhibitAudioRelationWhereInput[];
      audioId?: UuidFilter<"exhibitAudioRelation"> | string;
      exhibitId?: UuidFilter<"exhibitAudioRelation"> | string;
      audio?: XOR<AudioScalarRelationFilter, audioWhereInput>;
      exhibit?: XOR<ExhibitScalarRelationFilter, exhibitWhereInput>;
    },
    "audioId_exhibitId"
  >;

  export type exhibitAudioRelationOrderByWithAggregationInput = {
    audioId?: SortOrder;
    exhibitId?: SortOrder;
    _count?: exhibitAudioRelationCountOrderByAggregateInput;
    _max?: exhibitAudioRelationMaxOrderByAggregateInput;
    _min?: exhibitAudioRelationMinOrderByAggregateInput;
  };

  export type exhibitAudioRelationScalarWhereWithAggregatesInput = {
    AND?:
      | exhibitAudioRelationScalarWhereWithAggregatesInput
      | exhibitAudioRelationScalarWhereWithAggregatesInput[];
    OR?: exhibitAudioRelationScalarWhereWithAggregatesInput[];
    NOT?:
      | exhibitAudioRelationScalarWhereWithAggregatesInput
      | exhibitAudioRelationScalarWhereWithAggregatesInput[];
    audioId?: UuidWithAggregatesFilter<"exhibitAudioRelation"> | string;
    exhibitId?: UuidWithAggregatesFilter<"exhibitAudioRelation"> | string;
  };

  export type exhibitWhereInput = {
    AND?: exhibitWhereInput | exhibitWhereInput[];
    OR?: exhibitWhereInput[];
    NOT?: exhibitWhereInput | exhibitWhereInput[];
    exhibitId?: UuidFilter<"exhibit"> | string;
    title?: StringFilter<"exhibit"> | string;
    description?: StringFilter<"exhibit"> | string;
    audioId?: UuidFilter<"exhibit"> | string;
    createdBy?: UuidFilter<"exhibit"> | string;
    modifiedBy?: UuidFilter<"exhibit"> | string;
    qrCodeId?: UuidFilter<"exhibit"> | string;
    imageId?: UuidFilter<"exhibit"> | string;
    createdAt?: DateTimeFilter<"exhibit"> | Date | string;
    modifiedAt?: DateTimeFilter<"exhibit"> | Date | string;
    statusCode?: StringFilter<"exhibit"> | string;
    audio?: XOR<AudioScalarRelationFilter, audioWhereInput>;
    qrCode?: XOR<QrCodeScalarRelationFilter, qrCodeWhereInput>;
    image?: XOR<ImageScalarRelationFilter, imageWhereInput>;
    subtitles?: ExhibitSubtitleListRelationFilter;
    status?: XOR<StatusScalarRelationFilter, statusWhereInput>;
    exhibitAudioRelation?: ExhibitAudioRelationListRelationFilter;
  };

  export type exhibitOrderByWithRelationInput = {
    exhibitId?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    audioId?: SortOrder;
    createdBy?: SortOrder;
    modifiedBy?: SortOrder;
    qrCodeId?: SortOrder;
    imageId?: SortOrder;
    createdAt?: SortOrder;
    modifiedAt?: SortOrder;
    statusCode?: SortOrder;
    audio?: audioOrderByWithRelationInput;
    qrCode?: qrCodeOrderByWithRelationInput;
    image?: imageOrderByWithRelationInput;
    subtitles?: exhibitSubtitleOrderByRelationAggregateInput;
    status?: statusOrderByWithRelationInput;
    exhibitAudioRelation?: exhibitAudioRelationOrderByRelationAggregateInput;
  };

  export type exhibitWhereUniqueInput = Prisma.AtLeast<
    {
      exhibitId?: string;
      AND?: exhibitWhereInput | exhibitWhereInput[];
      OR?: exhibitWhereInput[];
      NOT?: exhibitWhereInput | exhibitWhereInput[];
      title?: StringFilter<"exhibit"> | string;
      description?: StringFilter<"exhibit"> | string;
      audioId?: UuidFilter<"exhibit"> | string;
      createdBy?: UuidFilter<"exhibit"> | string;
      modifiedBy?: UuidFilter<"exhibit"> | string;
      qrCodeId?: UuidFilter<"exhibit"> | string;
      imageId?: UuidFilter<"exhibit"> | string;
      createdAt?: DateTimeFilter<"exhibit"> | Date | string;
      modifiedAt?: DateTimeFilter<"exhibit"> | Date | string;
      statusCode?: StringFilter<"exhibit"> | string;
      audio?: XOR<AudioScalarRelationFilter, audioWhereInput>;
      qrCode?: XOR<QrCodeScalarRelationFilter, qrCodeWhereInput>;
      image?: XOR<ImageScalarRelationFilter, imageWhereInput>;
      subtitles?: ExhibitSubtitleListRelationFilter;
      status?: XOR<StatusScalarRelationFilter, statusWhereInput>;
      exhibitAudioRelation?: ExhibitAudioRelationListRelationFilter;
    },
    "exhibitId"
  >;

  export type exhibitOrderByWithAggregationInput = {
    exhibitId?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    audioId?: SortOrder;
    createdBy?: SortOrder;
    modifiedBy?: SortOrder;
    qrCodeId?: SortOrder;
    imageId?: SortOrder;
    createdAt?: SortOrder;
    modifiedAt?: SortOrder;
    statusCode?: SortOrder;
    _count?: exhibitCountOrderByAggregateInput;
    _max?: exhibitMaxOrderByAggregateInput;
    _min?: exhibitMinOrderByAggregateInput;
  };

  export type exhibitScalarWhereWithAggregatesInput = {
    AND?:
      | exhibitScalarWhereWithAggregatesInput
      | exhibitScalarWhereWithAggregatesInput[];
    OR?: exhibitScalarWhereWithAggregatesInput[];
    NOT?:
      | exhibitScalarWhereWithAggregatesInput
      | exhibitScalarWhereWithAggregatesInput[];
    exhibitId?: UuidWithAggregatesFilter<"exhibit"> | string;
    title?: StringWithAggregatesFilter<"exhibit"> | string;
    description?: StringWithAggregatesFilter<"exhibit"> | string;
    audioId?: UuidWithAggregatesFilter<"exhibit"> | string;
    createdBy?: UuidWithAggregatesFilter<"exhibit"> | string;
    modifiedBy?: UuidWithAggregatesFilter<"exhibit"> | string;
    qrCodeId?: UuidWithAggregatesFilter<"exhibit"> | string;
    imageId?: UuidWithAggregatesFilter<"exhibit"> | string;
    createdAt?: DateTimeWithAggregatesFilter<"exhibit"> | Date | string;
    modifiedAt?: DateTimeWithAggregatesFilter<"exhibit"> | Date | string;
    statusCode?: StringWithAggregatesFilter<"exhibit"> | string;
  };

  export type auditLogWhereInput = {
    AND?: auditLogWhereInput | auditLogWhereInput[];
    OR?: auditLogWhereInput[];
    NOT?: auditLogWhereInput | auditLogWhereInput[];
    auditLogId?: UuidFilter<"auditLog"> | string;
    userId?: UuidFilter<"auditLog"> | string;
    ipAddress?: StringFilter<"auditLog"> | string;
    entityName?: StringFilter<"auditLog"> | string;
    entityId?: StringFilter<"auditLog"> | string;
    actionType?: StringFilter<"auditLog"> | string;
    oldValue?: StringFilter<"auditLog"> | string;
    newValue?: StringFilter<"auditLog"> | string;
    timestamp?: DateTimeFilter<"auditLog"> | Date | string;
    statusCode?: StringFilter<"auditLog"> | string;
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>;
    status?: XOR<StatusScalarRelationFilter, statusWhereInput>;
  };

  export type auditLogOrderByWithRelationInput = {
    auditLogId?: SortOrder;
    userId?: SortOrder;
    ipAddress?: SortOrder;
    entityName?: SortOrder;
    entityId?: SortOrder;
    actionType?: SortOrder;
    oldValue?: SortOrder;
    newValue?: SortOrder;
    timestamp?: SortOrder;
    statusCode?: SortOrder;
    user?: usersOrderByWithRelationInput;
    status?: statusOrderByWithRelationInput;
  };

  export type auditLogWhereUniqueInput = Prisma.AtLeast<
    {
      auditLogId?: string;
      AND?: auditLogWhereInput | auditLogWhereInput[];
      OR?: auditLogWhereInput[];
      NOT?: auditLogWhereInput | auditLogWhereInput[];
      userId?: UuidFilter<"auditLog"> | string;
      ipAddress?: StringFilter<"auditLog"> | string;
      entityName?: StringFilter<"auditLog"> | string;
      entityId?: StringFilter<"auditLog"> | string;
      actionType?: StringFilter<"auditLog"> | string;
      oldValue?: StringFilter<"auditLog"> | string;
      newValue?: StringFilter<"auditLog"> | string;
      timestamp?: DateTimeFilter<"auditLog"> | Date | string;
      statusCode?: StringFilter<"auditLog"> | string;
      user?: XOR<UsersScalarRelationFilter, usersWhereInput>;
      status?: XOR<StatusScalarRelationFilter, statusWhereInput>;
    },
    "auditLogId"
  >;

  export type auditLogOrderByWithAggregationInput = {
    auditLogId?: SortOrder;
    userId?: SortOrder;
    ipAddress?: SortOrder;
    entityName?: SortOrder;
    entityId?: SortOrder;
    actionType?: SortOrder;
    oldValue?: SortOrder;
    newValue?: SortOrder;
    timestamp?: SortOrder;
    statusCode?: SortOrder;
    _count?: auditLogCountOrderByAggregateInput;
    _max?: auditLogMaxOrderByAggregateInput;
    _min?: auditLogMinOrderByAggregateInput;
  };

  export type auditLogScalarWhereWithAggregatesInput = {
    AND?:
      | auditLogScalarWhereWithAggregatesInput
      | auditLogScalarWhereWithAggregatesInput[];
    OR?: auditLogScalarWhereWithAggregatesInput[];
    NOT?:
      | auditLogScalarWhereWithAggregatesInput
      | auditLogScalarWhereWithAggregatesInput[];
    auditLogId?: UuidWithAggregatesFilter<"auditLog"> | string;
    userId?: UuidWithAggregatesFilter<"auditLog"> | string;
    ipAddress?: StringWithAggregatesFilter<"auditLog"> | string;
    entityName?: StringWithAggregatesFilter<"auditLog"> | string;
    entityId?: StringWithAggregatesFilter<"auditLog"> | string;
    actionType?: StringWithAggregatesFilter<"auditLog"> | string;
    oldValue?: StringWithAggregatesFilter<"auditLog"> | string;
    newValue?: StringWithAggregatesFilter<"auditLog"> | string;
    timestamp?: DateTimeWithAggregatesFilter<"auditLog"> | Date | string;
    statusCode?: StringWithAggregatesFilter<"auditLog"> | string;
  };

  export type phoneNumberWhereInput = {
    AND?: phoneNumberWhereInput | phoneNumberWhereInput[];
    OR?: phoneNumberWhereInput[];
    NOT?: phoneNumberWhereInput | phoneNumberWhereInput[];
    phoneNumberId?: UuidFilter<"phoneNumber"> | string;
    userId?: UuidFilter<"phoneNumber"> | string;
    phoneNumber?: StringFilter<"phoneNumber"> | string;
    verified?: BoolFilter<"phoneNumber"> | boolean;
    isPrimary?: BoolFilter<"phoneNumber"> | boolean;
    createdAt?: DateTimeFilter<"phoneNumber"> | Date | string;
    statusCode?: StringFilter<"phoneNumber"> | string;
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>;
    status?: XOR<StatusScalarRelationFilter, statusWhereInput>;
  };

  export type phoneNumberOrderByWithRelationInput = {
    phoneNumberId?: SortOrder;
    userId?: SortOrder;
    phoneNumber?: SortOrder;
    verified?: SortOrder;
    isPrimary?: SortOrder;
    createdAt?: SortOrder;
    statusCode?: SortOrder;
    user?: usersOrderByWithRelationInput;
    status?: statusOrderByWithRelationInput;
  };

  export type phoneNumberWhereUniqueInput = Prisma.AtLeast<
    {
      phoneNumberId?: string;
      AND?: phoneNumberWhereInput | phoneNumberWhereInput[];
      OR?: phoneNumberWhereInput[];
      NOT?: phoneNumberWhereInput | phoneNumberWhereInput[];
      userId?: UuidFilter<"phoneNumber"> | string;
      phoneNumber?: StringFilter<"phoneNumber"> | string;
      verified?: BoolFilter<"phoneNumber"> | boolean;
      isPrimary?: BoolFilter<"phoneNumber"> | boolean;
      createdAt?: DateTimeFilter<"phoneNumber"> | Date | string;
      statusCode?: StringFilter<"phoneNumber"> | string;
      user?: XOR<UsersScalarRelationFilter, usersWhereInput>;
      status?: XOR<StatusScalarRelationFilter, statusWhereInput>;
    },
    "phoneNumberId"
  >;

  export type phoneNumberOrderByWithAggregationInput = {
    phoneNumberId?: SortOrder;
    userId?: SortOrder;
    phoneNumber?: SortOrder;
    verified?: SortOrder;
    isPrimary?: SortOrder;
    createdAt?: SortOrder;
    statusCode?: SortOrder;
    _count?: phoneNumberCountOrderByAggregateInput;
    _max?: phoneNumberMaxOrderByAggregateInput;
    _min?: phoneNumberMinOrderByAggregateInput;
  };

  export type phoneNumberScalarWhereWithAggregatesInput = {
    AND?:
      | phoneNumberScalarWhereWithAggregatesInput
      | phoneNumberScalarWhereWithAggregatesInput[];
    OR?: phoneNumberScalarWhereWithAggregatesInput[];
    NOT?:
      | phoneNumberScalarWhereWithAggregatesInput
      | phoneNumberScalarWhereWithAggregatesInput[];
    phoneNumberId?: UuidWithAggregatesFilter<"phoneNumber"> | string;
    userId?: UuidWithAggregatesFilter<"phoneNumber"> | string;
    phoneNumber?: StringWithAggregatesFilter<"phoneNumber"> | string;
    verified?: BoolWithAggregatesFilter<"phoneNumber"> | boolean;
    isPrimary?: BoolWithAggregatesFilter<"phoneNumber"> | boolean;
    createdAt?: DateTimeWithAggregatesFilter<"phoneNumber"> | Date | string;
    statusCode?: StringWithAggregatesFilter<"phoneNumber"> | string;
  };

  export type emailWhereInput = {
    AND?: emailWhereInput | emailWhereInput[];
    OR?: emailWhereInput[];
    NOT?: emailWhereInput | emailWhereInput[];
    emailId?: UuidFilter<"email"> | string;
    userId?: UuidFilter<"email"> | string;
    email?: StringFilter<"email"> | string;
    verified?: BoolFilter<"email"> | boolean;
    isPrimary?: BoolFilter<"email"> | boolean;
    createdAt?: DateTimeFilter<"email"> | Date | string;
    statusCode?: StringFilter<"email"> | string;
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>;
    status?: XOR<StatusScalarRelationFilter, statusWhereInput>;
  };

  export type emailOrderByWithRelationInput = {
    emailId?: SortOrder;
    userId?: SortOrder;
    email?: SortOrder;
    verified?: SortOrder;
    isPrimary?: SortOrder;
    createdAt?: SortOrder;
    statusCode?: SortOrder;
    user?: usersOrderByWithRelationInput;
    status?: statusOrderByWithRelationInput;
  };

  export type emailWhereUniqueInput = Prisma.AtLeast<
    {
      emailId?: string;
      AND?: emailWhereInput | emailWhereInput[];
      OR?: emailWhereInput[];
      NOT?: emailWhereInput | emailWhereInput[];
      userId?: UuidFilter<"email"> | string;
      email?: StringFilter<"email"> | string;
      verified?: BoolFilter<"email"> | boolean;
      isPrimary?: BoolFilter<"email"> | boolean;
      createdAt?: DateTimeFilter<"email"> | Date | string;
      statusCode?: StringFilter<"email"> | string;
      user?: XOR<UsersScalarRelationFilter, usersWhereInput>;
      status?: XOR<StatusScalarRelationFilter, statusWhereInput>;
    },
    "emailId"
  >;

  export type emailOrderByWithAggregationInput = {
    emailId?: SortOrder;
    userId?: SortOrder;
    email?: SortOrder;
    verified?: SortOrder;
    isPrimary?: SortOrder;
    createdAt?: SortOrder;
    statusCode?: SortOrder;
    _count?: emailCountOrderByAggregateInput;
    _max?: emailMaxOrderByAggregateInput;
    _min?: emailMinOrderByAggregateInput;
  };

  export type emailScalarWhereWithAggregatesInput = {
    AND?:
      | emailScalarWhereWithAggregatesInput
      | emailScalarWhereWithAggregatesInput[];
    OR?: emailScalarWhereWithAggregatesInput[];
    NOT?:
      | emailScalarWhereWithAggregatesInput
      | emailScalarWhereWithAggregatesInput[];
    emailId?: UuidWithAggregatesFilter<"email"> | string;
    userId?: UuidWithAggregatesFilter<"email"> | string;
    email?: StringWithAggregatesFilter<"email"> | string;
    verified?: BoolWithAggregatesFilter<"email"> | boolean;
    isPrimary?: BoolWithAggregatesFilter<"email"> | boolean;
    createdAt?: DateTimeWithAggregatesFilter<"email"> | Date | string;
    statusCode?: StringWithAggregatesFilter<"email"> | string;
  };

  export type userRoleWhereInput = {
    AND?: userRoleWhereInput | userRoleWhereInput[];
    OR?: userRoleWhereInput[];
    NOT?: userRoleWhereInput | userRoleWhereInput[];
    userId?: UuidFilter<"userRole"> | string;
    roleId?: IntFilter<"userRole"> | number;
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>;
    role?: XOR<RoleScalarRelationFilter, roleWhereInput>;
  };

  export type userRoleOrderByWithRelationInput = {
    userId?: SortOrder;
    roleId?: SortOrder;
    user?: usersOrderByWithRelationInput;
    role?: roleOrderByWithRelationInput;
  };

  export type userRoleWhereUniqueInput = Prisma.AtLeast<
    {
      userId_roleId?: userRoleUserIdRoleIdCompoundUniqueInput;
      AND?: userRoleWhereInput | userRoleWhereInput[];
      OR?: userRoleWhereInput[];
      NOT?: userRoleWhereInput | userRoleWhereInput[];
      userId?: UuidFilter<"userRole"> | string;
      roleId?: IntFilter<"userRole"> | number;
      user?: XOR<UsersScalarRelationFilter, usersWhereInput>;
      role?: XOR<RoleScalarRelationFilter, roleWhereInput>;
    },
    "userId_roleId"
  >;

  export type userRoleOrderByWithAggregationInput = {
    userId?: SortOrder;
    roleId?: SortOrder;
    _count?: userRoleCountOrderByAggregateInput;
    _avg?: userRoleAvgOrderByAggregateInput;
    _max?: userRoleMaxOrderByAggregateInput;
    _min?: userRoleMinOrderByAggregateInput;
    _sum?: userRoleSumOrderByAggregateInput;
  };

  export type userRoleScalarWhereWithAggregatesInput = {
    AND?:
      | userRoleScalarWhereWithAggregatesInput
      | userRoleScalarWhereWithAggregatesInput[];
    OR?: userRoleScalarWhereWithAggregatesInput[];
    NOT?:
      | userRoleScalarWhereWithAggregatesInput
      | userRoleScalarWhereWithAggregatesInput[];
    userId?: UuidWithAggregatesFilter<"userRole"> | string;
    roleId?: IntWithAggregatesFilter<"userRole"> | number;
  };

  export type roleWhereInput = {
    AND?: roleWhereInput | roleWhereInput[];
    OR?: roleWhereInput[];
    NOT?: roleWhereInput | roleWhereInput[];
    roleId?: IntFilter<"role"> | number;
    roleName?: StringFilter<"role"> | string;
    description?: StringFilter<"role"> | string;
    statusCode?: StringFilter<"role"> | string;
    userRoles?: UserRoleListRelationFilter;
    status?: XOR<StatusScalarRelationFilter, statusWhereInput>;
  };

  export type roleOrderByWithRelationInput = {
    roleId?: SortOrder;
    roleName?: SortOrder;
    description?: SortOrder;
    statusCode?: SortOrder;
    userRoles?: userRoleOrderByRelationAggregateInput;
    status?: statusOrderByWithRelationInput;
  };

  export type roleWhereUniqueInput = Prisma.AtLeast<
    {
      roleId?: number;
      AND?: roleWhereInput | roleWhereInput[];
      OR?: roleWhereInput[];
      NOT?: roleWhereInput | roleWhereInput[];
      roleName?: StringFilter<"role"> | string;
      description?: StringFilter<"role"> | string;
      statusCode?: StringFilter<"role"> | string;
      userRoles?: UserRoleListRelationFilter;
      status?: XOR<StatusScalarRelationFilter, statusWhereInput>;
    },
    "roleId"
  >;

  export type roleOrderByWithAggregationInput = {
    roleId?: SortOrder;
    roleName?: SortOrder;
    description?: SortOrder;
    statusCode?: SortOrder;
    _count?: roleCountOrderByAggregateInput;
    _avg?: roleAvgOrderByAggregateInput;
    _max?: roleMaxOrderByAggregateInput;
    _min?: roleMinOrderByAggregateInput;
    _sum?: roleSumOrderByAggregateInput;
  };

  export type roleScalarWhereWithAggregatesInput = {
    AND?:
      | roleScalarWhereWithAggregatesInput
      | roleScalarWhereWithAggregatesInput[];
    OR?: roleScalarWhereWithAggregatesInput[];
    NOT?:
      | roleScalarWhereWithAggregatesInput
      | roleScalarWhereWithAggregatesInput[];
    roleId?: IntWithAggregatesFilter<"role"> | number;
    roleName?: StringWithAggregatesFilter<"role"> | string;
    description?: StringWithAggregatesFilter<"role"> | string;
    statusCode?: StringWithAggregatesFilter<"role"> | string;
  };

  export type qrCodeWhereInput = {
    AND?: qrCodeWhereInput | qrCodeWhereInput[];
    OR?: qrCodeWhereInput[];
    NOT?: qrCodeWhereInput | qrCodeWhereInput[];
    qrCodeId?: UuidFilter<"qrCode"> | string;
    qrLink?: StringFilter<"qrCode"> | string;
    createdBy?: UuidFilter<"qrCode"> | string;
    createdAt?: DateTimeFilter<"qrCode"> | Date | string;
    statusCode?: StringFilter<"qrCode"> | string;
    exhibit?: ExhibitListRelationFilter;
    status?: XOR<StatusScalarRelationFilter, statusWhereInput>;
  };

  export type qrCodeOrderByWithRelationInput = {
    qrCodeId?: SortOrder;
    qrLink?: SortOrder;
    createdBy?: SortOrder;
    createdAt?: SortOrder;
    statusCode?: SortOrder;
    exhibit?: exhibitOrderByRelationAggregateInput;
    status?: statusOrderByWithRelationInput;
  };

  export type qrCodeWhereUniqueInput = Prisma.AtLeast<
    {
      qrCodeId?: string;
      AND?: qrCodeWhereInput | qrCodeWhereInput[];
      OR?: qrCodeWhereInput[];
      NOT?: qrCodeWhereInput | qrCodeWhereInput[];
      qrLink?: StringFilter<"qrCode"> | string;
      createdBy?: UuidFilter<"qrCode"> | string;
      createdAt?: DateTimeFilter<"qrCode"> | Date | string;
      statusCode?: StringFilter<"qrCode"> | string;
      exhibit?: ExhibitListRelationFilter;
      status?: XOR<StatusScalarRelationFilter, statusWhereInput>;
    },
    "qrCodeId"
  >;

  export type qrCodeOrderByWithAggregationInput = {
    qrCodeId?: SortOrder;
    qrLink?: SortOrder;
    createdBy?: SortOrder;
    createdAt?: SortOrder;
    statusCode?: SortOrder;
    _count?: qrCodeCountOrderByAggregateInput;
    _max?: qrCodeMaxOrderByAggregateInput;
    _min?: qrCodeMinOrderByAggregateInput;
  };

  export type qrCodeScalarWhereWithAggregatesInput = {
    AND?:
      | qrCodeScalarWhereWithAggregatesInput
      | qrCodeScalarWhereWithAggregatesInput[];
    OR?: qrCodeScalarWhereWithAggregatesInput[];
    NOT?:
      | qrCodeScalarWhereWithAggregatesInput
      | qrCodeScalarWhereWithAggregatesInput[];
    qrCodeId?: UuidWithAggregatesFilter<"qrCode"> | string;
    qrLink?: StringWithAggregatesFilter<"qrCode"> | string;
    createdBy?: UuidWithAggregatesFilter<"qrCode"> | string;
    createdAt?: DateTimeWithAggregatesFilter<"qrCode"> | Date | string;
    statusCode?: StringWithAggregatesFilter<"qrCode"> | string;
  };

  export type imageWhereInput = {
    AND?: imageWhereInput | imageWhereInput[];
    OR?: imageWhereInput[];
    NOT?: imageWhereInput | imageWhereInput[];
    imageId?: UuidFilter<"image"> | string;
    description?: StringFilter<"image"> | string;
    createdBy?: UuidFilter<"image"> | string;
    createdAt?: DateTimeFilter<"image"> | Date | string;
    statusCode?: StringFilter<"image"> | string;
    exhibit?: ExhibitListRelationFilter;
    status?: XOR<StatusScalarRelationFilter, statusWhereInput>;
  };

  export type imageOrderByWithRelationInput = {
    imageId?: SortOrder;
    description?: SortOrder;
    createdBy?: SortOrder;
    createdAt?: SortOrder;
    statusCode?: SortOrder;
    exhibit?: exhibitOrderByRelationAggregateInput;
    status?: statusOrderByWithRelationInput;
  };

  export type imageWhereUniqueInput = Prisma.AtLeast<
    {
      imageId?: string;
      AND?: imageWhereInput | imageWhereInput[];
      OR?: imageWhereInput[];
      NOT?: imageWhereInput | imageWhereInput[];
      description?: StringFilter<"image"> | string;
      createdBy?: UuidFilter<"image"> | string;
      createdAt?: DateTimeFilter<"image"> | Date | string;
      statusCode?: StringFilter<"image"> | string;
      exhibit?: ExhibitListRelationFilter;
      status?: XOR<StatusScalarRelationFilter, statusWhereInput>;
    },
    "imageId"
  >;

  export type imageOrderByWithAggregationInput = {
    imageId?: SortOrder;
    description?: SortOrder;
    createdBy?: SortOrder;
    createdAt?: SortOrder;
    statusCode?: SortOrder;
    _count?: imageCountOrderByAggregateInput;
    _max?: imageMaxOrderByAggregateInput;
    _min?: imageMinOrderByAggregateInput;
  };

  export type imageScalarWhereWithAggregatesInput = {
    AND?:
      | imageScalarWhereWithAggregatesInput
      | imageScalarWhereWithAggregatesInput[];
    OR?: imageScalarWhereWithAggregatesInput[];
    NOT?:
      | imageScalarWhereWithAggregatesInput
      | imageScalarWhereWithAggregatesInput[];
    imageId?: UuidWithAggregatesFilter<"image"> | string;
    description?: StringWithAggregatesFilter<"image"> | string;
    createdBy?: UuidWithAggregatesFilter<"image"> | string;
    createdAt?: DateTimeWithAggregatesFilter<"image"> | Date | string;
    statusCode?: StringWithAggregatesFilter<"image"> | string;
  };

  export type eventWhereInput = {
    AND?: eventWhereInput | eventWhereInput[];
    OR?: eventWhereInput[];
    NOT?: eventWhereInput | eventWhereInput[];
    eventId?: UuidFilter<"event"> | string;
    sessionId?: UuidFilter<"event"> | string;
    entityId?: IntFilter<"event"> | number;
    entityName?: StringFilter<"event"> | string;
    timestamp?: DateTimeFilter<"event"> | Date | string;
    usersUserId?: UuidNullableFilter<"event"> | string | null;
    session?: XOR<SessionScalarRelationFilter, sessionWhereInput>;
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null;
  };

  export type eventOrderByWithRelationInput = {
    eventId?: SortOrder;
    sessionId?: SortOrder;
    entityId?: SortOrder;
    entityName?: SortOrder;
    timestamp?: SortOrder;
    usersUserId?: SortOrderInput | SortOrder;
    session?: sessionOrderByWithRelationInput;
    users?: usersOrderByWithRelationInput;
  };

  export type eventWhereUniqueInput = Prisma.AtLeast<
    {
      eventId?: string;
      AND?: eventWhereInput | eventWhereInput[];
      OR?: eventWhereInput[];
      NOT?: eventWhereInput | eventWhereInput[];
      sessionId?: UuidFilter<"event"> | string;
      entityId?: IntFilter<"event"> | number;
      entityName?: StringFilter<"event"> | string;
      timestamp?: DateTimeFilter<"event"> | Date | string;
      usersUserId?: UuidNullableFilter<"event"> | string | null;
      session?: XOR<SessionScalarRelationFilter, sessionWhereInput>;
      users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null;
    },
    "eventId"
  >;

  export type eventOrderByWithAggregationInput = {
    eventId?: SortOrder;
    sessionId?: SortOrder;
    entityId?: SortOrder;
    entityName?: SortOrder;
    timestamp?: SortOrder;
    usersUserId?: SortOrderInput | SortOrder;
    _count?: eventCountOrderByAggregateInput;
    _avg?: eventAvgOrderByAggregateInput;
    _max?: eventMaxOrderByAggregateInput;
    _min?: eventMinOrderByAggregateInput;
    _sum?: eventSumOrderByAggregateInput;
  };

  export type eventScalarWhereWithAggregatesInput = {
    AND?:
      | eventScalarWhereWithAggregatesInput
      | eventScalarWhereWithAggregatesInput[];
    OR?: eventScalarWhereWithAggregatesInput[];
    NOT?:
      | eventScalarWhereWithAggregatesInput
      | eventScalarWhereWithAggregatesInput[];
    eventId?: UuidWithAggregatesFilter<"event"> | string;
    sessionId?: UuidWithAggregatesFilter<"event"> | string;
    entityId?: IntWithAggregatesFilter<"event"> | number;
    entityName?: StringWithAggregatesFilter<"event"> | string;
    timestamp?: DateTimeWithAggregatesFilter<"event"> | Date | string;
    usersUserId?: UuidNullableWithAggregatesFilter<"event"> | string | null;
  };

  export type sessionWhereInput = {
    AND?: sessionWhereInput | sessionWhereInput[];
    OR?: sessionWhereInput[];
    NOT?: sessionWhereInput | sessionWhereInput[];
    sessionId?: UuidFilter<"session"> | string;
    userId?: UuidFilter<"session"> | string;
    deviceInfo?: StringFilter<"session"> | string;
    isActive?: BoolFilter<"session"> | boolean;
    createdAt?: DateTimeFilter<"session"> | Date | string;
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>;
    events?: EventListRelationFilter;
  };

  export type sessionOrderByWithRelationInput = {
    sessionId?: SortOrder;
    userId?: SortOrder;
    deviceInfo?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    user?: usersOrderByWithRelationInput;
    events?: eventOrderByRelationAggregateInput;
  };

  export type sessionWhereUniqueInput = Prisma.AtLeast<
    {
      sessionId?: string;
      AND?: sessionWhereInput | sessionWhereInput[];
      OR?: sessionWhereInput[];
      NOT?: sessionWhereInput | sessionWhereInput[];
      userId?: UuidFilter<"session"> | string;
      deviceInfo?: StringFilter<"session"> | string;
      isActive?: BoolFilter<"session"> | boolean;
      createdAt?: DateTimeFilter<"session"> | Date | string;
      user?: XOR<UsersScalarRelationFilter, usersWhereInput>;
      events?: EventListRelationFilter;
    },
    "sessionId"
  >;

  export type sessionOrderByWithAggregationInput = {
    sessionId?: SortOrder;
    userId?: SortOrder;
    deviceInfo?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    _count?: sessionCountOrderByAggregateInput;
    _max?: sessionMaxOrderByAggregateInput;
    _min?: sessionMinOrderByAggregateInput;
  };

  export type sessionScalarWhereWithAggregatesInput = {
    AND?:
      | sessionScalarWhereWithAggregatesInput
      | sessionScalarWhereWithAggregatesInput[];
    OR?: sessionScalarWhereWithAggregatesInput[];
    NOT?:
      | sessionScalarWhereWithAggregatesInput
      | sessionScalarWhereWithAggregatesInput[];
    sessionId?: UuidWithAggregatesFilter<"session"> | string;
    userId?: UuidWithAggregatesFilter<"session"> | string;
    deviceInfo?: StringWithAggregatesFilter<"session"> | string;
    isActive?: BoolWithAggregatesFilter<"session"> | boolean;
    createdAt?: DateTimeWithAggregatesFilter<"session"> | Date | string;
  };

  export type userProfileWhereInput = {
    AND?: userProfileWhereInput | userProfileWhereInput[];
    OR?: userProfileWhereInput[];
    NOT?: userProfileWhereInput | userProfileWhereInput[];
    userProfileId?: UuidFilter<"userProfile"> | string;
    userId?: UuidFilter<"userProfile"> | string;
    fName?: StringFilter<"userProfile"> | string;
    lName?: StringFilter<"userProfile"> | string;
    languageCode?: StringFilter<"userProfile"> | string;
    gender?: StringFilter<"userProfile"> | string;
    dob?: DateTimeFilter<"userProfile"> | Date | string;
    modifiedBy?: UuidFilter<"userProfile"> | string;
    createdBy?: UuidFilter<"userProfile"> | string;
    createdAt?: DateTimeFilter<"userProfile"> | Date | string;
    modifiedAt?: DateTimeFilter<"userProfile"> | Date | string;
    statusCode?: StringFilter<"userProfile"> | string;
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>;
    language?: XOR<LanguageScalarRelationFilter, languageWhereInput>;
    status?: XOR<StatusScalarRelationFilter, statusWhereInput>;
  };

  export type userProfileOrderByWithRelationInput = {
    userProfileId?: SortOrder;
    userId?: SortOrder;
    fName?: SortOrder;
    lName?: SortOrder;
    languageCode?: SortOrder;
    gender?: SortOrder;
    dob?: SortOrder;
    modifiedBy?: SortOrder;
    createdBy?: SortOrder;
    createdAt?: SortOrder;
    modifiedAt?: SortOrder;
    statusCode?: SortOrder;
    user?: usersOrderByWithRelationInput;
    language?: languageOrderByWithRelationInput;
    status?: statusOrderByWithRelationInput;
  };

  export type userProfileWhereUniqueInput = Prisma.AtLeast<
    {
      userProfileId?: string;
      userId?: string;
      AND?: userProfileWhereInput | userProfileWhereInput[];
      OR?: userProfileWhereInput[];
      NOT?: userProfileWhereInput | userProfileWhereInput[];
      fName?: StringFilter<"userProfile"> | string;
      lName?: StringFilter<"userProfile"> | string;
      languageCode?: StringFilter<"userProfile"> | string;
      gender?: StringFilter<"userProfile"> | string;
      dob?: DateTimeFilter<"userProfile"> | Date | string;
      modifiedBy?: UuidFilter<"userProfile"> | string;
      createdBy?: UuidFilter<"userProfile"> | string;
      createdAt?: DateTimeFilter<"userProfile"> | Date | string;
      modifiedAt?: DateTimeFilter<"userProfile"> | Date | string;
      statusCode?: StringFilter<"userProfile"> | string;
      user?: XOR<UsersScalarRelationFilter, usersWhereInput>;
      language?: XOR<LanguageScalarRelationFilter, languageWhereInput>;
      status?: XOR<StatusScalarRelationFilter, statusWhereInput>;
    },
    "userProfileId" | "userId"
  >;

  export type userProfileOrderByWithAggregationInput = {
    userProfileId?: SortOrder;
    userId?: SortOrder;
    fName?: SortOrder;
    lName?: SortOrder;
    languageCode?: SortOrder;
    gender?: SortOrder;
    dob?: SortOrder;
    modifiedBy?: SortOrder;
    createdBy?: SortOrder;
    createdAt?: SortOrder;
    modifiedAt?: SortOrder;
    statusCode?: SortOrder;
    _count?: userProfileCountOrderByAggregateInput;
    _max?: userProfileMaxOrderByAggregateInput;
    _min?: userProfileMinOrderByAggregateInput;
  };

  export type userProfileScalarWhereWithAggregatesInput = {
    AND?:
      | userProfileScalarWhereWithAggregatesInput
      | userProfileScalarWhereWithAggregatesInput[];
    OR?: userProfileScalarWhereWithAggregatesInput[];
    NOT?:
      | userProfileScalarWhereWithAggregatesInput
      | userProfileScalarWhereWithAggregatesInput[];
    userProfileId?: UuidWithAggregatesFilter<"userProfile"> | string;
    userId?: UuidWithAggregatesFilter<"userProfile"> | string;
    fName?: StringWithAggregatesFilter<"userProfile"> | string;
    lName?: StringWithAggregatesFilter<"userProfile"> | string;
    languageCode?: StringWithAggregatesFilter<"userProfile"> | string;
    gender?: StringWithAggregatesFilter<"userProfile"> | string;
    dob?: DateTimeWithAggregatesFilter<"userProfile"> | Date | string;
    modifiedBy?: UuidWithAggregatesFilter<"userProfile"> | string;
    createdBy?: UuidWithAggregatesFilter<"userProfile"> | string;
    createdAt?: DateTimeWithAggregatesFilter<"userProfile"> | Date | string;
    modifiedAt?: DateTimeWithAggregatesFilter<"userProfile"> | Date | string;
    statusCode?: StringWithAggregatesFilter<"userProfile"> | string;
  };

  export type languageWhereInput = {
    AND?: languageWhereInput | languageWhereInput[];
    OR?: languageWhereInput[];
    NOT?: languageWhereInput | languageWhereInput[];
    languageCode?: StringFilter<"language"> | string;
    languageName?: StringFilter<"language"> | string;
    statusCode?: StringFilter<"language"> | string;
    audios?: AudioListRelationFilter;
    profiles?: UserProfileListRelationFilter;
    subtitles?: SubtitleListRelationFilter;
    status?: XOR<StatusScalarRelationFilter, statusWhereInput>;
  };

  export type languageOrderByWithRelationInput = {
    languageCode?: SortOrder;
    languageName?: SortOrder;
    statusCode?: SortOrder;
    audios?: audioOrderByRelationAggregateInput;
    profiles?: userProfileOrderByRelationAggregateInput;
    subtitles?: subtitleOrderByRelationAggregateInput;
    status?: statusOrderByWithRelationInput;
  };

  export type languageWhereUniqueInput = Prisma.AtLeast<
    {
      languageCode?: string;
      AND?: languageWhereInput | languageWhereInput[];
      OR?: languageWhereInput[];
      NOT?: languageWhereInput | languageWhereInput[];
      languageName?: StringFilter<"language"> | string;
      statusCode?: StringFilter<"language"> | string;
      audios?: AudioListRelationFilter;
      profiles?: UserProfileListRelationFilter;
      subtitles?: SubtitleListRelationFilter;
      status?: XOR<StatusScalarRelationFilter, statusWhereInput>;
    },
    "languageCode"
  >;

  export type languageOrderByWithAggregationInput = {
    languageCode?: SortOrder;
    languageName?: SortOrder;
    statusCode?: SortOrder;
    _count?: languageCountOrderByAggregateInput;
    _max?: languageMaxOrderByAggregateInput;
    _min?: languageMinOrderByAggregateInput;
  };

  export type languageScalarWhereWithAggregatesInput = {
    AND?:
      | languageScalarWhereWithAggregatesInput
      | languageScalarWhereWithAggregatesInput[];
    OR?: languageScalarWhereWithAggregatesInput[];
    NOT?:
      | languageScalarWhereWithAggregatesInput
      | languageScalarWhereWithAggregatesInput[];
    languageCode?: StringWithAggregatesFilter<"language"> | string;
    languageName?: StringWithAggregatesFilter<"language"> | string;
    statusCode?: StringWithAggregatesFilter<"language"> | string;
  };

  export type subtitleWhereInput = {
    AND?: subtitleWhereInput | subtitleWhereInput[];
    OR?: subtitleWhereInput[];
    NOT?: subtitleWhereInput | subtitleWhereInput[];
    subtitleId?: UuidFilter<"subtitle"> | string;
    subtitleText?: StringFilter<"subtitle"> | string;
    languageCode?: StringFilter<"subtitle"> | string;
    createdBy?: UuidFilter<"subtitle"> | string;
    modifiedBy?: UuidFilter<"subtitle"> | string;
    createdAt?: DateTimeFilter<"subtitle"> | Date | string;
    modifiedAt?: DateTimeFilter<"subtitle"> | Date | string;
    statusCode?: StringFilter<"subtitle"> | string;
    language?: XOR<LanguageScalarRelationFilter, languageWhereInput>;
    status?: XOR<StatusScalarRelationFilter, statusWhereInput>;
    exhibits?: ExhibitSubtitleListRelationFilter;
  };

  export type subtitleOrderByWithRelationInput = {
    subtitleId?: SortOrder;
    subtitleText?: SortOrder;
    languageCode?: SortOrder;
    createdBy?: SortOrder;
    modifiedBy?: SortOrder;
    createdAt?: SortOrder;
    modifiedAt?: SortOrder;
    statusCode?: SortOrder;
    language?: languageOrderByWithRelationInput;
    status?: statusOrderByWithRelationInput;
    exhibits?: exhibitSubtitleOrderByRelationAggregateInput;
  };

  export type subtitleWhereUniqueInput = Prisma.AtLeast<
    {
      subtitleId?: string;
      AND?: subtitleWhereInput | subtitleWhereInput[];
      OR?: subtitleWhereInput[];
      NOT?: subtitleWhereInput | subtitleWhereInput[];
      subtitleText?: StringFilter<"subtitle"> | string;
      languageCode?: StringFilter<"subtitle"> | string;
      createdBy?: UuidFilter<"subtitle"> | string;
      modifiedBy?: UuidFilter<"subtitle"> | string;
      createdAt?: DateTimeFilter<"subtitle"> | Date | string;
      modifiedAt?: DateTimeFilter<"subtitle"> | Date | string;
      statusCode?: StringFilter<"subtitle"> | string;
      language?: XOR<LanguageScalarRelationFilter, languageWhereInput>;
      status?: XOR<StatusScalarRelationFilter, statusWhereInput>;
      exhibits?: ExhibitSubtitleListRelationFilter;
    },
    "subtitleId"
  >;

  export type subtitleOrderByWithAggregationInput = {
    subtitleId?: SortOrder;
    subtitleText?: SortOrder;
    languageCode?: SortOrder;
    createdBy?: SortOrder;
    modifiedBy?: SortOrder;
    createdAt?: SortOrder;
    modifiedAt?: SortOrder;
    statusCode?: SortOrder;
    _count?: subtitleCountOrderByAggregateInput;
    _max?: subtitleMaxOrderByAggregateInput;
    _min?: subtitleMinOrderByAggregateInput;
  };

  export type subtitleScalarWhereWithAggregatesInput = {
    AND?:
      | subtitleScalarWhereWithAggregatesInput
      | subtitleScalarWhereWithAggregatesInput[];
    OR?: subtitleScalarWhereWithAggregatesInput[];
    NOT?:
      | subtitleScalarWhereWithAggregatesInput
      | subtitleScalarWhereWithAggregatesInput[];
    subtitleId?: UuidWithAggregatesFilter<"subtitle"> | string;
    subtitleText?: StringWithAggregatesFilter<"subtitle"> | string;
    languageCode?: StringWithAggregatesFilter<"subtitle"> | string;
    createdBy?: UuidWithAggregatesFilter<"subtitle"> | string;
    modifiedBy?: UuidWithAggregatesFilter<"subtitle"> | string;
    createdAt?: DateTimeWithAggregatesFilter<"subtitle"> | Date | string;
    modifiedAt?: DateTimeWithAggregatesFilter<"subtitle"> | Date | string;
    statusCode?: StringWithAggregatesFilter<"subtitle"> | string;
  };

  export type exhibitSubtitleWhereInput = {
    AND?: exhibitSubtitleWhereInput | exhibitSubtitleWhereInput[];
    OR?: exhibitSubtitleWhereInput[];
    NOT?: exhibitSubtitleWhereInput | exhibitSubtitleWhereInput[];
    exhibitId?: UuidFilter<"exhibitSubtitle"> | string;
    subtitleId?: UuidFilter<"exhibitSubtitle"> | string;
    createdAt?: DateTimeFilter<"exhibitSubtitle"> | Date | string;
    exhibit?: XOR<ExhibitScalarRelationFilter, exhibitWhereInput>;
    subtitle?: XOR<SubtitleScalarRelationFilter, subtitleWhereInput>;
  };

  export type exhibitSubtitleOrderByWithRelationInput = {
    exhibitId?: SortOrder;
    subtitleId?: SortOrder;
    createdAt?: SortOrder;
    exhibit?: exhibitOrderByWithRelationInput;
    subtitle?: subtitleOrderByWithRelationInput;
  };

  export type exhibitSubtitleWhereUniqueInput = Prisma.AtLeast<
    {
      exhibitId_subtitleId?: exhibitSubtitleExhibitIdSubtitleIdCompoundUniqueInput;
      AND?: exhibitSubtitleWhereInput | exhibitSubtitleWhereInput[];
      OR?: exhibitSubtitleWhereInput[];
      NOT?: exhibitSubtitleWhereInput | exhibitSubtitleWhereInput[];
      exhibitId?: UuidFilter<"exhibitSubtitle"> | string;
      subtitleId?: UuidFilter<"exhibitSubtitle"> | string;
      createdAt?: DateTimeFilter<"exhibitSubtitle"> | Date | string;
      exhibit?: XOR<ExhibitScalarRelationFilter, exhibitWhereInput>;
      subtitle?: XOR<SubtitleScalarRelationFilter, subtitleWhereInput>;
    },
    "exhibitId_subtitleId"
  >;

  export type exhibitSubtitleOrderByWithAggregationInput = {
    exhibitId?: SortOrder;
    subtitleId?: SortOrder;
    createdAt?: SortOrder;
    _count?: exhibitSubtitleCountOrderByAggregateInput;
    _max?: exhibitSubtitleMaxOrderByAggregateInput;
    _min?: exhibitSubtitleMinOrderByAggregateInput;
  };

  export type exhibitSubtitleScalarWhereWithAggregatesInput = {
    AND?:
      | exhibitSubtitleScalarWhereWithAggregatesInput
      | exhibitSubtitleScalarWhereWithAggregatesInput[];
    OR?: exhibitSubtitleScalarWhereWithAggregatesInput[];
    NOT?:
      | exhibitSubtitleScalarWhereWithAggregatesInput
      | exhibitSubtitleScalarWhereWithAggregatesInput[];
    exhibitId?: UuidWithAggregatesFilter<"exhibitSubtitle"> | string;
    subtitleId?: UuidWithAggregatesFilter<"exhibitSubtitle"> | string;
    createdAt?: DateTimeWithAggregatesFilter<"exhibitSubtitle"> | Date | string;
  };

  export type usersCreateInput = {
    userId?: string;
    username: string;
    password: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    phoneNumbers?: phoneNumberCreateNestedManyWithoutUserInput;
    emails?: emailCreateNestedManyWithoutUserInput;
    userProfile?: userProfileCreateNestedOneWithoutUserInput;
    sessions?: sessionCreateNestedManyWithoutUserInput;
    auditLogs?: auditLogCreateNestedManyWithoutUserInput;
    events?: eventCreateNestedManyWithoutUsersInput;
    userRoles?: userRoleCreateNestedManyWithoutUserInput;
    status: statusCreateNestedOneWithoutUsersInput;
  };

  export type usersUncheckedCreateInput = {
    userId?: string;
    username: string;
    password: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    statusCode: string;
    phoneNumbers?: phoneNumberUncheckedCreateNestedManyWithoutUserInput;
    emails?: emailUncheckedCreateNestedManyWithoutUserInput;
    userProfile?: userProfileUncheckedCreateNestedOneWithoutUserInput;
    sessions?: sessionUncheckedCreateNestedManyWithoutUserInput;
    auditLogs?: auditLogUncheckedCreateNestedManyWithoutUserInput;
    events?: eventUncheckedCreateNestedManyWithoutUsersInput;
    userRoles?: userRoleUncheckedCreateNestedManyWithoutUserInput;
  };

  export type usersUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    phoneNumbers?: phoneNumberUpdateManyWithoutUserNestedInput;
    emails?: emailUpdateManyWithoutUserNestedInput;
    userProfile?: userProfileUpdateOneWithoutUserNestedInput;
    sessions?: sessionUpdateManyWithoutUserNestedInput;
    auditLogs?: auditLogUpdateManyWithoutUserNestedInput;
    events?: eventUpdateManyWithoutUsersNestedInput;
    userRoles?: userRoleUpdateManyWithoutUserNestedInput;
    status?: statusUpdateOneRequiredWithoutUsersNestedInput;
  };

  export type usersUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
    phoneNumbers?: phoneNumberUncheckedUpdateManyWithoutUserNestedInput;
    emails?: emailUncheckedUpdateManyWithoutUserNestedInput;
    userProfile?: userProfileUncheckedUpdateOneWithoutUserNestedInput;
    sessions?: sessionUncheckedUpdateManyWithoutUserNestedInput;
    auditLogs?: auditLogUncheckedUpdateManyWithoutUserNestedInput;
    events?: eventUncheckedUpdateManyWithoutUsersNestedInput;
    userRoles?: userRoleUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type usersCreateManyInput = {
    userId?: string;
    username: string;
    password: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    statusCode: string;
  };

  export type usersUpdateManyMutationInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type usersUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
  };

  export type statusCreateInput = {
    statusCode: string;
    description: string;
    users?: usersCreateNestedManyWithoutStatusInput;
    audios?: audioCreateNestedManyWithoutStatusInput;
    exhibits?: exhibitCreateNestedManyWithoutStatusInput;
    phoneNumbers?: phoneNumberCreateNestedManyWithoutStatusInput;
    emails?: emailCreateNestedManyWithoutStatusInput;
    roles?: roleCreateNestedManyWithoutStatusInput;
    qrcodes?: qrCodeCreateNestedManyWithoutStatusInput;
    images?: imageCreateNestedManyWithoutStatusInput;
    subtitles?: subtitleCreateNestedManyWithoutStatusInput;
    languages?: languageCreateNestedManyWithoutStatusInput;
    auditLogs?: auditLogCreateNestedManyWithoutStatusInput;
    userProfiles?: userProfileCreateNestedManyWithoutStatusInput;
  };

  export type statusUncheckedCreateInput = {
    statusCode: string;
    description: string;
    users?: usersUncheckedCreateNestedManyWithoutStatusInput;
    audios?: audioUncheckedCreateNestedManyWithoutStatusInput;
    exhibits?: exhibitUncheckedCreateNestedManyWithoutStatusInput;
    phoneNumbers?: phoneNumberUncheckedCreateNestedManyWithoutStatusInput;
    emails?: emailUncheckedCreateNestedManyWithoutStatusInput;
    roles?: roleUncheckedCreateNestedManyWithoutStatusInput;
    qrcodes?: qrCodeUncheckedCreateNestedManyWithoutStatusInput;
    images?: imageUncheckedCreateNestedManyWithoutStatusInput;
    subtitles?: subtitleUncheckedCreateNestedManyWithoutStatusInput;
    languages?: languageUncheckedCreateNestedManyWithoutStatusInput;
    auditLogs?: auditLogUncheckedCreateNestedManyWithoutStatusInput;
    userProfiles?: userProfileUncheckedCreateNestedManyWithoutStatusInput;
  };

  export type statusUpdateInput = {
    statusCode?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    users?: usersUpdateManyWithoutStatusNestedInput;
    audios?: audioUpdateManyWithoutStatusNestedInput;
    exhibits?: exhibitUpdateManyWithoutStatusNestedInput;
    phoneNumbers?: phoneNumberUpdateManyWithoutStatusNestedInput;
    emails?: emailUpdateManyWithoutStatusNestedInput;
    roles?: roleUpdateManyWithoutStatusNestedInput;
    qrcodes?: qrCodeUpdateManyWithoutStatusNestedInput;
    images?: imageUpdateManyWithoutStatusNestedInput;
    subtitles?: subtitleUpdateManyWithoutStatusNestedInput;
    languages?: languageUpdateManyWithoutStatusNestedInput;
    auditLogs?: auditLogUpdateManyWithoutStatusNestedInput;
    userProfiles?: userProfileUpdateManyWithoutStatusNestedInput;
  };

  export type statusUncheckedUpdateInput = {
    statusCode?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    users?: usersUncheckedUpdateManyWithoutStatusNestedInput;
    audios?: audioUncheckedUpdateManyWithoutStatusNestedInput;
    exhibits?: exhibitUncheckedUpdateManyWithoutStatusNestedInput;
    phoneNumbers?: phoneNumberUncheckedUpdateManyWithoutStatusNestedInput;
    emails?: emailUncheckedUpdateManyWithoutStatusNestedInput;
    roles?: roleUncheckedUpdateManyWithoutStatusNestedInput;
    qrcodes?: qrCodeUncheckedUpdateManyWithoutStatusNestedInput;
    images?: imageUncheckedUpdateManyWithoutStatusNestedInput;
    subtitles?: subtitleUncheckedUpdateManyWithoutStatusNestedInput;
    languages?: languageUncheckedUpdateManyWithoutStatusNestedInput;
    auditLogs?: auditLogUncheckedUpdateManyWithoutStatusNestedInput;
    userProfiles?: userProfileUncheckedUpdateManyWithoutStatusNestedInput;
  };

  export type statusCreateManyInput = {
    statusCode: string;
    description: string;
  };

  export type statusUpdateManyMutationInput = {
    statusCode?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
  };

  export type statusUncheckedUpdateManyInput = {
    statusCode?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
  };

  export type audioCreateInput = {
    audioId?: string;
    fileUrl: string;
    description: string;
    createdBy: string;
    createdAt: Date | string;
    language: languageCreateNestedOneWithoutAudiosInput;
    status: statusCreateNestedOneWithoutAudiosInput;
    exhibits?: exhibitAudioRelationCreateNestedManyWithoutAudioInput;
    exhibit?: exhibitCreateNestedManyWithoutAudioInput;
  };

  export type audioUncheckedCreateInput = {
    audioId?: string;
    fileUrl: string;
    description: string;
    createdBy: string;
    languageId: string;
    createdAt: Date | string;
    statusCode: string;
    exhibits?: exhibitAudioRelationUncheckedCreateNestedManyWithoutAudioInput;
    exhibit?: exhibitUncheckedCreateNestedManyWithoutAudioInput;
  };

  export type audioUpdateInput = {
    audioId?: StringFieldUpdateOperationsInput | string;
    fileUrl?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    language?: languageUpdateOneRequiredWithoutAudiosNestedInput;
    status?: statusUpdateOneRequiredWithoutAudiosNestedInput;
    exhibits?: exhibitAudioRelationUpdateManyWithoutAudioNestedInput;
    exhibit?: exhibitUpdateManyWithoutAudioNestedInput;
  };

  export type audioUncheckedUpdateInput = {
    audioId?: StringFieldUpdateOperationsInput | string;
    fileUrl?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    languageId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
    exhibits?: exhibitAudioRelationUncheckedUpdateManyWithoutAudioNestedInput;
    exhibit?: exhibitUncheckedUpdateManyWithoutAudioNestedInput;
  };

  export type audioCreateManyInput = {
    audioId?: string;
    fileUrl: string;
    description: string;
    createdBy: string;
    languageId: string;
    createdAt: Date | string;
    statusCode: string;
  };

  export type audioUpdateManyMutationInput = {
    audioId?: StringFieldUpdateOperationsInput | string;
    fileUrl?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type audioUncheckedUpdateManyInput = {
    audioId?: StringFieldUpdateOperationsInput | string;
    fileUrl?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    languageId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
  };

  export type exhibitAudioRelationCreateInput = {
    audio: audioCreateNestedOneWithoutExhibitsInput;
    exhibit: exhibitCreateNestedOneWithoutExhibitAudioRelationInput;
  };

  export type exhibitAudioRelationUncheckedCreateInput = {
    audioId: string;
    exhibitId: string;
  };

  export type exhibitAudioRelationUpdateInput = {
    audio?: audioUpdateOneRequiredWithoutExhibitsNestedInput;
    exhibit?: exhibitUpdateOneRequiredWithoutExhibitAudioRelationNestedInput;
  };

  export type exhibitAudioRelationUncheckedUpdateInput = {
    audioId?: StringFieldUpdateOperationsInput | string;
    exhibitId?: StringFieldUpdateOperationsInput | string;
  };

  export type exhibitAudioRelationCreateManyInput = {
    audioId: string;
    exhibitId: string;
  };

  export type exhibitAudioRelationUpdateManyMutationInput = {};

  export type exhibitAudioRelationUncheckedUpdateManyInput = {
    audioId?: StringFieldUpdateOperationsInput | string;
    exhibitId?: StringFieldUpdateOperationsInput | string;
  };

  export type exhibitCreateInput = {
    exhibitId?: string;
    title: string;
    description: string;
    createdBy: string;
    modifiedBy: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    audio: audioCreateNestedOneWithoutExhibitInput;
    qrCode: qrCodeCreateNestedOneWithoutExhibitInput;
    image: imageCreateNestedOneWithoutExhibitInput;
    subtitles?: exhibitSubtitleCreateNestedManyWithoutExhibitInput;
    status: statusCreateNestedOneWithoutExhibitsInput;
    exhibitAudioRelation?: exhibitAudioRelationCreateNestedManyWithoutExhibitInput;
  };

  export type exhibitUncheckedCreateInput = {
    exhibitId?: string;
    title: string;
    description: string;
    audioId: string;
    createdBy: string;
    modifiedBy: string;
    qrCodeId: string;
    imageId: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    statusCode: string;
    subtitles?: exhibitSubtitleUncheckedCreateNestedManyWithoutExhibitInput;
    exhibitAudioRelation?: exhibitAudioRelationUncheckedCreateNestedManyWithoutExhibitInput;
  };

  export type exhibitUpdateInput = {
    exhibitId?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    modifiedBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    audio?: audioUpdateOneRequiredWithoutExhibitNestedInput;
    qrCode?: qrCodeUpdateOneRequiredWithoutExhibitNestedInput;
    image?: imageUpdateOneRequiredWithoutExhibitNestedInput;
    subtitles?: exhibitSubtitleUpdateManyWithoutExhibitNestedInput;
    status?: statusUpdateOneRequiredWithoutExhibitsNestedInput;
    exhibitAudioRelation?: exhibitAudioRelationUpdateManyWithoutExhibitNestedInput;
  };

  export type exhibitUncheckedUpdateInput = {
    exhibitId?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    audioId?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    modifiedBy?: StringFieldUpdateOperationsInput | string;
    qrCodeId?: StringFieldUpdateOperationsInput | string;
    imageId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
    subtitles?: exhibitSubtitleUncheckedUpdateManyWithoutExhibitNestedInput;
    exhibitAudioRelation?: exhibitAudioRelationUncheckedUpdateManyWithoutExhibitNestedInput;
  };

  export type exhibitCreateManyInput = {
    exhibitId?: string;
    title: string;
    description: string;
    audioId: string;
    createdBy: string;
    modifiedBy: string;
    qrCodeId: string;
    imageId: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    statusCode: string;
  };

  export type exhibitUpdateManyMutationInput = {
    exhibitId?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    modifiedBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type exhibitUncheckedUpdateManyInput = {
    exhibitId?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    audioId?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    modifiedBy?: StringFieldUpdateOperationsInput | string;
    qrCodeId?: StringFieldUpdateOperationsInput | string;
    imageId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
  };

  export type auditLogCreateInput = {
    auditLogId?: string;
    ipAddress: string;
    entityName: string;
    entityId: string;
    actionType: string;
    oldValue: string;
    newValue: string;
    timestamp: Date | string;
    user: usersCreateNestedOneWithoutAuditLogsInput;
    status: statusCreateNestedOneWithoutAuditLogsInput;
  };

  export type auditLogUncheckedCreateInput = {
    auditLogId?: string;
    userId: string;
    ipAddress: string;
    entityName: string;
    entityId: string;
    actionType: string;
    oldValue: string;
    newValue: string;
    timestamp: Date | string;
    statusCode: string;
  };

  export type auditLogUpdateInput = {
    auditLogId?: StringFieldUpdateOperationsInput | string;
    ipAddress?: StringFieldUpdateOperationsInput | string;
    entityName?: StringFieldUpdateOperationsInput | string;
    entityId?: StringFieldUpdateOperationsInput | string;
    actionType?: StringFieldUpdateOperationsInput | string;
    oldValue?: StringFieldUpdateOperationsInput | string;
    newValue?: StringFieldUpdateOperationsInput | string;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: usersUpdateOneRequiredWithoutAuditLogsNestedInput;
    status?: statusUpdateOneRequiredWithoutAuditLogsNestedInput;
  };

  export type auditLogUncheckedUpdateInput = {
    auditLogId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    ipAddress?: StringFieldUpdateOperationsInput | string;
    entityName?: StringFieldUpdateOperationsInput | string;
    entityId?: StringFieldUpdateOperationsInput | string;
    actionType?: StringFieldUpdateOperationsInput | string;
    oldValue?: StringFieldUpdateOperationsInput | string;
    newValue?: StringFieldUpdateOperationsInput | string;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
  };

  export type auditLogCreateManyInput = {
    auditLogId?: string;
    userId: string;
    ipAddress: string;
    entityName: string;
    entityId: string;
    actionType: string;
    oldValue: string;
    newValue: string;
    timestamp: Date | string;
    statusCode: string;
  };

  export type auditLogUpdateManyMutationInput = {
    auditLogId?: StringFieldUpdateOperationsInput | string;
    ipAddress?: StringFieldUpdateOperationsInput | string;
    entityName?: StringFieldUpdateOperationsInput | string;
    entityId?: StringFieldUpdateOperationsInput | string;
    actionType?: StringFieldUpdateOperationsInput | string;
    oldValue?: StringFieldUpdateOperationsInput | string;
    newValue?: StringFieldUpdateOperationsInput | string;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type auditLogUncheckedUpdateManyInput = {
    auditLogId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    ipAddress?: StringFieldUpdateOperationsInput | string;
    entityName?: StringFieldUpdateOperationsInput | string;
    entityId?: StringFieldUpdateOperationsInput | string;
    actionType?: StringFieldUpdateOperationsInput | string;
    oldValue?: StringFieldUpdateOperationsInput | string;
    newValue?: StringFieldUpdateOperationsInput | string;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
  };

  export type phoneNumberCreateInput = {
    phoneNumberId?: string;
    phoneNumber: string;
    verified: boolean;
    isPrimary: boolean;
    createdAt: Date | string;
    user: usersCreateNestedOneWithoutPhoneNumbersInput;
    status: statusCreateNestedOneWithoutPhoneNumbersInput;
  };

  export type phoneNumberUncheckedCreateInput = {
    phoneNumberId?: string;
    userId: string;
    phoneNumber: string;
    verified: boolean;
    isPrimary: boolean;
    createdAt: Date | string;
    statusCode: string;
  };

  export type phoneNumberUpdateInput = {
    phoneNumberId?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: StringFieldUpdateOperationsInput | string;
    verified?: BoolFieldUpdateOperationsInput | boolean;
    isPrimary?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: usersUpdateOneRequiredWithoutPhoneNumbersNestedInput;
    status?: statusUpdateOneRequiredWithoutPhoneNumbersNestedInput;
  };

  export type phoneNumberUncheckedUpdateInput = {
    phoneNumberId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: StringFieldUpdateOperationsInput | string;
    verified?: BoolFieldUpdateOperationsInput | boolean;
    isPrimary?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
  };

  export type phoneNumberCreateManyInput = {
    phoneNumberId?: string;
    userId: string;
    phoneNumber: string;
    verified: boolean;
    isPrimary: boolean;
    createdAt: Date | string;
    statusCode: string;
  };

  export type phoneNumberUpdateManyMutationInput = {
    phoneNumberId?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: StringFieldUpdateOperationsInput | string;
    verified?: BoolFieldUpdateOperationsInput | boolean;
    isPrimary?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type phoneNumberUncheckedUpdateManyInput = {
    phoneNumberId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: StringFieldUpdateOperationsInput | string;
    verified?: BoolFieldUpdateOperationsInput | boolean;
    isPrimary?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
  };

  export type emailCreateInput = {
    emailId?: string;
    email: string;
    verified: boolean;
    isPrimary: boolean;
    createdAt: Date | string;
    user: usersCreateNestedOneWithoutEmailsInput;
    status: statusCreateNestedOneWithoutEmailsInput;
  };

  export type emailUncheckedCreateInput = {
    emailId?: string;
    userId: string;
    email: string;
    verified: boolean;
    isPrimary: boolean;
    createdAt: Date | string;
    statusCode: string;
  };

  export type emailUpdateInput = {
    emailId?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    verified?: BoolFieldUpdateOperationsInput | boolean;
    isPrimary?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: usersUpdateOneRequiredWithoutEmailsNestedInput;
    status?: statusUpdateOneRequiredWithoutEmailsNestedInput;
  };

  export type emailUncheckedUpdateInput = {
    emailId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    verified?: BoolFieldUpdateOperationsInput | boolean;
    isPrimary?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
  };

  export type emailCreateManyInput = {
    emailId?: string;
    userId: string;
    email: string;
    verified: boolean;
    isPrimary: boolean;
    createdAt: Date | string;
    statusCode: string;
  };

  export type emailUpdateManyMutationInput = {
    emailId?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    verified?: BoolFieldUpdateOperationsInput | boolean;
    isPrimary?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type emailUncheckedUpdateManyInput = {
    emailId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    verified?: BoolFieldUpdateOperationsInput | boolean;
    isPrimary?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
  };

  export type userRoleCreateInput = {
    user: usersCreateNestedOneWithoutUserRolesInput;
    role: roleCreateNestedOneWithoutUserRolesInput;
  };

  export type userRoleUncheckedCreateInput = {
    userId: string;
    roleId: number;
  };

  export type userRoleUpdateInput = {
    user?: usersUpdateOneRequiredWithoutUserRolesNestedInput;
    role?: roleUpdateOneRequiredWithoutUserRolesNestedInput;
  };

  export type userRoleUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    roleId?: IntFieldUpdateOperationsInput | number;
  };

  export type userRoleCreateManyInput = {
    userId: string;
    roleId: number;
  };

  export type userRoleUpdateManyMutationInput = {};

  export type userRoleUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    roleId?: IntFieldUpdateOperationsInput | number;
  };

  export type roleCreateInput = {
    roleName: string;
    description: string;
    userRoles?: userRoleCreateNestedManyWithoutRoleInput;
    status: statusCreateNestedOneWithoutRolesInput;
  };

  export type roleUncheckedCreateInput = {
    roleId?: number;
    roleName: string;
    description: string;
    statusCode: string;
    userRoles?: userRoleUncheckedCreateNestedManyWithoutRoleInput;
  };

  export type roleUpdateInput = {
    roleName?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    userRoles?: userRoleUpdateManyWithoutRoleNestedInput;
    status?: statusUpdateOneRequiredWithoutRolesNestedInput;
  };

  export type roleUncheckedUpdateInput = {
    roleId?: IntFieldUpdateOperationsInput | number;
    roleName?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
    userRoles?: userRoleUncheckedUpdateManyWithoutRoleNestedInput;
  };

  export type roleCreateManyInput = {
    roleId?: number;
    roleName: string;
    description: string;
    statusCode: string;
  };

  export type roleUpdateManyMutationInput = {
    roleName?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
  };

  export type roleUncheckedUpdateManyInput = {
    roleId?: IntFieldUpdateOperationsInput | number;
    roleName?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
  };

  export type qrCodeCreateInput = {
    qrCodeId?: string;
    qrLink: string;
    createdBy: string;
    createdAt: Date | string;
    exhibit?: exhibitCreateNestedManyWithoutQrCodeInput;
    status: statusCreateNestedOneWithoutQrcodesInput;
  };

  export type qrCodeUncheckedCreateInput = {
    qrCodeId?: string;
    qrLink: string;
    createdBy: string;
    createdAt: Date | string;
    statusCode: string;
    exhibit?: exhibitUncheckedCreateNestedManyWithoutQrCodeInput;
  };

  export type qrCodeUpdateInput = {
    qrCodeId?: StringFieldUpdateOperationsInput | string;
    qrLink?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    exhibit?: exhibitUpdateManyWithoutQrCodeNestedInput;
    status?: statusUpdateOneRequiredWithoutQrcodesNestedInput;
  };

  export type qrCodeUncheckedUpdateInput = {
    qrCodeId?: StringFieldUpdateOperationsInput | string;
    qrLink?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
    exhibit?: exhibitUncheckedUpdateManyWithoutQrCodeNestedInput;
  };

  export type qrCodeCreateManyInput = {
    qrCodeId?: string;
    qrLink: string;
    createdBy: string;
    createdAt: Date | string;
    statusCode: string;
  };

  export type qrCodeUpdateManyMutationInput = {
    qrCodeId?: StringFieldUpdateOperationsInput | string;
    qrLink?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type qrCodeUncheckedUpdateManyInput = {
    qrCodeId?: StringFieldUpdateOperationsInput | string;
    qrLink?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
  };

  export type imageCreateInput = {
    imageId?: string;
    description: string;
    createdBy: string;
    createdAt: Date | string;
    exhibit?: exhibitCreateNestedManyWithoutImageInput;
    status: statusCreateNestedOneWithoutImagesInput;
  };

  export type imageUncheckedCreateInput = {
    imageId?: string;
    description: string;
    createdBy: string;
    createdAt: Date | string;
    statusCode: string;
    exhibit?: exhibitUncheckedCreateNestedManyWithoutImageInput;
  };

  export type imageUpdateInput = {
    imageId?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    exhibit?: exhibitUpdateManyWithoutImageNestedInput;
    status?: statusUpdateOneRequiredWithoutImagesNestedInput;
  };

  export type imageUncheckedUpdateInput = {
    imageId?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
    exhibit?: exhibitUncheckedUpdateManyWithoutImageNestedInput;
  };

  export type imageCreateManyInput = {
    imageId?: string;
    description: string;
    createdBy: string;
    createdAt: Date | string;
    statusCode: string;
  };

  export type imageUpdateManyMutationInput = {
    imageId?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type imageUncheckedUpdateManyInput = {
    imageId?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
  };

  export type eventCreateInput = {
    eventId?: string;
    entityId: number;
    entityName: string;
    timestamp: Date | string;
    session: sessionCreateNestedOneWithoutEventsInput;
    users?: usersCreateNestedOneWithoutEventsInput;
  };

  export type eventUncheckedCreateInput = {
    eventId?: string;
    sessionId: string;
    entityId: number;
    entityName: string;
    timestamp: Date | string;
    usersUserId?: string | null;
  };

  export type eventUpdateInput = {
    eventId?: StringFieldUpdateOperationsInput | string;
    entityId?: IntFieldUpdateOperationsInput | number;
    entityName?: StringFieldUpdateOperationsInput | string;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
    session?: sessionUpdateOneRequiredWithoutEventsNestedInput;
    users?: usersUpdateOneWithoutEventsNestedInput;
  };

  export type eventUncheckedUpdateInput = {
    eventId?: StringFieldUpdateOperationsInput | string;
    sessionId?: StringFieldUpdateOperationsInput | string;
    entityId?: IntFieldUpdateOperationsInput | number;
    entityName?: StringFieldUpdateOperationsInput | string;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
    usersUserId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type eventCreateManyInput = {
    eventId?: string;
    sessionId: string;
    entityId: number;
    entityName: string;
    timestamp: Date | string;
    usersUserId?: string | null;
  };

  export type eventUpdateManyMutationInput = {
    eventId?: StringFieldUpdateOperationsInput | string;
    entityId?: IntFieldUpdateOperationsInput | number;
    entityName?: StringFieldUpdateOperationsInput | string;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type eventUncheckedUpdateManyInput = {
    eventId?: StringFieldUpdateOperationsInput | string;
    sessionId?: StringFieldUpdateOperationsInput | string;
    entityId?: IntFieldUpdateOperationsInput | number;
    entityName?: StringFieldUpdateOperationsInput | string;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
    usersUserId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type sessionCreateInput = {
    sessionId?: string;
    deviceInfo: string;
    isActive: boolean;
    createdAt: Date | string;
    user: usersCreateNestedOneWithoutSessionsInput;
    events?: eventCreateNestedManyWithoutSessionInput;
  };

  export type sessionUncheckedCreateInput = {
    sessionId?: string;
    userId: string;
    deviceInfo: string;
    isActive: boolean;
    createdAt: Date | string;
    events?: eventUncheckedCreateNestedManyWithoutSessionInput;
  };

  export type sessionUpdateInput = {
    sessionId?: StringFieldUpdateOperationsInput | string;
    deviceInfo?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: usersUpdateOneRequiredWithoutSessionsNestedInput;
    events?: eventUpdateManyWithoutSessionNestedInput;
  };

  export type sessionUncheckedUpdateInput = {
    sessionId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    deviceInfo?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    events?: eventUncheckedUpdateManyWithoutSessionNestedInput;
  };

  export type sessionCreateManyInput = {
    sessionId?: string;
    userId: string;
    deviceInfo: string;
    isActive: boolean;
    createdAt: Date | string;
  };

  export type sessionUpdateManyMutationInput = {
    sessionId?: StringFieldUpdateOperationsInput | string;
    deviceInfo?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type sessionUncheckedUpdateManyInput = {
    sessionId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    deviceInfo?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type userProfileCreateInput = {
    userProfileId?: string;
    fName: string;
    lName: string;
    gender: string;
    dob: Date | string;
    modifiedBy: string;
    createdBy: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    user: usersCreateNestedOneWithoutUserProfileInput;
    language: languageCreateNestedOneWithoutProfilesInput;
    status: statusCreateNestedOneWithoutUserProfilesInput;
  };

  export type userProfileUncheckedCreateInput = {
    userProfileId?: string;
    userId: string;
    fName: string;
    lName: string;
    languageCode: string;
    gender: string;
    dob: Date | string;
    modifiedBy: string;
    createdBy: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    statusCode: string;
  };

  export type userProfileUpdateInput = {
    userProfileId?: StringFieldUpdateOperationsInput | string;
    fName?: StringFieldUpdateOperationsInput | string;
    lName?: StringFieldUpdateOperationsInput | string;
    gender?: StringFieldUpdateOperationsInput | string;
    dob?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedBy?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: usersUpdateOneRequiredWithoutUserProfileNestedInput;
    language?: languageUpdateOneRequiredWithoutProfilesNestedInput;
    status?: statusUpdateOneRequiredWithoutUserProfilesNestedInput;
  };

  export type userProfileUncheckedUpdateInput = {
    userProfileId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    fName?: StringFieldUpdateOperationsInput | string;
    lName?: StringFieldUpdateOperationsInput | string;
    languageCode?: StringFieldUpdateOperationsInput | string;
    gender?: StringFieldUpdateOperationsInput | string;
    dob?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedBy?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
  };

  export type userProfileCreateManyInput = {
    userProfileId?: string;
    userId: string;
    fName: string;
    lName: string;
    languageCode: string;
    gender: string;
    dob: Date | string;
    modifiedBy: string;
    createdBy: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    statusCode: string;
  };

  export type userProfileUpdateManyMutationInput = {
    userProfileId?: StringFieldUpdateOperationsInput | string;
    fName?: StringFieldUpdateOperationsInput | string;
    lName?: StringFieldUpdateOperationsInput | string;
    gender?: StringFieldUpdateOperationsInput | string;
    dob?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedBy?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type userProfileUncheckedUpdateManyInput = {
    userProfileId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    fName?: StringFieldUpdateOperationsInput | string;
    lName?: StringFieldUpdateOperationsInput | string;
    languageCode?: StringFieldUpdateOperationsInput | string;
    gender?: StringFieldUpdateOperationsInput | string;
    dob?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedBy?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
  };

  export type languageCreateInput = {
    languageCode: string;
    languageName: string;
    audios?: audioCreateNestedManyWithoutLanguageInput;
    profiles?: userProfileCreateNestedManyWithoutLanguageInput;
    subtitles?: subtitleCreateNestedManyWithoutLanguageInput;
    status: statusCreateNestedOneWithoutLanguagesInput;
  };

  export type languageUncheckedCreateInput = {
    languageCode: string;
    languageName: string;
    statusCode: string;
    audios?: audioUncheckedCreateNestedManyWithoutLanguageInput;
    profiles?: userProfileUncheckedCreateNestedManyWithoutLanguageInput;
    subtitles?: subtitleUncheckedCreateNestedManyWithoutLanguageInput;
  };

  export type languageUpdateInput = {
    languageCode?: StringFieldUpdateOperationsInput | string;
    languageName?: StringFieldUpdateOperationsInput | string;
    audios?: audioUpdateManyWithoutLanguageNestedInput;
    profiles?: userProfileUpdateManyWithoutLanguageNestedInput;
    subtitles?: subtitleUpdateManyWithoutLanguageNestedInput;
    status?: statusUpdateOneRequiredWithoutLanguagesNestedInput;
  };

  export type languageUncheckedUpdateInput = {
    languageCode?: StringFieldUpdateOperationsInput | string;
    languageName?: StringFieldUpdateOperationsInput | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
    audios?: audioUncheckedUpdateManyWithoutLanguageNestedInput;
    profiles?: userProfileUncheckedUpdateManyWithoutLanguageNestedInput;
    subtitles?: subtitleUncheckedUpdateManyWithoutLanguageNestedInput;
  };

  export type languageCreateManyInput = {
    languageCode: string;
    languageName: string;
    statusCode: string;
  };

  export type languageUpdateManyMutationInput = {
    languageCode?: StringFieldUpdateOperationsInput | string;
    languageName?: StringFieldUpdateOperationsInput | string;
  };

  export type languageUncheckedUpdateManyInput = {
    languageCode?: StringFieldUpdateOperationsInput | string;
    languageName?: StringFieldUpdateOperationsInput | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
  };

  export type subtitleCreateInput = {
    subtitleId?: string;
    subtitleText: string;
    createdBy: string;
    modifiedBy: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    language: languageCreateNestedOneWithoutSubtitlesInput;
    status: statusCreateNestedOneWithoutSubtitlesInput;
    exhibits?: exhibitSubtitleCreateNestedManyWithoutSubtitleInput;
  };

  export type subtitleUncheckedCreateInput = {
    subtitleId?: string;
    subtitleText: string;
    languageCode: string;
    createdBy: string;
    modifiedBy: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    statusCode: string;
    exhibits?: exhibitSubtitleUncheckedCreateNestedManyWithoutSubtitleInput;
  };

  export type subtitleUpdateInput = {
    subtitleId?: StringFieldUpdateOperationsInput | string;
    subtitleText?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    modifiedBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    language?: languageUpdateOneRequiredWithoutSubtitlesNestedInput;
    status?: statusUpdateOneRequiredWithoutSubtitlesNestedInput;
    exhibits?: exhibitSubtitleUpdateManyWithoutSubtitleNestedInput;
  };

  export type subtitleUncheckedUpdateInput = {
    subtitleId?: StringFieldUpdateOperationsInput | string;
    subtitleText?: StringFieldUpdateOperationsInput | string;
    languageCode?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    modifiedBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
    exhibits?: exhibitSubtitleUncheckedUpdateManyWithoutSubtitleNestedInput;
  };

  export type subtitleCreateManyInput = {
    subtitleId?: string;
    subtitleText: string;
    languageCode: string;
    createdBy: string;
    modifiedBy: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    statusCode: string;
  };

  export type subtitleUpdateManyMutationInput = {
    subtitleId?: StringFieldUpdateOperationsInput | string;
    subtitleText?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    modifiedBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type subtitleUncheckedUpdateManyInput = {
    subtitleId?: StringFieldUpdateOperationsInput | string;
    subtitleText?: StringFieldUpdateOperationsInput | string;
    languageCode?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    modifiedBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
  };

  export type exhibitSubtitleCreateInput = {
    createdAt: Date | string;
    exhibit: exhibitCreateNestedOneWithoutSubtitlesInput;
    subtitle: subtitleCreateNestedOneWithoutExhibitsInput;
  };

  export type exhibitSubtitleUncheckedCreateInput = {
    exhibitId: string;
    subtitleId: string;
    createdAt: Date | string;
  };

  export type exhibitSubtitleUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    exhibit?: exhibitUpdateOneRequiredWithoutSubtitlesNestedInput;
    subtitle?: subtitleUpdateOneRequiredWithoutExhibitsNestedInput;
  };

  export type exhibitSubtitleUncheckedUpdateInput = {
    exhibitId?: StringFieldUpdateOperationsInput | string;
    subtitleId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type exhibitSubtitleCreateManyInput = {
    exhibitId: string;
    subtitleId: string;
    createdAt: Date | string;
  };

  export type exhibitSubtitleUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type exhibitSubtitleUncheckedUpdateManyInput = {
    exhibitId?: StringFieldUpdateOperationsInput | string;
    subtitleId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedUuidFilter<$PrismaModel> | string;
  };

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type PhoneNumberListRelationFilter = {
    every?: phoneNumberWhereInput;
    some?: phoneNumberWhereInput;
    none?: phoneNumberWhereInput;
  };

  export type EmailListRelationFilter = {
    every?: emailWhereInput;
    some?: emailWhereInput;
    none?: emailWhereInput;
  };

  export type UserProfileNullableScalarRelationFilter = {
    is?: userProfileWhereInput | null;
    isNot?: userProfileWhereInput | null;
  };

  export type SessionListRelationFilter = {
    every?: sessionWhereInput;
    some?: sessionWhereInput;
    none?: sessionWhereInput;
  };

  export type AuditLogListRelationFilter = {
    every?: auditLogWhereInput;
    some?: auditLogWhereInput;
    none?: auditLogWhereInput;
  };

  export type EventListRelationFilter = {
    every?: eventWhereInput;
    some?: eventWhereInput;
    none?: eventWhereInput;
  };

  export type UserRoleListRelationFilter = {
    every?: userRoleWhereInput;
    some?: userRoleWhereInput;
    none?: userRoleWhereInput;
  };

  export type StatusScalarRelationFilter = {
    is?: statusWhereInput;
    isNot?: statusWhereInput;
  };

  export type phoneNumberOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type emailOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type sessionOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type auditLogOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type eventOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type userRoleOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type usersCountOrderByAggregateInput = {
    userId?: SortOrder;
    username?: SortOrder;
    password?: SortOrder;
    createdAt?: SortOrder;
    modifiedAt?: SortOrder;
    statusCode?: SortOrder;
  };

  export type usersMaxOrderByAggregateInput = {
    userId?: SortOrder;
    username?: SortOrder;
    password?: SortOrder;
    createdAt?: SortOrder;
    modifiedAt?: SortOrder;
    statusCode?: SortOrder;
  };

  export type usersMinOrderByAggregateInput = {
    userId?: SortOrder;
    username?: SortOrder;
    password?: SortOrder;
    createdAt?: SortOrder;
    modifiedAt?: SortOrder;
    statusCode?: SortOrder;
  };

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type UsersListRelationFilter = {
    every?: usersWhereInput;
    some?: usersWhereInput;
    none?: usersWhereInput;
  };

  export type AudioListRelationFilter = {
    every?: audioWhereInput;
    some?: audioWhereInput;
    none?: audioWhereInput;
  };

  export type ExhibitListRelationFilter = {
    every?: exhibitWhereInput;
    some?: exhibitWhereInput;
    none?: exhibitWhereInput;
  };

  export type RoleListRelationFilter = {
    every?: roleWhereInput;
    some?: roleWhereInput;
    none?: roleWhereInput;
  };

  export type QrCodeListRelationFilter = {
    every?: qrCodeWhereInput;
    some?: qrCodeWhereInput;
    none?: qrCodeWhereInput;
  };

  export type ImageListRelationFilter = {
    every?: imageWhereInput;
    some?: imageWhereInput;
    none?: imageWhereInput;
  };

  export type SubtitleListRelationFilter = {
    every?: subtitleWhereInput;
    some?: subtitleWhereInput;
    none?: subtitleWhereInput;
  };

  export type LanguageListRelationFilter = {
    every?: languageWhereInput;
    some?: languageWhereInput;
    none?: languageWhereInput;
  };

  export type UserProfileListRelationFilter = {
    every?: userProfileWhereInput;
    some?: userProfileWhereInput;
    none?: userProfileWhereInput;
  };

  export type usersOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type audioOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type exhibitOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type roleOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type qrCodeOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type imageOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type subtitleOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type languageOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type userProfileOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type statusCountOrderByAggregateInput = {
    statusCode?: SortOrder;
    description?: SortOrder;
  };

  export type statusMaxOrderByAggregateInput = {
    statusCode?: SortOrder;
    description?: SortOrder;
  };

  export type statusMinOrderByAggregateInput = {
    statusCode?: SortOrder;
    description?: SortOrder;
  };

  export type LanguageScalarRelationFilter = {
    is?: languageWhereInput;
    isNot?: languageWhereInput;
  };

  export type ExhibitAudioRelationListRelationFilter = {
    every?: exhibitAudioRelationWhereInput;
    some?: exhibitAudioRelationWhereInput;
    none?: exhibitAudioRelationWhereInput;
  };

  export type exhibitAudioRelationOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type audioCountOrderByAggregateInput = {
    audioId?: SortOrder;
    fileUrl?: SortOrder;
    description?: SortOrder;
    createdBy?: SortOrder;
    languageId?: SortOrder;
    createdAt?: SortOrder;
    statusCode?: SortOrder;
  };

  export type audioMaxOrderByAggregateInput = {
    audioId?: SortOrder;
    fileUrl?: SortOrder;
    description?: SortOrder;
    createdBy?: SortOrder;
    languageId?: SortOrder;
    createdAt?: SortOrder;
    statusCode?: SortOrder;
  };

  export type audioMinOrderByAggregateInput = {
    audioId?: SortOrder;
    fileUrl?: SortOrder;
    description?: SortOrder;
    createdBy?: SortOrder;
    languageId?: SortOrder;
    createdAt?: SortOrder;
    statusCode?: SortOrder;
  };

  export type AudioScalarRelationFilter = {
    is?: audioWhereInput;
    isNot?: audioWhereInput;
  };

  export type ExhibitScalarRelationFilter = {
    is?: exhibitWhereInput;
    isNot?: exhibitWhereInput;
  };

  export type exhibitAudioRelationAudioIdExhibitIdCompoundUniqueInput = {
    audioId: string;
    exhibitId: string;
  };

  export type exhibitAudioRelationCountOrderByAggregateInput = {
    audioId?: SortOrder;
    exhibitId?: SortOrder;
  };

  export type exhibitAudioRelationMaxOrderByAggregateInput = {
    audioId?: SortOrder;
    exhibitId?: SortOrder;
  };

  export type exhibitAudioRelationMinOrderByAggregateInput = {
    audioId?: SortOrder;
    exhibitId?: SortOrder;
  };

  export type QrCodeScalarRelationFilter = {
    is?: qrCodeWhereInput;
    isNot?: qrCodeWhereInput;
  };

  export type ImageScalarRelationFilter = {
    is?: imageWhereInput;
    isNot?: imageWhereInput;
  };

  export type ExhibitSubtitleListRelationFilter = {
    every?: exhibitSubtitleWhereInput;
    some?: exhibitSubtitleWhereInput;
    none?: exhibitSubtitleWhereInput;
  };

  export type exhibitSubtitleOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type exhibitCountOrderByAggregateInput = {
    exhibitId?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    audioId?: SortOrder;
    createdBy?: SortOrder;
    modifiedBy?: SortOrder;
    qrCodeId?: SortOrder;
    imageId?: SortOrder;
    createdAt?: SortOrder;
    modifiedAt?: SortOrder;
    statusCode?: SortOrder;
  };

  export type exhibitMaxOrderByAggregateInput = {
    exhibitId?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    audioId?: SortOrder;
    createdBy?: SortOrder;
    modifiedBy?: SortOrder;
    qrCodeId?: SortOrder;
    imageId?: SortOrder;
    createdAt?: SortOrder;
    modifiedAt?: SortOrder;
    statusCode?: SortOrder;
  };

  export type exhibitMinOrderByAggregateInput = {
    exhibitId?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    audioId?: SortOrder;
    createdBy?: SortOrder;
    modifiedBy?: SortOrder;
    qrCodeId?: SortOrder;
    imageId?: SortOrder;
    createdAt?: SortOrder;
    modifiedAt?: SortOrder;
    statusCode?: SortOrder;
  };

  export type UsersScalarRelationFilter = {
    is?: usersWhereInput;
    isNot?: usersWhereInput;
  };

  export type auditLogCountOrderByAggregateInput = {
    auditLogId?: SortOrder;
    userId?: SortOrder;
    ipAddress?: SortOrder;
    entityName?: SortOrder;
    entityId?: SortOrder;
    actionType?: SortOrder;
    oldValue?: SortOrder;
    newValue?: SortOrder;
    timestamp?: SortOrder;
    statusCode?: SortOrder;
  };

  export type auditLogMaxOrderByAggregateInput = {
    auditLogId?: SortOrder;
    userId?: SortOrder;
    ipAddress?: SortOrder;
    entityName?: SortOrder;
    entityId?: SortOrder;
    actionType?: SortOrder;
    oldValue?: SortOrder;
    newValue?: SortOrder;
    timestamp?: SortOrder;
    statusCode?: SortOrder;
  };

  export type auditLogMinOrderByAggregateInput = {
    auditLogId?: SortOrder;
    userId?: SortOrder;
    ipAddress?: SortOrder;
    entityName?: SortOrder;
    entityId?: SortOrder;
    actionType?: SortOrder;
    oldValue?: SortOrder;
    newValue?: SortOrder;
    timestamp?: SortOrder;
    statusCode?: SortOrder;
  };

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type phoneNumberCountOrderByAggregateInput = {
    phoneNumberId?: SortOrder;
    userId?: SortOrder;
    phoneNumber?: SortOrder;
    verified?: SortOrder;
    isPrimary?: SortOrder;
    createdAt?: SortOrder;
    statusCode?: SortOrder;
  };

  export type phoneNumberMaxOrderByAggregateInput = {
    phoneNumberId?: SortOrder;
    userId?: SortOrder;
    phoneNumber?: SortOrder;
    verified?: SortOrder;
    isPrimary?: SortOrder;
    createdAt?: SortOrder;
    statusCode?: SortOrder;
  };

  export type phoneNumberMinOrderByAggregateInput = {
    phoneNumberId?: SortOrder;
    userId?: SortOrder;
    phoneNumber?: SortOrder;
    verified?: SortOrder;
    isPrimary?: SortOrder;
    createdAt?: SortOrder;
    statusCode?: SortOrder;
  };

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type emailCountOrderByAggregateInput = {
    emailId?: SortOrder;
    userId?: SortOrder;
    email?: SortOrder;
    verified?: SortOrder;
    isPrimary?: SortOrder;
    createdAt?: SortOrder;
    statusCode?: SortOrder;
  };

  export type emailMaxOrderByAggregateInput = {
    emailId?: SortOrder;
    userId?: SortOrder;
    email?: SortOrder;
    verified?: SortOrder;
    isPrimary?: SortOrder;
    createdAt?: SortOrder;
    statusCode?: SortOrder;
  };

  export type emailMinOrderByAggregateInput = {
    emailId?: SortOrder;
    userId?: SortOrder;
    email?: SortOrder;
    verified?: SortOrder;
    isPrimary?: SortOrder;
    createdAt?: SortOrder;
    statusCode?: SortOrder;
  };

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type RoleScalarRelationFilter = {
    is?: roleWhereInput;
    isNot?: roleWhereInput;
  };

  export type userRoleUserIdRoleIdCompoundUniqueInput = {
    userId: string;
    roleId: number;
  };

  export type userRoleCountOrderByAggregateInput = {
    userId?: SortOrder;
    roleId?: SortOrder;
  };

  export type userRoleAvgOrderByAggregateInput = {
    roleId?: SortOrder;
  };

  export type userRoleMaxOrderByAggregateInput = {
    userId?: SortOrder;
    roleId?: SortOrder;
  };

  export type userRoleMinOrderByAggregateInput = {
    userId?: SortOrder;
    roleId?: SortOrder;
  };

  export type userRoleSumOrderByAggregateInput = {
    roleId?: SortOrder;
  };

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type roleCountOrderByAggregateInput = {
    roleId?: SortOrder;
    roleName?: SortOrder;
    description?: SortOrder;
    statusCode?: SortOrder;
  };

  export type roleAvgOrderByAggregateInput = {
    roleId?: SortOrder;
  };

  export type roleMaxOrderByAggregateInput = {
    roleId?: SortOrder;
    roleName?: SortOrder;
    description?: SortOrder;
    statusCode?: SortOrder;
  };

  export type roleMinOrderByAggregateInput = {
    roleId?: SortOrder;
    roleName?: SortOrder;
    description?: SortOrder;
    statusCode?: SortOrder;
  };

  export type roleSumOrderByAggregateInput = {
    roleId?: SortOrder;
  };

  export type qrCodeCountOrderByAggregateInput = {
    qrCodeId?: SortOrder;
    qrLink?: SortOrder;
    createdBy?: SortOrder;
    createdAt?: SortOrder;
    statusCode?: SortOrder;
  };

  export type qrCodeMaxOrderByAggregateInput = {
    qrCodeId?: SortOrder;
    qrLink?: SortOrder;
    createdBy?: SortOrder;
    createdAt?: SortOrder;
    statusCode?: SortOrder;
  };

  export type qrCodeMinOrderByAggregateInput = {
    qrCodeId?: SortOrder;
    qrLink?: SortOrder;
    createdBy?: SortOrder;
    createdAt?: SortOrder;
    statusCode?: SortOrder;
  };

  export type imageCountOrderByAggregateInput = {
    imageId?: SortOrder;
    description?: SortOrder;
    createdBy?: SortOrder;
    createdAt?: SortOrder;
    statusCode?: SortOrder;
  };

  export type imageMaxOrderByAggregateInput = {
    imageId?: SortOrder;
    description?: SortOrder;
    createdBy?: SortOrder;
    createdAt?: SortOrder;
    statusCode?: SortOrder;
  };

  export type imageMinOrderByAggregateInput = {
    imageId?: SortOrder;
    description?: SortOrder;
    createdBy?: SortOrder;
    createdAt?: SortOrder;
    statusCode?: SortOrder;
  };

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null;
  };

  export type SessionScalarRelationFilter = {
    is?: sessionWhereInput;
    isNot?: sessionWhereInput;
  };

  export type UsersNullableScalarRelationFilter = {
    is?: usersWhereInput | null;
    isNot?: usersWhereInput | null;
  };

  export type SortOrderInput = {
    sort: SortOrder;
    nulls?: NullsOrder;
  };

  export type eventCountOrderByAggregateInput = {
    eventId?: SortOrder;
    sessionId?: SortOrder;
    entityId?: SortOrder;
    entityName?: SortOrder;
    timestamp?: SortOrder;
    usersUserId?: SortOrder;
  };

  export type eventAvgOrderByAggregateInput = {
    entityId?: SortOrder;
  };

  export type eventMaxOrderByAggregateInput = {
    eventId?: SortOrder;
    sessionId?: SortOrder;
    entityId?: SortOrder;
    entityName?: SortOrder;
    timestamp?: SortOrder;
    usersUserId?: SortOrder;
  };

  export type eventMinOrderByAggregateInput = {
    eventId?: SortOrder;
    sessionId?: SortOrder;
    entityId?: SortOrder;
    entityName?: SortOrder;
    timestamp?: SortOrder;
    usersUserId?: SortOrder;
  };

  export type eventSumOrderByAggregateInput = {
    entityId?: SortOrder;
  };

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type sessionCountOrderByAggregateInput = {
    sessionId?: SortOrder;
    userId?: SortOrder;
    deviceInfo?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
  };

  export type sessionMaxOrderByAggregateInput = {
    sessionId?: SortOrder;
    userId?: SortOrder;
    deviceInfo?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
  };

  export type sessionMinOrderByAggregateInput = {
    sessionId?: SortOrder;
    userId?: SortOrder;
    deviceInfo?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
  };

  export type userProfileCountOrderByAggregateInput = {
    userProfileId?: SortOrder;
    userId?: SortOrder;
    fName?: SortOrder;
    lName?: SortOrder;
    languageCode?: SortOrder;
    gender?: SortOrder;
    dob?: SortOrder;
    modifiedBy?: SortOrder;
    createdBy?: SortOrder;
    createdAt?: SortOrder;
    modifiedAt?: SortOrder;
    statusCode?: SortOrder;
  };

  export type userProfileMaxOrderByAggregateInput = {
    userProfileId?: SortOrder;
    userId?: SortOrder;
    fName?: SortOrder;
    lName?: SortOrder;
    languageCode?: SortOrder;
    gender?: SortOrder;
    dob?: SortOrder;
    modifiedBy?: SortOrder;
    createdBy?: SortOrder;
    createdAt?: SortOrder;
    modifiedAt?: SortOrder;
    statusCode?: SortOrder;
  };

  export type userProfileMinOrderByAggregateInput = {
    userProfileId?: SortOrder;
    userId?: SortOrder;
    fName?: SortOrder;
    lName?: SortOrder;
    languageCode?: SortOrder;
    gender?: SortOrder;
    dob?: SortOrder;
    modifiedBy?: SortOrder;
    createdBy?: SortOrder;
    createdAt?: SortOrder;
    modifiedAt?: SortOrder;
    statusCode?: SortOrder;
  };

  export type languageCountOrderByAggregateInput = {
    languageCode?: SortOrder;
    languageName?: SortOrder;
    statusCode?: SortOrder;
  };

  export type languageMaxOrderByAggregateInput = {
    languageCode?: SortOrder;
    languageName?: SortOrder;
    statusCode?: SortOrder;
  };

  export type languageMinOrderByAggregateInput = {
    languageCode?: SortOrder;
    languageName?: SortOrder;
    statusCode?: SortOrder;
  };

  export type subtitleCountOrderByAggregateInput = {
    subtitleId?: SortOrder;
    subtitleText?: SortOrder;
    languageCode?: SortOrder;
    createdBy?: SortOrder;
    modifiedBy?: SortOrder;
    createdAt?: SortOrder;
    modifiedAt?: SortOrder;
    statusCode?: SortOrder;
  };

  export type subtitleMaxOrderByAggregateInput = {
    subtitleId?: SortOrder;
    subtitleText?: SortOrder;
    languageCode?: SortOrder;
    createdBy?: SortOrder;
    modifiedBy?: SortOrder;
    createdAt?: SortOrder;
    modifiedAt?: SortOrder;
    statusCode?: SortOrder;
  };

  export type subtitleMinOrderByAggregateInput = {
    subtitleId?: SortOrder;
    subtitleText?: SortOrder;
    languageCode?: SortOrder;
    createdBy?: SortOrder;
    modifiedBy?: SortOrder;
    createdAt?: SortOrder;
    modifiedAt?: SortOrder;
    statusCode?: SortOrder;
  };

  export type SubtitleScalarRelationFilter = {
    is?: subtitleWhereInput;
    isNot?: subtitleWhereInput;
  };

  export type exhibitSubtitleExhibitIdSubtitleIdCompoundUniqueInput = {
    exhibitId: string;
    subtitleId: string;
  };

  export type exhibitSubtitleCountOrderByAggregateInput = {
    exhibitId?: SortOrder;
    subtitleId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type exhibitSubtitleMaxOrderByAggregateInput = {
    exhibitId?: SortOrder;
    subtitleId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type exhibitSubtitleMinOrderByAggregateInput = {
    exhibitId?: SortOrder;
    subtitleId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type phoneNumberCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          phoneNumberCreateWithoutUserInput,
          phoneNumberUncheckedCreateWithoutUserInput
        >
      | phoneNumberCreateWithoutUserInput[]
      | phoneNumberUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | phoneNumberCreateOrConnectWithoutUserInput
      | phoneNumberCreateOrConnectWithoutUserInput[];
    createMany?: phoneNumberCreateManyUserInputEnvelope;
    connect?: phoneNumberWhereUniqueInput | phoneNumberWhereUniqueInput[];
  };

  export type emailCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<emailCreateWithoutUserInput, emailUncheckedCreateWithoutUserInput>
      | emailCreateWithoutUserInput[]
      | emailUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | emailCreateOrConnectWithoutUserInput
      | emailCreateOrConnectWithoutUserInput[];
    createMany?: emailCreateManyUserInputEnvelope;
    connect?: emailWhereUniqueInput | emailWhereUniqueInput[];
  };

  export type userProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<
      userProfileCreateWithoutUserInput,
      userProfileUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: userProfileCreateOrConnectWithoutUserInput;
    connect?: userProfileWhereUniqueInput;
  };

  export type sessionCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          sessionCreateWithoutUserInput,
          sessionUncheckedCreateWithoutUserInput
        >
      | sessionCreateWithoutUserInput[]
      | sessionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | sessionCreateOrConnectWithoutUserInput
      | sessionCreateOrConnectWithoutUserInput[];
    createMany?: sessionCreateManyUserInputEnvelope;
    connect?: sessionWhereUniqueInput | sessionWhereUniqueInput[];
  };

  export type auditLogCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          auditLogCreateWithoutUserInput,
          auditLogUncheckedCreateWithoutUserInput
        >
      | auditLogCreateWithoutUserInput[]
      | auditLogUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | auditLogCreateOrConnectWithoutUserInput
      | auditLogCreateOrConnectWithoutUserInput[];
    createMany?: auditLogCreateManyUserInputEnvelope;
    connect?: auditLogWhereUniqueInput | auditLogWhereUniqueInput[];
  };

  export type eventCreateNestedManyWithoutUsersInput = {
    create?:
      | XOR<eventCreateWithoutUsersInput, eventUncheckedCreateWithoutUsersInput>
      | eventCreateWithoutUsersInput[]
      | eventUncheckedCreateWithoutUsersInput[];
    connectOrCreate?:
      | eventCreateOrConnectWithoutUsersInput
      | eventCreateOrConnectWithoutUsersInput[];
    createMany?: eventCreateManyUsersInputEnvelope;
    connect?: eventWhereUniqueInput | eventWhereUniqueInput[];
  };

  export type userRoleCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          userRoleCreateWithoutUserInput,
          userRoleUncheckedCreateWithoutUserInput
        >
      | userRoleCreateWithoutUserInput[]
      | userRoleUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | userRoleCreateOrConnectWithoutUserInput
      | userRoleCreateOrConnectWithoutUserInput[];
    createMany?: userRoleCreateManyUserInputEnvelope;
    connect?: userRoleWhereUniqueInput | userRoleWhereUniqueInput[];
  };

  export type statusCreateNestedOneWithoutUsersInput = {
    create?: XOR<
      statusCreateWithoutUsersInput,
      statusUncheckedCreateWithoutUsersInput
    >;
    connectOrCreate?: statusCreateOrConnectWithoutUsersInput;
    connect?: statusWhereUniqueInput;
  };

  export type phoneNumberUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          phoneNumberCreateWithoutUserInput,
          phoneNumberUncheckedCreateWithoutUserInput
        >
      | phoneNumberCreateWithoutUserInput[]
      | phoneNumberUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | phoneNumberCreateOrConnectWithoutUserInput
      | phoneNumberCreateOrConnectWithoutUserInput[];
    createMany?: phoneNumberCreateManyUserInputEnvelope;
    connect?: phoneNumberWhereUniqueInput | phoneNumberWhereUniqueInput[];
  };

  export type emailUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<emailCreateWithoutUserInput, emailUncheckedCreateWithoutUserInput>
      | emailCreateWithoutUserInput[]
      | emailUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | emailCreateOrConnectWithoutUserInput
      | emailCreateOrConnectWithoutUserInput[];
    createMany?: emailCreateManyUserInputEnvelope;
    connect?: emailWhereUniqueInput | emailWhereUniqueInput[];
  };

  export type userProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<
      userProfileCreateWithoutUserInput,
      userProfileUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: userProfileCreateOrConnectWithoutUserInput;
    connect?: userProfileWhereUniqueInput;
  };

  export type sessionUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          sessionCreateWithoutUserInput,
          sessionUncheckedCreateWithoutUserInput
        >
      | sessionCreateWithoutUserInput[]
      | sessionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | sessionCreateOrConnectWithoutUserInput
      | sessionCreateOrConnectWithoutUserInput[];
    createMany?: sessionCreateManyUserInputEnvelope;
    connect?: sessionWhereUniqueInput | sessionWhereUniqueInput[];
  };

  export type auditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          auditLogCreateWithoutUserInput,
          auditLogUncheckedCreateWithoutUserInput
        >
      | auditLogCreateWithoutUserInput[]
      | auditLogUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | auditLogCreateOrConnectWithoutUserInput
      | auditLogCreateOrConnectWithoutUserInput[];
    createMany?: auditLogCreateManyUserInputEnvelope;
    connect?: auditLogWhereUniqueInput | auditLogWhereUniqueInput[];
  };

  export type eventUncheckedCreateNestedManyWithoutUsersInput = {
    create?:
      | XOR<eventCreateWithoutUsersInput, eventUncheckedCreateWithoutUsersInput>
      | eventCreateWithoutUsersInput[]
      | eventUncheckedCreateWithoutUsersInput[];
    connectOrCreate?:
      | eventCreateOrConnectWithoutUsersInput
      | eventCreateOrConnectWithoutUsersInput[];
    createMany?: eventCreateManyUsersInputEnvelope;
    connect?: eventWhereUniqueInput | eventWhereUniqueInput[];
  };

  export type userRoleUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          userRoleCreateWithoutUserInput,
          userRoleUncheckedCreateWithoutUserInput
        >
      | userRoleCreateWithoutUserInput[]
      | userRoleUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | userRoleCreateOrConnectWithoutUserInput
      | userRoleCreateOrConnectWithoutUserInput[];
    createMany?: userRoleCreateManyUserInputEnvelope;
    connect?: userRoleWhereUniqueInput | userRoleWhereUniqueInput[];
  };

  export type StringFieldUpdateOperationsInput = {
    set?: string;
  };

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string;
  };

  export type phoneNumberUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          phoneNumberCreateWithoutUserInput,
          phoneNumberUncheckedCreateWithoutUserInput
        >
      | phoneNumberCreateWithoutUserInput[]
      | phoneNumberUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | phoneNumberCreateOrConnectWithoutUserInput
      | phoneNumberCreateOrConnectWithoutUserInput[];
    upsert?:
      | phoneNumberUpsertWithWhereUniqueWithoutUserInput
      | phoneNumberUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: phoneNumberCreateManyUserInputEnvelope;
    set?: phoneNumberWhereUniqueInput | phoneNumberWhereUniqueInput[];
    disconnect?: phoneNumberWhereUniqueInput | phoneNumberWhereUniqueInput[];
    delete?: phoneNumberWhereUniqueInput | phoneNumberWhereUniqueInput[];
    connect?: phoneNumberWhereUniqueInput | phoneNumberWhereUniqueInput[];
    update?:
      | phoneNumberUpdateWithWhereUniqueWithoutUserInput
      | phoneNumberUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | phoneNumberUpdateManyWithWhereWithoutUserInput
      | phoneNumberUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: phoneNumberScalarWhereInput | phoneNumberScalarWhereInput[];
  };

  export type emailUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<emailCreateWithoutUserInput, emailUncheckedCreateWithoutUserInput>
      | emailCreateWithoutUserInput[]
      | emailUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | emailCreateOrConnectWithoutUserInput
      | emailCreateOrConnectWithoutUserInput[];
    upsert?:
      | emailUpsertWithWhereUniqueWithoutUserInput
      | emailUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: emailCreateManyUserInputEnvelope;
    set?: emailWhereUniqueInput | emailWhereUniqueInput[];
    disconnect?: emailWhereUniqueInput | emailWhereUniqueInput[];
    delete?: emailWhereUniqueInput | emailWhereUniqueInput[];
    connect?: emailWhereUniqueInput | emailWhereUniqueInput[];
    update?:
      | emailUpdateWithWhereUniqueWithoutUserInput
      | emailUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | emailUpdateManyWithWhereWithoutUserInput
      | emailUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: emailScalarWhereInput | emailScalarWhereInput[];
  };

  export type userProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<
      userProfileCreateWithoutUserInput,
      userProfileUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: userProfileCreateOrConnectWithoutUserInput;
    upsert?: userProfileUpsertWithoutUserInput;
    disconnect?: userProfileWhereInput | boolean;
    delete?: userProfileWhereInput | boolean;
    connect?: userProfileWhereUniqueInput;
    update?: XOR<
      XOR<
        userProfileUpdateToOneWithWhereWithoutUserInput,
        userProfileUpdateWithoutUserInput
      >,
      userProfileUncheckedUpdateWithoutUserInput
    >;
  };

  export type sessionUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          sessionCreateWithoutUserInput,
          sessionUncheckedCreateWithoutUserInput
        >
      | sessionCreateWithoutUserInput[]
      | sessionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | sessionCreateOrConnectWithoutUserInput
      | sessionCreateOrConnectWithoutUserInput[];
    upsert?:
      | sessionUpsertWithWhereUniqueWithoutUserInput
      | sessionUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: sessionCreateManyUserInputEnvelope;
    set?: sessionWhereUniqueInput | sessionWhereUniqueInput[];
    disconnect?: sessionWhereUniqueInput | sessionWhereUniqueInput[];
    delete?: sessionWhereUniqueInput | sessionWhereUniqueInput[];
    connect?: sessionWhereUniqueInput | sessionWhereUniqueInput[];
    update?:
      | sessionUpdateWithWhereUniqueWithoutUserInput
      | sessionUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | sessionUpdateManyWithWhereWithoutUserInput
      | sessionUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: sessionScalarWhereInput | sessionScalarWhereInput[];
  };

  export type auditLogUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          auditLogCreateWithoutUserInput,
          auditLogUncheckedCreateWithoutUserInput
        >
      | auditLogCreateWithoutUserInput[]
      | auditLogUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | auditLogCreateOrConnectWithoutUserInput
      | auditLogCreateOrConnectWithoutUserInput[];
    upsert?:
      | auditLogUpsertWithWhereUniqueWithoutUserInput
      | auditLogUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: auditLogCreateManyUserInputEnvelope;
    set?: auditLogWhereUniqueInput | auditLogWhereUniqueInput[];
    disconnect?: auditLogWhereUniqueInput | auditLogWhereUniqueInput[];
    delete?: auditLogWhereUniqueInput | auditLogWhereUniqueInput[];
    connect?: auditLogWhereUniqueInput | auditLogWhereUniqueInput[];
    update?:
      | auditLogUpdateWithWhereUniqueWithoutUserInput
      | auditLogUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | auditLogUpdateManyWithWhereWithoutUserInput
      | auditLogUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: auditLogScalarWhereInput | auditLogScalarWhereInput[];
  };

  export type eventUpdateManyWithoutUsersNestedInput = {
    create?:
      | XOR<eventCreateWithoutUsersInput, eventUncheckedCreateWithoutUsersInput>
      | eventCreateWithoutUsersInput[]
      | eventUncheckedCreateWithoutUsersInput[];
    connectOrCreate?:
      | eventCreateOrConnectWithoutUsersInput
      | eventCreateOrConnectWithoutUsersInput[];
    upsert?:
      | eventUpsertWithWhereUniqueWithoutUsersInput
      | eventUpsertWithWhereUniqueWithoutUsersInput[];
    createMany?: eventCreateManyUsersInputEnvelope;
    set?: eventWhereUniqueInput | eventWhereUniqueInput[];
    disconnect?: eventWhereUniqueInput | eventWhereUniqueInput[];
    delete?: eventWhereUniqueInput | eventWhereUniqueInput[];
    connect?: eventWhereUniqueInput | eventWhereUniqueInput[];
    update?:
      | eventUpdateWithWhereUniqueWithoutUsersInput
      | eventUpdateWithWhereUniqueWithoutUsersInput[];
    updateMany?:
      | eventUpdateManyWithWhereWithoutUsersInput
      | eventUpdateManyWithWhereWithoutUsersInput[];
    deleteMany?: eventScalarWhereInput | eventScalarWhereInput[];
  };

  export type userRoleUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          userRoleCreateWithoutUserInput,
          userRoleUncheckedCreateWithoutUserInput
        >
      | userRoleCreateWithoutUserInput[]
      | userRoleUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | userRoleCreateOrConnectWithoutUserInput
      | userRoleCreateOrConnectWithoutUserInput[];
    upsert?:
      | userRoleUpsertWithWhereUniqueWithoutUserInput
      | userRoleUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: userRoleCreateManyUserInputEnvelope;
    set?: userRoleWhereUniqueInput | userRoleWhereUniqueInput[];
    disconnect?: userRoleWhereUniqueInput | userRoleWhereUniqueInput[];
    delete?: userRoleWhereUniqueInput | userRoleWhereUniqueInput[];
    connect?: userRoleWhereUniqueInput | userRoleWhereUniqueInput[];
    update?:
      | userRoleUpdateWithWhereUniqueWithoutUserInput
      | userRoleUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | userRoleUpdateManyWithWhereWithoutUserInput
      | userRoleUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: userRoleScalarWhereInput | userRoleScalarWhereInput[];
  };

  export type statusUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<
      statusCreateWithoutUsersInput,
      statusUncheckedCreateWithoutUsersInput
    >;
    connectOrCreate?: statusCreateOrConnectWithoutUsersInput;
    upsert?: statusUpsertWithoutUsersInput;
    connect?: statusWhereUniqueInput;
    update?: XOR<
      XOR<
        statusUpdateToOneWithWhereWithoutUsersInput,
        statusUpdateWithoutUsersInput
      >,
      statusUncheckedUpdateWithoutUsersInput
    >;
  };

  export type phoneNumberUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          phoneNumberCreateWithoutUserInput,
          phoneNumberUncheckedCreateWithoutUserInput
        >
      | phoneNumberCreateWithoutUserInput[]
      | phoneNumberUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | phoneNumberCreateOrConnectWithoutUserInput
      | phoneNumberCreateOrConnectWithoutUserInput[];
    upsert?:
      | phoneNumberUpsertWithWhereUniqueWithoutUserInput
      | phoneNumberUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: phoneNumberCreateManyUserInputEnvelope;
    set?: phoneNumberWhereUniqueInput | phoneNumberWhereUniqueInput[];
    disconnect?: phoneNumberWhereUniqueInput | phoneNumberWhereUniqueInput[];
    delete?: phoneNumberWhereUniqueInput | phoneNumberWhereUniqueInput[];
    connect?: phoneNumberWhereUniqueInput | phoneNumberWhereUniqueInput[];
    update?:
      | phoneNumberUpdateWithWhereUniqueWithoutUserInput
      | phoneNumberUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | phoneNumberUpdateManyWithWhereWithoutUserInput
      | phoneNumberUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: phoneNumberScalarWhereInput | phoneNumberScalarWhereInput[];
  };

  export type emailUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<emailCreateWithoutUserInput, emailUncheckedCreateWithoutUserInput>
      | emailCreateWithoutUserInput[]
      | emailUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | emailCreateOrConnectWithoutUserInput
      | emailCreateOrConnectWithoutUserInput[];
    upsert?:
      | emailUpsertWithWhereUniqueWithoutUserInput
      | emailUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: emailCreateManyUserInputEnvelope;
    set?: emailWhereUniqueInput | emailWhereUniqueInput[];
    disconnect?: emailWhereUniqueInput | emailWhereUniqueInput[];
    delete?: emailWhereUniqueInput | emailWhereUniqueInput[];
    connect?: emailWhereUniqueInput | emailWhereUniqueInput[];
    update?:
      | emailUpdateWithWhereUniqueWithoutUserInput
      | emailUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | emailUpdateManyWithWhereWithoutUserInput
      | emailUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: emailScalarWhereInput | emailScalarWhereInput[];
  };

  export type userProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<
      userProfileCreateWithoutUserInput,
      userProfileUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: userProfileCreateOrConnectWithoutUserInput;
    upsert?: userProfileUpsertWithoutUserInput;
    disconnect?: userProfileWhereInput | boolean;
    delete?: userProfileWhereInput | boolean;
    connect?: userProfileWhereUniqueInput;
    update?: XOR<
      XOR<
        userProfileUpdateToOneWithWhereWithoutUserInput,
        userProfileUpdateWithoutUserInput
      >,
      userProfileUncheckedUpdateWithoutUserInput
    >;
  };

  export type sessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          sessionCreateWithoutUserInput,
          sessionUncheckedCreateWithoutUserInput
        >
      | sessionCreateWithoutUserInput[]
      | sessionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | sessionCreateOrConnectWithoutUserInput
      | sessionCreateOrConnectWithoutUserInput[];
    upsert?:
      | sessionUpsertWithWhereUniqueWithoutUserInput
      | sessionUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: sessionCreateManyUserInputEnvelope;
    set?: sessionWhereUniqueInput | sessionWhereUniqueInput[];
    disconnect?: sessionWhereUniqueInput | sessionWhereUniqueInput[];
    delete?: sessionWhereUniqueInput | sessionWhereUniqueInput[];
    connect?: sessionWhereUniqueInput | sessionWhereUniqueInput[];
    update?:
      | sessionUpdateWithWhereUniqueWithoutUserInput
      | sessionUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | sessionUpdateManyWithWhereWithoutUserInput
      | sessionUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: sessionScalarWhereInput | sessionScalarWhereInput[];
  };

  export type auditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          auditLogCreateWithoutUserInput,
          auditLogUncheckedCreateWithoutUserInput
        >
      | auditLogCreateWithoutUserInput[]
      | auditLogUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | auditLogCreateOrConnectWithoutUserInput
      | auditLogCreateOrConnectWithoutUserInput[];
    upsert?:
      | auditLogUpsertWithWhereUniqueWithoutUserInput
      | auditLogUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: auditLogCreateManyUserInputEnvelope;
    set?: auditLogWhereUniqueInput | auditLogWhereUniqueInput[];
    disconnect?: auditLogWhereUniqueInput | auditLogWhereUniqueInput[];
    delete?: auditLogWhereUniqueInput | auditLogWhereUniqueInput[];
    connect?: auditLogWhereUniqueInput | auditLogWhereUniqueInput[];
    update?:
      | auditLogUpdateWithWhereUniqueWithoutUserInput
      | auditLogUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | auditLogUpdateManyWithWhereWithoutUserInput
      | auditLogUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: auditLogScalarWhereInput | auditLogScalarWhereInput[];
  };

  export type eventUncheckedUpdateManyWithoutUsersNestedInput = {
    create?:
      | XOR<eventCreateWithoutUsersInput, eventUncheckedCreateWithoutUsersInput>
      | eventCreateWithoutUsersInput[]
      | eventUncheckedCreateWithoutUsersInput[];
    connectOrCreate?:
      | eventCreateOrConnectWithoutUsersInput
      | eventCreateOrConnectWithoutUsersInput[];
    upsert?:
      | eventUpsertWithWhereUniqueWithoutUsersInput
      | eventUpsertWithWhereUniqueWithoutUsersInput[];
    createMany?: eventCreateManyUsersInputEnvelope;
    set?: eventWhereUniqueInput | eventWhereUniqueInput[];
    disconnect?: eventWhereUniqueInput | eventWhereUniqueInput[];
    delete?: eventWhereUniqueInput | eventWhereUniqueInput[];
    connect?: eventWhereUniqueInput | eventWhereUniqueInput[];
    update?:
      | eventUpdateWithWhereUniqueWithoutUsersInput
      | eventUpdateWithWhereUniqueWithoutUsersInput[];
    updateMany?:
      | eventUpdateManyWithWhereWithoutUsersInput
      | eventUpdateManyWithWhereWithoutUsersInput[];
    deleteMany?: eventScalarWhereInput | eventScalarWhereInput[];
  };

  export type userRoleUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          userRoleCreateWithoutUserInput,
          userRoleUncheckedCreateWithoutUserInput
        >
      | userRoleCreateWithoutUserInput[]
      | userRoleUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | userRoleCreateOrConnectWithoutUserInput
      | userRoleCreateOrConnectWithoutUserInput[];
    upsert?:
      | userRoleUpsertWithWhereUniqueWithoutUserInput
      | userRoleUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: userRoleCreateManyUserInputEnvelope;
    set?: userRoleWhereUniqueInput | userRoleWhereUniqueInput[];
    disconnect?: userRoleWhereUniqueInput | userRoleWhereUniqueInput[];
    delete?: userRoleWhereUniqueInput | userRoleWhereUniqueInput[];
    connect?: userRoleWhereUniqueInput | userRoleWhereUniqueInput[];
    update?:
      | userRoleUpdateWithWhereUniqueWithoutUserInput
      | userRoleUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | userRoleUpdateManyWithWhereWithoutUserInput
      | userRoleUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: userRoleScalarWhereInput | userRoleScalarWhereInput[];
  };

  export type usersCreateNestedManyWithoutStatusInput = {
    create?:
      | XOR<
          usersCreateWithoutStatusInput,
          usersUncheckedCreateWithoutStatusInput
        >
      | usersCreateWithoutStatusInput[]
      | usersUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | usersCreateOrConnectWithoutStatusInput
      | usersCreateOrConnectWithoutStatusInput[];
    createMany?: usersCreateManyStatusInputEnvelope;
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[];
  };

  export type audioCreateNestedManyWithoutStatusInput = {
    create?:
      | XOR<
          audioCreateWithoutStatusInput,
          audioUncheckedCreateWithoutStatusInput
        >
      | audioCreateWithoutStatusInput[]
      | audioUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | audioCreateOrConnectWithoutStatusInput
      | audioCreateOrConnectWithoutStatusInput[];
    createMany?: audioCreateManyStatusInputEnvelope;
    connect?: audioWhereUniqueInput | audioWhereUniqueInput[];
  };

  export type exhibitCreateNestedManyWithoutStatusInput = {
    create?:
      | XOR<
          exhibitCreateWithoutStatusInput,
          exhibitUncheckedCreateWithoutStatusInput
        >
      | exhibitCreateWithoutStatusInput[]
      | exhibitUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | exhibitCreateOrConnectWithoutStatusInput
      | exhibitCreateOrConnectWithoutStatusInput[];
    createMany?: exhibitCreateManyStatusInputEnvelope;
    connect?: exhibitWhereUniqueInput | exhibitWhereUniqueInput[];
  };

  export type phoneNumberCreateNestedManyWithoutStatusInput = {
    create?:
      | XOR<
          phoneNumberCreateWithoutStatusInput,
          phoneNumberUncheckedCreateWithoutStatusInput
        >
      | phoneNumberCreateWithoutStatusInput[]
      | phoneNumberUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | phoneNumberCreateOrConnectWithoutStatusInput
      | phoneNumberCreateOrConnectWithoutStatusInput[];
    createMany?: phoneNumberCreateManyStatusInputEnvelope;
    connect?: phoneNumberWhereUniqueInput | phoneNumberWhereUniqueInput[];
  };

  export type emailCreateNestedManyWithoutStatusInput = {
    create?:
      | XOR<
          emailCreateWithoutStatusInput,
          emailUncheckedCreateWithoutStatusInput
        >
      | emailCreateWithoutStatusInput[]
      | emailUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | emailCreateOrConnectWithoutStatusInput
      | emailCreateOrConnectWithoutStatusInput[];
    createMany?: emailCreateManyStatusInputEnvelope;
    connect?: emailWhereUniqueInput | emailWhereUniqueInput[];
  };

  export type roleCreateNestedManyWithoutStatusInput = {
    create?:
      | XOR<roleCreateWithoutStatusInput, roleUncheckedCreateWithoutStatusInput>
      | roleCreateWithoutStatusInput[]
      | roleUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | roleCreateOrConnectWithoutStatusInput
      | roleCreateOrConnectWithoutStatusInput[];
    createMany?: roleCreateManyStatusInputEnvelope;
    connect?: roleWhereUniqueInput | roleWhereUniqueInput[];
  };

  export type qrCodeCreateNestedManyWithoutStatusInput = {
    create?:
      | XOR<
          qrCodeCreateWithoutStatusInput,
          qrCodeUncheckedCreateWithoutStatusInput
        >
      | qrCodeCreateWithoutStatusInput[]
      | qrCodeUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | qrCodeCreateOrConnectWithoutStatusInput
      | qrCodeCreateOrConnectWithoutStatusInput[];
    createMany?: qrCodeCreateManyStatusInputEnvelope;
    connect?: qrCodeWhereUniqueInput | qrCodeWhereUniqueInput[];
  };

  export type imageCreateNestedManyWithoutStatusInput = {
    create?:
      | XOR<
          imageCreateWithoutStatusInput,
          imageUncheckedCreateWithoutStatusInput
        >
      | imageCreateWithoutStatusInput[]
      | imageUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | imageCreateOrConnectWithoutStatusInput
      | imageCreateOrConnectWithoutStatusInput[];
    createMany?: imageCreateManyStatusInputEnvelope;
    connect?: imageWhereUniqueInput | imageWhereUniqueInput[];
  };

  export type subtitleCreateNestedManyWithoutStatusInput = {
    create?:
      | XOR<
          subtitleCreateWithoutStatusInput,
          subtitleUncheckedCreateWithoutStatusInput
        >
      | subtitleCreateWithoutStatusInput[]
      | subtitleUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | subtitleCreateOrConnectWithoutStatusInput
      | subtitleCreateOrConnectWithoutStatusInput[];
    createMany?: subtitleCreateManyStatusInputEnvelope;
    connect?: subtitleWhereUniqueInput | subtitleWhereUniqueInput[];
  };

  export type languageCreateNestedManyWithoutStatusInput = {
    create?:
      | XOR<
          languageCreateWithoutStatusInput,
          languageUncheckedCreateWithoutStatusInput
        >
      | languageCreateWithoutStatusInput[]
      | languageUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | languageCreateOrConnectWithoutStatusInput
      | languageCreateOrConnectWithoutStatusInput[];
    createMany?: languageCreateManyStatusInputEnvelope;
    connect?: languageWhereUniqueInput | languageWhereUniqueInput[];
  };

  export type auditLogCreateNestedManyWithoutStatusInput = {
    create?:
      | XOR<
          auditLogCreateWithoutStatusInput,
          auditLogUncheckedCreateWithoutStatusInput
        >
      | auditLogCreateWithoutStatusInput[]
      | auditLogUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | auditLogCreateOrConnectWithoutStatusInput
      | auditLogCreateOrConnectWithoutStatusInput[];
    createMany?: auditLogCreateManyStatusInputEnvelope;
    connect?: auditLogWhereUniqueInput | auditLogWhereUniqueInput[];
  };

  export type userProfileCreateNestedManyWithoutStatusInput = {
    create?:
      | XOR<
          userProfileCreateWithoutStatusInput,
          userProfileUncheckedCreateWithoutStatusInput
        >
      | userProfileCreateWithoutStatusInput[]
      | userProfileUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | userProfileCreateOrConnectWithoutStatusInput
      | userProfileCreateOrConnectWithoutStatusInput[];
    createMany?: userProfileCreateManyStatusInputEnvelope;
    connect?: userProfileWhereUniqueInput | userProfileWhereUniqueInput[];
  };

  export type usersUncheckedCreateNestedManyWithoutStatusInput = {
    create?:
      | XOR<
          usersCreateWithoutStatusInput,
          usersUncheckedCreateWithoutStatusInput
        >
      | usersCreateWithoutStatusInput[]
      | usersUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | usersCreateOrConnectWithoutStatusInput
      | usersCreateOrConnectWithoutStatusInput[];
    createMany?: usersCreateManyStatusInputEnvelope;
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[];
  };

  export type audioUncheckedCreateNestedManyWithoutStatusInput = {
    create?:
      | XOR<
          audioCreateWithoutStatusInput,
          audioUncheckedCreateWithoutStatusInput
        >
      | audioCreateWithoutStatusInput[]
      | audioUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | audioCreateOrConnectWithoutStatusInput
      | audioCreateOrConnectWithoutStatusInput[];
    createMany?: audioCreateManyStatusInputEnvelope;
    connect?: audioWhereUniqueInput | audioWhereUniqueInput[];
  };

  export type exhibitUncheckedCreateNestedManyWithoutStatusInput = {
    create?:
      | XOR<
          exhibitCreateWithoutStatusInput,
          exhibitUncheckedCreateWithoutStatusInput
        >
      | exhibitCreateWithoutStatusInput[]
      | exhibitUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | exhibitCreateOrConnectWithoutStatusInput
      | exhibitCreateOrConnectWithoutStatusInput[];
    createMany?: exhibitCreateManyStatusInputEnvelope;
    connect?: exhibitWhereUniqueInput | exhibitWhereUniqueInput[];
  };

  export type phoneNumberUncheckedCreateNestedManyWithoutStatusInput = {
    create?:
      | XOR<
          phoneNumberCreateWithoutStatusInput,
          phoneNumberUncheckedCreateWithoutStatusInput
        >
      | phoneNumberCreateWithoutStatusInput[]
      | phoneNumberUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | phoneNumberCreateOrConnectWithoutStatusInput
      | phoneNumberCreateOrConnectWithoutStatusInput[];
    createMany?: phoneNumberCreateManyStatusInputEnvelope;
    connect?: phoneNumberWhereUniqueInput | phoneNumberWhereUniqueInput[];
  };

  export type emailUncheckedCreateNestedManyWithoutStatusInput = {
    create?:
      | XOR<
          emailCreateWithoutStatusInput,
          emailUncheckedCreateWithoutStatusInput
        >
      | emailCreateWithoutStatusInput[]
      | emailUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | emailCreateOrConnectWithoutStatusInput
      | emailCreateOrConnectWithoutStatusInput[];
    createMany?: emailCreateManyStatusInputEnvelope;
    connect?: emailWhereUniqueInput | emailWhereUniqueInput[];
  };

  export type roleUncheckedCreateNestedManyWithoutStatusInput = {
    create?:
      | XOR<roleCreateWithoutStatusInput, roleUncheckedCreateWithoutStatusInput>
      | roleCreateWithoutStatusInput[]
      | roleUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | roleCreateOrConnectWithoutStatusInput
      | roleCreateOrConnectWithoutStatusInput[];
    createMany?: roleCreateManyStatusInputEnvelope;
    connect?: roleWhereUniqueInput | roleWhereUniqueInput[];
  };

  export type qrCodeUncheckedCreateNestedManyWithoutStatusInput = {
    create?:
      | XOR<
          qrCodeCreateWithoutStatusInput,
          qrCodeUncheckedCreateWithoutStatusInput
        >
      | qrCodeCreateWithoutStatusInput[]
      | qrCodeUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | qrCodeCreateOrConnectWithoutStatusInput
      | qrCodeCreateOrConnectWithoutStatusInput[];
    createMany?: qrCodeCreateManyStatusInputEnvelope;
    connect?: qrCodeWhereUniqueInput | qrCodeWhereUniqueInput[];
  };

  export type imageUncheckedCreateNestedManyWithoutStatusInput = {
    create?:
      | XOR<
          imageCreateWithoutStatusInput,
          imageUncheckedCreateWithoutStatusInput
        >
      | imageCreateWithoutStatusInput[]
      | imageUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | imageCreateOrConnectWithoutStatusInput
      | imageCreateOrConnectWithoutStatusInput[];
    createMany?: imageCreateManyStatusInputEnvelope;
    connect?: imageWhereUniqueInput | imageWhereUniqueInput[];
  };

  export type subtitleUncheckedCreateNestedManyWithoutStatusInput = {
    create?:
      | XOR<
          subtitleCreateWithoutStatusInput,
          subtitleUncheckedCreateWithoutStatusInput
        >
      | subtitleCreateWithoutStatusInput[]
      | subtitleUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | subtitleCreateOrConnectWithoutStatusInput
      | subtitleCreateOrConnectWithoutStatusInput[];
    createMany?: subtitleCreateManyStatusInputEnvelope;
    connect?: subtitleWhereUniqueInput | subtitleWhereUniqueInput[];
  };

  export type languageUncheckedCreateNestedManyWithoutStatusInput = {
    create?:
      | XOR<
          languageCreateWithoutStatusInput,
          languageUncheckedCreateWithoutStatusInput
        >
      | languageCreateWithoutStatusInput[]
      | languageUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | languageCreateOrConnectWithoutStatusInput
      | languageCreateOrConnectWithoutStatusInput[];
    createMany?: languageCreateManyStatusInputEnvelope;
    connect?: languageWhereUniqueInput | languageWhereUniqueInput[];
  };

  export type auditLogUncheckedCreateNestedManyWithoutStatusInput = {
    create?:
      | XOR<
          auditLogCreateWithoutStatusInput,
          auditLogUncheckedCreateWithoutStatusInput
        >
      | auditLogCreateWithoutStatusInput[]
      | auditLogUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | auditLogCreateOrConnectWithoutStatusInput
      | auditLogCreateOrConnectWithoutStatusInput[];
    createMany?: auditLogCreateManyStatusInputEnvelope;
    connect?: auditLogWhereUniqueInput | auditLogWhereUniqueInput[];
  };

  export type userProfileUncheckedCreateNestedManyWithoutStatusInput = {
    create?:
      | XOR<
          userProfileCreateWithoutStatusInput,
          userProfileUncheckedCreateWithoutStatusInput
        >
      | userProfileCreateWithoutStatusInput[]
      | userProfileUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | userProfileCreateOrConnectWithoutStatusInput
      | userProfileCreateOrConnectWithoutStatusInput[];
    createMany?: userProfileCreateManyStatusInputEnvelope;
    connect?: userProfileWhereUniqueInput | userProfileWhereUniqueInput[];
  };

  export type usersUpdateManyWithoutStatusNestedInput = {
    create?:
      | XOR<
          usersCreateWithoutStatusInput,
          usersUncheckedCreateWithoutStatusInput
        >
      | usersCreateWithoutStatusInput[]
      | usersUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | usersCreateOrConnectWithoutStatusInput
      | usersCreateOrConnectWithoutStatusInput[];
    upsert?:
      | usersUpsertWithWhereUniqueWithoutStatusInput
      | usersUpsertWithWhereUniqueWithoutStatusInput[];
    createMany?: usersCreateManyStatusInputEnvelope;
    set?: usersWhereUniqueInput | usersWhereUniqueInput[];
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[];
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[];
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[];
    update?:
      | usersUpdateWithWhereUniqueWithoutStatusInput
      | usersUpdateWithWhereUniqueWithoutStatusInput[];
    updateMany?:
      | usersUpdateManyWithWhereWithoutStatusInput
      | usersUpdateManyWithWhereWithoutStatusInput[];
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[];
  };

  export type audioUpdateManyWithoutStatusNestedInput = {
    create?:
      | XOR<
          audioCreateWithoutStatusInput,
          audioUncheckedCreateWithoutStatusInput
        >
      | audioCreateWithoutStatusInput[]
      | audioUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | audioCreateOrConnectWithoutStatusInput
      | audioCreateOrConnectWithoutStatusInput[];
    upsert?:
      | audioUpsertWithWhereUniqueWithoutStatusInput
      | audioUpsertWithWhereUniqueWithoutStatusInput[];
    createMany?: audioCreateManyStatusInputEnvelope;
    set?: audioWhereUniqueInput | audioWhereUniqueInput[];
    disconnect?: audioWhereUniqueInput | audioWhereUniqueInput[];
    delete?: audioWhereUniqueInput | audioWhereUniqueInput[];
    connect?: audioWhereUniqueInput | audioWhereUniqueInput[];
    update?:
      | audioUpdateWithWhereUniqueWithoutStatusInput
      | audioUpdateWithWhereUniqueWithoutStatusInput[];
    updateMany?:
      | audioUpdateManyWithWhereWithoutStatusInput
      | audioUpdateManyWithWhereWithoutStatusInput[];
    deleteMany?: audioScalarWhereInput | audioScalarWhereInput[];
  };

  export type exhibitUpdateManyWithoutStatusNestedInput = {
    create?:
      | XOR<
          exhibitCreateWithoutStatusInput,
          exhibitUncheckedCreateWithoutStatusInput
        >
      | exhibitCreateWithoutStatusInput[]
      | exhibitUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | exhibitCreateOrConnectWithoutStatusInput
      | exhibitCreateOrConnectWithoutStatusInput[];
    upsert?:
      | exhibitUpsertWithWhereUniqueWithoutStatusInput
      | exhibitUpsertWithWhereUniqueWithoutStatusInput[];
    createMany?: exhibitCreateManyStatusInputEnvelope;
    set?: exhibitWhereUniqueInput | exhibitWhereUniqueInput[];
    disconnect?: exhibitWhereUniqueInput | exhibitWhereUniqueInput[];
    delete?: exhibitWhereUniqueInput | exhibitWhereUniqueInput[];
    connect?: exhibitWhereUniqueInput | exhibitWhereUniqueInput[];
    update?:
      | exhibitUpdateWithWhereUniqueWithoutStatusInput
      | exhibitUpdateWithWhereUniqueWithoutStatusInput[];
    updateMany?:
      | exhibitUpdateManyWithWhereWithoutStatusInput
      | exhibitUpdateManyWithWhereWithoutStatusInput[];
    deleteMany?: exhibitScalarWhereInput | exhibitScalarWhereInput[];
  };

  export type phoneNumberUpdateManyWithoutStatusNestedInput = {
    create?:
      | XOR<
          phoneNumberCreateWithoutStatusInput,
          phoneNumberUncheckedCreateWithoutStatusInput
        >
      | phoneNumberCreateWithoutStatusInput[]
      | phoneNumberUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | phoneNumberCreateOrConnectWithoutStatusInput
      | phoneNumberCreateOrConnectWithoutStatusInput[];
    upsert?:
      | phoneNumberUpsertWithWhereUniqueWithoutStatusInput
      | phoneNumberUpsertWithWhereUniqueWithoutStatusInput[];
    createMany?: phoneNumberCreateManyStatusInputEnvelope;
    set?: phoneNumberWhereUniqueInput | phoneNumberWhereUniqueInput[];
    disconnect?: phoneNumberWhereUniqueInput | phoneNumberWhereUniqueInput[];
    delete?: phoneNumberWhereUniqueInput | phoneNumberWhereUniqueInput[];
    connect?: phoneNumberWhereUniqueInput | phoneNumberWhereUniqueInput[];
    update?:
      | phoneNumberUpdateWithWhereUniqueWithoutStatusInput
      | phoneNumberUpdateWithWhereUniqueWithoutStatusInput[];
    updateMany?:
      | phoneNumberUpdateManyWithWhereWithoutStatusInput
      | phoneNumberUpdateManyWithWhereWithoutStatusInput[];
    deleteMany?: phoneNumberScalarWhereInput | phoneNumberScalarWhereInput[];
  };

  export type emailUpdateManyWithoutStatusNestedInput = {
    create?:
      | XOR<
          emailCreateWithoutStatusInput,
          emailUncheckedCreateWithoutStatusInput
        >
      | emailCreateWithoutStatusInput[]
      | emailUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | emailCreateOrConnectWithoutStatusInput
      | emailCreateOrConnectWithoutStatusInput[];
    upsert?:
      | emailUpsertWithWhereUniqueWithoutStatusInput
      | emailUpsertWithWhereUniqueWithoutStatusInput[];
    createMany?: emailCreateManyStatusInputEnvelope;
    set?: emailWhereUniqueInput | emailWhereUniqueInput[];
    disconnect?: emailWhereUniqueInput | emailWhereUniqueInput[];
    delete?: emailWhereUniqueInput | emailWhereUniqueInput[];
    connect?: emailWhereUniqueInput | emailWhereUniqueInput[];
    update?:
      | emailUpdateWithWhereUniqueWithoutStatusInput
      | emailUpdateWithWhereUniqueWithoutStatusInput[];
    updateMany?:
      | emailUpdateManyWithWhereWithoutStatusInput
      | emailUpdateManyWithWhereWithoutStatusInput[];
    deleteMany?: emailScalarWhereInput | emailScalarWhereInput[];
  };

  export type roleUpdateManyWithoutStatusNestedInput = {
    create?:
      | XOR<roleCreateWithoutStatusInput, roleUncheckedCreateWithoutStatusInput>
      | roleCreateWithoutStatusInput[]
      | roleUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | roleCreateOrConnectWithoutStatusInput
      | roleCreateOrConnectWithoutStatusInput[];
    upsert?:
      | roleUpsertWithWhereUniqueWithoutStatusInput
      | roleUpsertWithWhereUniqueWithoutStatusInput[];
    createMany?: roleCreateManyStatusInputEnvelope;
    set?: roleWhereUniqueInput | roleWhereUniqueInput[];
    disconnect?: roleWhereUniqueInput | roleWhereUniqueInput[];
    delete?: roleWhereUniqueInput | roleWhereUniqueInput[];
    connect?: roleWhereUniqueInput | roleWhereUniqueInput[];
    update?:
      | roleUpdateWithWhereUniqueWithoutStatusInput
      | roleUpdateWithWhereUniqueWithoutStatusInput[];
    updateMany?:
      | roleUpdateManyWithWhereWithoutStatusInput
      | roleUpdateManyWithWhereWithoutStatusInput[];
    deleteMany?: roleScalarWhereInput | roleScalarWhereInput[];
  };

  export type qrCodeUpdateManyWithoutStatusNestedInput = {
    create?:
      | XOR<
          qrCodeCreateWithoutStatusInput,
          qrCodeUncheckedCreateWithoutStatusInput
        >
      | qrCodeCreateWithoutStatusInput[]
      | qrCodeUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | qrCodeCreateOrConnectWithoutStatusInput
      | qrCodeCreateOrConnectWithoutStatusInput[];
    upsert?:
      | qrCodeUpsertWithWhereUniqueWithoutStatusInput
      | qrCodeUpsertWithWhereUniqueWithoutStatusInput[];
    createMany?: qrCodeCreateManyStatusInputEnvelope;
    set?: qrCodeWhereUniqueInput | qrCodeWhereUniqueInput[];
    disconnect?: qrCodeWhereUniqueInput | qrCodeWhereUniqueInput[];
    delete?: qrCodeWhereUniqueInput | qrCodeWhereUniqueInput[];
    connect?: qrCodeWhereUniqueInput | qrCodeWhereUniqueInput[];
    update?:
      | qrCodeUpdateWithWhereUniqueWithoutStatusInput
      | qrCodeUpdateWithWhereUniqueWithoutStatusInput[];
    updateMany?:
      | qrCodeUpdateManyWithWhereWithoutStatusInput
      | qrCodeUpdateManyWithWhereWithoutStatusInput[];
    deleteMany?: qrCodeScalarWhereInput | qrCodeScalarWhereInput[];
  };

  export type imageUpdateManyWithoutStatusNestedInput = {
    create?:
      | XOR<
          imageCreateWithoutStatusInput,
          imageUncheckedCreateWithoutStatusInput
        >
      | imageCreateWithoutStatusInput[]
      | imageUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | imageCreateOrConnectWithoutStatusInput
      | imageCreateOrConnectWithoutStatusInput[];
    upsert?:
      | imageUpsertWithWhereUniqueWithoutStatusInput
      | imageUpsertWithWhereUniqueWithoutStatusInput[];
    createMany?: imageCreateManyStatusInputEnvelope;
    set?: imageWhereUniqueInput | imageWhereUniqueInput[];
    disconnect?: imageWhereUniqueInput | imageWhereUniqueInput[];
    delete?: imageWhereUniqueInput | imageWhereUniqueInput[];
    connect?: imageWhereUniqueInput | imageWhereUniqueInput[];
    update?:
      | imageUpdateWithWhereUniqueWithoutStatusInput
      | imageUpdateWithWhereUniqueWithoutStatusInput[];
    updateMany?:
      | imageUpdateManyWithWhereWithoutStatusInput
      | imageUpdateManyWithWhereWithoutStatusInput[];
    deleteMany?: imageScalarWhereInput | imageScalarWhereInput[];
  };

  export type subtitleUpdateManyWithoutStatusNestedInput = {
    create?:
      | XOR<
          subtitleCreateWithoutStatusInput,
          subtitleUncheckedCreateWithoutStatusInput
        >
      | subtitleCreateWithoutStatusInput[]
      | subtitleUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | subtitleCreateOrConnectWithoutStatusInput
      | subtitleCreateOrConnectWithoutStatusInput[];
    upsert?:
      | subtitleUpsertWithWhereUniqueWithoutStatusInput
      | subtitleUpsertWithWhereUniqueWithoutStatusInput[];
    createMany?: subtitleCreateManyStatusInputEnvelope;
    set?: subtitleWhereUniqueInput | subtitleWhereUniqueInput[];
    disconnect?: subtitleWhereUniqueInput | subtitleWhereUniqueInput[];
    delete?: subtitleWhereUniqueInput | subtitleWhereUniqueInput[];
    connect?: subtitleWhereUniqueInput | subtitleWhereUniqueInput[];
    update?:
      | subtitleUpdateWithWhereUniqueWithoutStatusInput
      | subtitleUpdateWithWhereUniqueWithoutStatusInput[];
    updateMany?:
      | subtitleUpdateManyWithWhereWithoutStatusInput
      | subtitleUpdateManyWithWhereWithoutStatusInput[];
    deleteMany?: subtitleScalarWhereInput | subtitleScalarWhereInput[];
  };

  export type languageUpdateManyWithoutStatusNestedInput = {
    create?:
      | XOR<
          languageCreateWithoutStatusInput,
          languageUncheckedCreateWithoutStatusInput
        >
      | languageCreateWithoutStatusInput[]
      | languageUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | languageCreateOrConnectWithoutStatusInput
      | languageCreateOrConnectWithoutStatusInput[];
    upsert?:
      | languageUpsertWithWhereUniqueWithoutStatusInput
      | languageUpsertWithWhereUniqueWithoutStatusInput[];
    createMany?: languageCreateManyStatusInputEnvelope;
    set?: languageWhereUniqueInput | languageWhereUniqueInput[];
    disconnect?: languageWhereUniqueInput | languageWhereUniqueInput[];
    delete?: languageWhereUniqueInput | languageWhereUniqueInput[];
    connect?: languageWhereUniqueInput | languageWhereUniqueInput[];
    update?:
      | languageUpdateWithWhereUniqueWithoutStatusInput
      | languageUpdateWithWhereUniqueWithoutStatusInput[];
    updateMany?:
      | languageUpdateManyWithWhereWithoutStatusInput
      | languageUpdateManyWithWhereWithoutStatusInput[];
    deleteMany?: languageScalarWhereInput | languageScalarWhereInput[];
  };

  export type auditLogUpdateManyWithoutStatusNestedInput = {
    create?:
      | XOR<
          auditLogCreateWithoutStatusInput,
          auditLogUncheckedCreateWithoutStatusInput
        >
      | auditLogCreateWithoutStatusInput[]
      | auditLogUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | auditLogCreateOrConnectWithoutStatusInput
      | auditLogCreateOrConnectWithoutStatusInput[];
    upsert?:
      | auditLogUpsertWithWhereUniqueWithoutStatusInput
      | auditLogUpsertWithWhereUniqueWithoutStatusInput[];
    createMany?: auditLogCreateManyStatusInputEnvelope;
    set?: auditLogWhereUniqueInput | auditLogWhereUniqueInput[];
    disconnect?: auditLogWhereUniqueInput | auditLogWhereUniqueInput[];
    delete?: auditLogWhereUniqueInput | auditLogWhereUniqueInput[];
    connect?: auditLogWhereUniqueInput | auditLogWhereUniqueInput[];
    update?:
      | auditLogUpdateWithWhereUniqueWithoutStatusInput
      | auditLogUpdateWithWhereUniqueWithoutStatusInput[];
    updateMany?:
      | auditLogUpdateManyWithWhereWithoutStatusInput
      | auditLogUpdateManyWithWhereWithoutStatusInput[];
    deleteMany?: auditLogScalarWhereInput | auditLogScalarWhereInput[];
  };

  export type userProfileUpdateManyWithoutStatusNestedInput = {
    create?:
      | XOR<
          userProfileCreateWithoutStatusInput,
          userProfileUncheckedCreateWithoutStatusInput
        >
      | userProfileCreateWithoutStatusInput[]
      | userProfileUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | userProfileCreateOrConnectWithoutStatusInput
      | userProfileCreateOrConnectWithoutStatusInput[];
    upsert?:
      | userProfileUpsertWithWhereUniqueWithoutStatusInput
      | userProfileUpsertWithWhereUniqueWithoutStatusInput[];
    createMany?: userProfileCreateManyStatusInputEnvelope;
    set?: userProfileWhereUniqueInput | userProfileWhereUniqueInput[];
    disconnect?: userProfileWhereUniqueInput | userProfileWhereUniqueInput[];
    delete?: userProfileWhereUniqueInput | userProfileWhereUniqueInput[];
    connect?: userProfileWhereUniqueInput | userProfileWhereUniqueInput[];
    update?:
      | userProfileUpdateWithWhereUniqueWithoutStatusInput
      | userProfileUpdateWithWhereUniqueWithoutStatusInput[];
    updateMany?:
      | userProfileUpdateManyWithWhereWithoutStatusInput
      | userProfileUpdateManyWithWhereWithoutStatusInput[];
    deleteMany?: userProfileScalarWhereInput | userProfileScalarWhereInput[];
  };

  export type usersUncheckedUpdateManyWithoutStatusNestedInput = {
    create?:
      | XOR<
          usersCreateWithoutStatusInput,
          usersUncheckedCreateWithoutStatusInput
        >
      | usersCreateWithoutStatusInput[]
      | usersUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | usersCreateOrConnectWithoutStatusInput
      | usersCreateOrConnectWithoutStatusInput[];
    upsert?:
      | usersUpsertWithWhereUniqueWithoutStatusInput
      | usersUpsertWithWhereUniqueWithoutStatusInput[];
    createMany?: usersCreateManyStatusInputEnvelope;
    set?: usersWhereUniqueInput | usersWhereUniqueInput[];
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[];
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[];
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[];
    update?:
      | usersUpdateWithWhereUniqueWithoutStatusInput
      | usersUpdateWithWhereUniqueWithoutStatusInput[];
    updateMany?:
      | usersUpdateManyWithWhereWithoutStatusInput
      | usersUpdateManyWithWhereWithoutStatusInput[];
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[];
  };

  export type audioUncheckedUpdateManyWithoutStatusNestedInput = {
    create?:
      | XOR<
          audioCreateWithoutStatusInput,
          audioUncheckedCreateWithoutStatusInput
        >
      | audioCreateWithoutStatusInput[]
      | audioUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | audioCreateOrConnectWithoutStatusInput
      | audioCreateOrConnectWithoutStatusInput[];
    upsert?:
      | audioUpsertWithWhereUniqueWithoutStatusInput
      | audioUpsertWithWhereUniqueWithoutStatusInput[];
    createMany?: audioCreateManyStatusInputEnvelope;
    set?: audioWhereUniqueInput | audioWhereUniqueInput[];
    disconnect?: audioWhereUniqueInput | audioWhereUniqueInput[];
    delete?: audioWhereUniqueInput | audioWhereUniqueInput[];
    connect?: audioWhereUniqueInput | audioWhereUniqueInput[];
    update?:
      | audioUpdateWithWhereUniqueWithoutStatusInput
      | audioUpdateWithWhereUniqueWithoutStatusInput[];
    updateMany?:
      | audioUpdateManyWithWhereWithoutStatusInput
      | audioUpdateManyWithWhereWithoutStatusInput[];
    deleteMany?: audioScalarWhereInput | audioScalarWhereInput[];
  };

  export type exhibitUncheckedUpdateManyWithoutStatusNestedInput = {
    create?:
      | XOR<
          exhibitCreateWithoutStatusInput,
          exhibitUncheckedCreateWithoutStatusInput
        >
      | exhibitCreateWithoutStatusInput[]
      | exhibitUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | exhibitCreateOrConnectWithoutStatusInput
      | exhibitCreateOrConnectWithoutStatusInput[];
    upsert?:
      | exhibitUpsertWithWhereUniqueWithoutStatusInput
      | exhibitUpsertWithWhereUniqueWithoutStatusInput[];
    createMany?: exhibitCreateManyStatusInputEnvelope;
    set?: exhibitWhereUniqueInput | exhibitWhereUniqueInput[];
    disconnect?: exhibitWhereUniqueInput | exhibitWhereUniqueInput[];
    delete?: exhibitWhereUniqueInput | exhibitWhereUniqueInput[];
    connect?: exhibitWhereUniqueInput | exhibitWhereUniqueInput[];
    update?:
      | exhibitUpdateWithWhereUniqueWithoutStatusInput
      | exhibitUpdateWithWhereUniqueWithoutStatusInput[];
    updateMany?:
      | exhibitUpdateManyWithWhereWithoutStatusInput
      | exhibitUpdateManyWithWhereWithoutStatusInput[];
    deleteMany?: exhibitScalarWhereInput | exhibitScalarWhereInput[];
  };

  export type phoneNumberUncheckedUpdateManyWithoutStatusNestedInput = {
    create?:
      | XOR<
          phoneNumberCreateWithoutStatusInput,
          phoneNumberUncheckedCreateWithoutStatusInput
        >
      | phoneNumberCreateWithoutStatusInput[]
      | phoneNumberUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | phoneNumberCreateOrConnectWithoutStatusInput
      | phoneNumberCreateOrConnectWithoutStatusInput[];
    upsert?:
      | phoneNumberUpsertWithWhereUniqueWithoutStatusInput
      | phoneNumberUpsertWithWhereUniqueWithoutStatusInput[];
    createMany?: phoneNumberCreateManyStatusInputEnvelope;
    set?: phoneNumberWhereUniqueInput | phoneNumberWhereUniqueInput[];
    disconnect?: phoneNumberWhereUniqueInput | phoneNumberWhereUniqueInput[];
    delete?: phoneNumberWhereUniqueInput | phoneNumberWhereUniqueInput[];
    connect?: phoneNumberWhereUniqueInput | phoneNumberWhereUniqueInput[];
    update?:
      | phoneNumberUpdateWithWhereUniqueWithoutStatusInput
      | phoneNumberUpdateWithWhereUniqueWithoutStatusInput[];
    updateMany?:
      | phoneNumberUpdateManyWithWhereWithoutStatusInput
      | phoneNumberUpdateManyWithWhereWithoutStatusInput[];
    deleteMany?: phoneNumberScalarWhereInput | phoneNumberScalarWhereInput[];
  };

  export type emailUncheckedUpdateManyWithoutStatusNestedInput = {
    create?:
      | XOR<
          emailCreateWithoutStatusInput,
          emailUncheckedCreateWithoutStatusInput
        >
      | emailCreateWithoutStatusInput[]
      | emailUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | emailCreateOrConnectWithoutStatusInput
      | emailCreateOrConnectWithoutStatusInput[];
    upsert?:
      | emailUpsertWithWhereUniqueWithoutStatusInput
      | emailUpsertWithWhereUniqueWithoutStatusInput[];
    createMany?: emailCreateManyStatusInputEnvelope;
    set?: emailWhereUniqueInput | emailWhereUniqueInput[];
    disconnect?: emailWhereUniqueInput | emailWhereUniqueInput[];
    delete?: emailWhereUniqueInput | emailWhereUniqueInput[];
    connect?: emailWhereUniqueInput | emailWhereUniqueInput[];
    update?:
      | emailUpdateWithWhereUniqueWithoutStatusInput
      | emailUpdateWithWhereUniqueWithoutStatusInput[];
    updateMany?:
      | emailUpdateManyWithWhereWithoutStatusInput
      | emailUpdateManyWithWhereWithoutStatusInput[];
    deleteMany?: emailScalarWhereInput | emailScalarWhereInput[];
  };

  export type roleUncheckedUpdateManyWithoutStatusNestedInput = {
    create?:
      | XOR<roleCreateWithoutStatusInput, roleUncheckedCreateWithoutStatusInput>
      | roleCreateWithoutStatusInput[]
      | roleUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | roleCreateOrConnectWithoutStatusInput
      | roleCreateOrConnectWithoutStatusInput[];
    upsert?:
      | roleUpsertWithWhereUniqueWithoutStatusInput
      | roleUpsertWithWhereUniqueWithoutStatusInput[];
    createMany?: roleCreateManyStatusInputEnvelope;
    set?: roleWhereUniqueInput | roleWhereUniqueInput[];
    disconnect?: roleWhereUniqueInput | roleWhereUniqueInput[];
    delete?: roleWhereUniqueInput | roleWhereUniqueInput[];
    connect?: roleWhereUniqueInput | roleWhereUniqueInput[];
    update?:
      | roleUpdateWithWhereUniqueWithoutStatusInput
      | roleUpdateWithWhereUniqueWithoutStatusInput[];
    updateMany?:
      | roleUpdateManyWithWhereWithoutStatusInput
      | roleUpdateManyWithWhereWithoutStatusInput[];
    deleteMany?: roleScalarWhereInput | roleScalarWhereInput[];
  };

  export type qrCodeUncheckedUpdateManyWithoutStatusNestedInput = {
    create?:
      | XOR<
          qrCodeCreateWithoutStatusInput,
          qrCodeUncheckedCreateWithoutStatusInput
        >
      | qrCodeCreateWithoutStatusInput[]
      | qrCodeUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | qrCodeCreateOrConnectWithoutStatusInput
      | qrCodeCreateOrConnectWithoutStatusInput[];
    upsert?:
      | qrCodeUpsertWithWhereUniqueWithoutStatusInput
      | qrCodeUpsertWithWhereUniqueWithoutStatusInput[];
    createMany?: qrCodeCreateManyStatusInputEnvelope;
    set?: qrCodeWhereUniqueInput | qrCodeWhereUniqueInput[];
    disconnect?: qrCodeWhereUniqueInput | qrCodeWhereUniqueInput[];
    delete?: qrCodeWhereUniqueInput | qrCodeWhereUniqueInput[];
    connect?: qrCodeWhereUniqueInput | qrCodeWhereUniqueInput[];
    update?:
      | qrCodeUpdateWithWhereUniqueWithoutStatusInput
      | qrCodeUpdateWithWhereUniqueWithoutStatusInput[];
    updateMany?:
      | qrCodeUpdateManyWithWhereWithoutStatusInput
      | qrCodeUpdateManyWithWhereWithoutStatusInput[];
    deleteMany?: qrCodeScalarWhereInput | qrCodeScalarWhereInput[];
  };

  export type imageUncheckedUpdateManyWithoutStatusNestedInput = {
    create?:
      | XOR<
          imageCreateWithoutStatusInput,
          imageUncheckedCreateWithoutStatusInput
        >
      | imageCreateWithoutStatusInput[]
      | imageUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | imageCreateOrConnectWithoutStatusInput
      | imageCreateOrConnectWithoutStatusInput[];
    upsert?:
      | imageUpsertWithWhereUniqueWithoutStatusInput
      | imageUpsertWithWhereUniqueWithoutStatusInput[];
    createMany?: imageCreateManyStatusInputEnvelope;
    set?: imageWhereUniqueInput | imageWhereUniqueInput[];
    disconnect?: imageWhereUniqueInput | imageWhereUniqueInput[];
    delete?: imageWhereUniqueInput | imageWhereUniqueInput[];
    connect?: imageWhereUniqueInput | imageWhereUniqueInput[];
    update?:
      | imageUpdateWithWhereUniqueWithoutStatusInput
      | imageUpdateWithWhereUniqueWithoutStatusInput[];
    updateMany?:
      | imageUpdateManyWithWhereWithoutStatusInput
      | imageUpdateManyWithWhereWithoutStatusInput[];
    deleteMany?: imageScalarWhereInput | imageScalarWhereInput[];
  };

  export type subtitleUncheckedUpdateManyWithoutStatusNestedInput = {
    create?:
      | XOR<
          subtitleCreateWithoutStatusInput,
          subtitleUncheckedCreateWithoutStatusInput
        >
      | subtitleCreateWithoutStatusInput[]
      | subtitleUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | subtitleCreateOrConnectWithoutStatusInput
      | subtitleCreateOrConnectWithoutStatusInput[];
    upsert?:
      | subtitleUpsertWithWhereUniqueWithoutStatusInput
      | subtitleUpsertWithWhereUniqueWithoutStatusInput[];
    createMany?: subtitleCreateManyStatusInputEnvelope;
    set?: subtitleWhereUniqueInput | subtitleWhereUniqueInput[];
    disconnect?: subtitleWhereUniqueInput | subtitleWhereUniqueInput[];
    delete?: subtitleWhereUniqueInput | subtitleWhereUniqueInput[];
    connect?: subtitleWhereUniqueInput | subtitleWhereUniqueInput[];
    update?:
      | subtitleUpdateWithWhereUniqueWithoutStatusInput
      | subtitleUpdateWithWhereUniqueWithoutStatusInput[];
    updateMany?:
      | subtitleUpdateManyWithWhereWithoutStatusInput
      | subtitleUpdateManyWithWhereWithoutStatusInput[];
    deleteMany?: subtitleScalarWhereInput | subtitleScalarWhereInput[];
  };

  export type languageUncheckedUpdateManyWithoutStatusNestedInput = {
    create?:
      | XOR<
          languageCreateWithoutStatusInput,
          languageUncheckedCreateWithoutStatusInput
        >
      | languageCreateWithoutStatusInput[]
      | languageUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | languageCreateOrConnectWithoutStatusInput
      | languageCreateOrConnectWithoutStatusInput[];
    upsert?:
      | languageUpsertWithWhereUniqueWithoutStatusInput
      | languageUpsertWithWhereUniqueWithoutStatusInput[];
    createMany?: languageCreateManyStatusInputEnvelope;
    set?: languageWhereUniqueInput | languageWhereUniqueInput[];
    disconnect?: languageWhereUniqueInput | languageWhereUniqueInput[];
    delete?: languageWhereUniqueInput | languageWhereUniqueInput[];
    connect?: languageWhereUniqueInput | languageWhereUniqueInput[];
    update?:
      | languageUpdateWithWhereUniqueWithoutStatusInput
      | languageUpdateWithWhereUniqueWithoutStatusInput[];
    updateMany?:
      | languageUpdateManyWithWhereWithoutStatusInput
      | languageUpdateManyWithWhereWithoutStatusInput[];
    deleteMany?: languageScalarWhereInput | languageScalarWhereInput[];
  };

  export type auditLogUncheckedUpdateManyWithoutStatusNestedInput = {
    create?:
      | XOR<
          auditLogCreateWithoutStatusInput,
          auditLogUncheckedCreateWithoutStatusInput
        >
      | auditLogCreateWithoutStatusInput[]
      | auditLogUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | auditLogCreateOrConnectWithoutStatusInput
      | auditLogCreateOrConnectWithoutStatusInput[];
    upsert?:
      | auditLogUpsertWithWhereUniqueWithoutStatusInput
      | auditLogUpsertWithWhereUniqueWithoutStatusInput[];
    createMany?: auditLogCreateManyStatusInputEnvelope;
    set?: auditLogWhereUniqueInput | auditLogWhereUniqueInput[];
    disconnect?: auditLogWhereUniqueInput | auditLogWhereUniqueInput[];
    delete?: auditLogWhereUniqueInput | auditLogWhereUniqueInput[];
    connect?: auditLogWhereUniqueInput | auditLogWhereUniqueInput[];
    update?:
      | auditLogUpdateWithWhereUniqueWithoutStatusInput
      | auditLogUpdateWithWhereUniqueWithoutStatusInput[];
    updateMany?:
      | auditLogUpdateManyWithWhereWithoutStatusInput
      | auditLogUpdateManyWithWhereWithoutStatusInput[];
    deleteMany?: auditLogScalarWhereInput | auditLogScalarWhereInput[];
  };

  export type userProfileUncheckedUpdateManyWithoutStatusNestedInput = {
    create?:
      | XOR<
          userProfileCreateWithoutStatusInput,
          userProfileUncheckedCreateWithoutStatusInput
        >
      | userProfileCreateWithoutStatusInput[]
      | userProfileUncheckedCreateWithoutStatusInput[];
    connectOrCreate?:
      | userProfileCreateOrConnectWithoutStatusInput
      | userProfileCreateOrConnectWithoutStatusInput[];
    upsert?:
      | userProfileUpsertWithWhereUniqueWithoutStatusInput
      | userProfileUpsertWithWhereUniqueWithoutStatusInput[];
    createMany?: userProfileCreateManyStatusInputEnvelope;
    set?: userProfileWhereUniqueInput | userProfileWhereUniqueInput[];
    disconnect?: userProfileWhereUniqueInput | userProfileWhereUniqueInput[];
    delete?: userProfileWhereUniqueInput | userProfileWhereUniqueInput[];
    connect?: userProfileWhereUniqueInput | userProfileWhereUniqueInput[];
    update?:
      | userProfileUpdateWithWhereUniqueWithoutStatusInput
      | userProfileUpdateWithWhereUniqueWithoutStatusInput[];
    updateMany?:
      | userProfileUpdateManyWithWhereWithoutStatusInput
      | userProfileUpdateManyWithWhereWithoutStatusInput[];
    deleteMany?: userProfileScalarWhereInput | userProfileScalarWhereInput[];
  };

  export type languageCreateNestedOneWithoutAudiosInput = {
    create?: XOR<
      languageCreateWithoutAudiosInput,
      languageUncheckedCreateWithoutAudiosInput
    >;
    connectOrCreate?: languageCreateOrConnectWithoutAudiosInput;
    connect?: languageWhereUniqueInput;
  };

  export type statusCreateNestedOneWithoutAudiosInput = {
    create?: XOR<
      statusCreateWithoutAudiosInput,
      statusUncheckedCreateWithoutAudiosInput
    >;
    connectOrCreate?: statusCreateOrConnectWithoutAudiosInput;
    connect?: statusWhereUniqueInput;
  };

  export type exhibitAudioRelationCreateNestedManyWithoutAudioInput = {
    create?:
      | XOR<
          exhibitAudioRelationCreateWithoutAudioInput,
          exhibitAudioRelationUncheckedCreateWithoutAudioInput
        >
      | exhibitAudioRelationCreateWithoutAudioInput[]
      | exhibitAudioRelationUncheckedCreateWithoutAudioInput[];
    connectOrCreate?:
      | exhibitAudioRelationCreateOrConnectWithoutAudioInput
      | exhibitAudioRelationCreateOrConnectWithoutAudioInput[];
    createMany?: exhibitAudioRelationCreateManyAudioInputEnvelope;
    connect?:
      | exhibitAudioRelationWhereUniqueInput
      | exhibitAudioRelationWhereUniqueInput[];
  };

  export type exhibitCreateNestedManyWithoutAudioInput = {
    create?:
      | XOR<
          exhibitCreateWithoutAudioInput,
          exhibitUncheckedCreateWithoutAudioInput
        >
      | exhibitCreateWithoutAudioInput[]
      | exhibitUncheckedCreateWithoutAudioInput[];
    connectOrCreate?:
      | exhibitCreateOrConnectWithoutAudioInput
      | exhibitCreateOrConnectWithoutAudioInput[];
    createMany?: exhibitCreateManyAudioInputEnvelope;
    connect?: exhibitWhereUniqueInput | exhibitWhereUniqueInput[];
  };

  export type exhibitAudioRelationUncheckedCreateNestedManyWithoutAudioInput = {
    create?:
      | XOR<
          exhibitAudioRelationCreateWithoutAudioInput,
          exhibitAudioRelationUncheckedCreateWithoutAudioInput
        >
      | exhibitAudioRelationCreateWithoutAudioInput[]
      | exhibitAudioRelationUncheckedCreateWithoutAudioInput[];
    connectOrCreate?:
      | exhibitAudioRelationCreateOrConnectWithoutAudioInput
      | exhibitAudioRelationCreateOrConnectWithoutAudioInput[];
    createMany?: exhibitAudioRelationCreateManyAudioInputEnvelope;
    connect?:
      | exhibitAudioRelationWhereUniqueInput
      | exhibitAudioRelationWhereUniqueInput[];
  };

  export type exhibitUncheckedCreateNestedManyWithoutAudioInput = {
    create?:
      | XOR<
          exhibitCreateWithoutAudioInput,
          exhibitUncheckedCreateWithoutAudioInput
        >
      | exhibitCreateWithoutAudioInput[]
      | exhibitUncheckedCreateWithoutAudioInput[];
    connectOrCreate?:
      | exhibitCreateOrConnectWithoutAudioInput
      | exhibitCreateOrConnectWithoutAudioInput[];
    createMany?: exhibitCreateManyAudioInputEnvelope;
    connect?: exhibitWhereUniqueInput | exhibitWhereUniqueInput[];
  };

  export type languageUpdateOneRequiredWithoutAudiosNestedInput = {
    create?: XOR<
      languageCreateWithoutAudiosInput,
      languageUncheckedCreateWithoutAudiosInput
    >;
    connectOrCreate?: languageCreateOrConnectWithoutAudiosInput;
    upsert?: languageUpsertWithoutAudiosInput;
    connect?: languageWhereUniqueInput;
    update?: XOR<
      XOR<
        languageUpdateToOneWithWhereWithoutAudiosInput,
        languageUpdateWithoutAudiosInput
      >,
      languageUncheckedUpdateWithoutAudiosInput
    >;
  };

  export type statusUpdateOneRequiredWithoutAudiosNestedInput = {
    create?: XOR<
      statusCreateWithoutAudiosInput,
      statusUncheckedCreateWithoutAudiosInput
    >;
    connectOrCreate?: statusCreateOrConnectWithoutAudiosInput;
    upsert?: statusUpsertWithoutAudiosInput;
    connect?: statusWhereUniqueInput;
    update?: XOR<
      XOR<
        statusUpdateToOneWithWhereWithoutAudiosInput,
        statusUpdateWithoutAudiosInput
      >,
      statusUncheckedUpdateWithoutAudiosInput
    >;
  };

  export type exhibitAudioRelationUpdateManyWithoutAudioNestedInput = {
    create?:
      | XOR<
          exhibitAudioRelationCreateWithoutAudioInput,
          exhibitAudioRelationUncheckedCreateWithoutAudioInput
        >
      | exhibitAudioRelationCreateWithoutAudioInput[]
      | exhibitAudioRelationUncheckedCreateWithoutAudioInput[];
    connectOrCreate?:
      | exhibitAudioRelationCreateOrConnectWithoutAudioInput
      | exhibitAudioRelationCreateOrConnectWithoutAudioInput[];
    upsert?:
      | exhibitAudioRelationUpsertWithWhereUniqueWithoutAudioInput
      | exhibitAudioRelationUpsertWithWhereUniqueWithoutAudioInput[];
    createMany?: exhibitAudioRelationCreateManyAudioInputEnvelope;
    set?:
      | exhibitAudioRelationWhereUniqueInput
      | exhibitAudioRelationWhereUniqueInput[];
    disconnect?:
      | exhibitAudioRelationWhereUniqueInput
      | exhibitAudioRelationWhereUniqueInput[];
    delete?:
      | exhibitAudioRelationWhereUniqueInput
      | exhibitAudioRelationWhereUniqueInput[];
    connect?:
      | exhibitAudioRelationWhereUniqueInput
      | exhibitAudioRelationWhereUniqueInput[];
    update?:
      | exhibitAudioRelationUpdateWithWhereUniqueWithoutAudioInput
      | exhibitAudioRelationUpdateWithWhereUniqueWithoutAudioInput[];
    updateMany?:
      | exhibitAudioRelationUpdateManyWithWhereWithoutAudioInput
      | exhibitAudioRelationUpdateManyWithWhereWithoutAudioInput[];
    deleteMany?:
      | exhibitAudioRelationScalarWhereInput
      | exhibitAudioRelationScalarWhereInput[];
  };

  export type exhibitUpdateManyWithoutAudioNestedInput = {
    create?:
      | XOR<
          exhibitCreateWithoutAudioInput,
          exhibitUncheckedCreateWithoutAudioInput
        >
      | exhibitCreateWithoutAudioInput[]
      | exhibitUncheckedCreateWithoutAudioInput[];
    connectOrCreate?:
      | exhibitCreateOrConnectWithoutAudioInput
      | exhibitCreateOrConnectWithoutAudioInput[];
    upsert?:
      | exhibitUpsertWithWhereUniqueWithoutAudioInput
      | exhibitUpsertWithWhereUniqueWithoutAudioInput[];
    createMany?: exhibitCreateManyAudioInputEnvelope;
    set?: exhibitWhereUniqueInput | exhibitWhereUniqueInput[];
    disconnect?: exhibitWhereUniqueInput | exhibitWhereUniqueInput[];
    delete?: exhibitWhereUniqueInput | exhibitWhereUniqueInput[];
    connect?: exhibitWhereUniqueInput | exhibitWhereUniqueInput[];
    update?:
      | exhibitUpdateWithWhereUniqueWithoutAudioInput
      | exhibitUpdateWithWhereUniqueWithoutAudioInput[];
    updateMany?:
      | exhibitUpdateManyWithWhereWithoutAudioInput
      | exhibitUpdateManyWithWhereWithoutAudioInput[];
    deleteMany?: exhibitScalarWhereInput | exhibitScalarWhereInput[];
  };

  export type exhibitAudioRelationUncheckedUpdateManyWithoutAudioNestedInput = {
    create?:
      | XOR<
          exhibitAudioRelationCreateWithoutAudioInput,
          exhibitAudioRelationUncheckedCreateWithoutAudioInput
        >
      | exhibitAudioRelationCreateWithoutAudioInput[]
      | exhibitAudioRelationUncheckedCreateWithoutAudioInput[];
    connectOrCreate?:
      | exhibitAudioRelationCreateOrConnectWithoutAudioInput
      | exhibitAudioRelationCreateOrConnectWithoutAudioInput[];
    upsert?:
      | exhibitAudioRelationUpsertWithWhereUniqueWithoutAudioInput
      | exhibitAudioRelationUpsertWithWhereUniqueWithoutAudioInput[];
    createMany?: exhibitAudioRelationCreateManyAudioInputEnvelope;
    set?:
      | exhibitAudioRelationWhereUniqueInput
      | exhibitAudioRelationWhereUniqueInput[];
    disconnect?:
      | exhibitAudioRelationWhereUniqueInput
      | exhibitAudioRelationWhereUniqueInput[];
    delete?:
      | exhibitAudioRelationWhereUniqueInput
      | exhibitAudioRelationWhereUniqueInput[];
    connect?:
      | exhibitAudioRelationWhereUniqueInput
      | exhibitAudioRelationWhereUniqueInput[];
    update?:
      | exhibitAudioRelationUpdateWithWhereUniqueWithoutAudioInput
      | exhibitAudioRelationUpdateWithWhereUniqueWithoutAudioInput[];
    updateMany?:
      | exhibitAudioRelationUpdateManyWithWhereWithoutAudioInput
      | exhibitAudioRelationUpdateManyWithWhereWithoutAudioInput[];
    deleteMany?:
      | exhibitAudioRelationScalarWhereInput
      | exhibitAudioRelationScalarWhereInput[];
  };

  export type exhibitUncheckedUpdateManyWithoutAudioNestedInput = {
    create?:
      | XOR<
          exhibitCreateWithoutAudioInput,
          exhibitUncheckedCreateWithoutAudioInput
        >
      | exhibitCreateWithoutAudioInput[]
      | exhibitUncheckedCreateWithoutAudioInput[];
    connectOrCreate?:
      | exhibitCreateOrConnectWithoutAudioInput
      | exhibitCreateOrConnectWithoutAudioInput[];
    upsert?:
      | exhibitUpsertWithWhereUniqueWithoutAudioInput
      | exhibitUpsertWithWhereUniqueWithoutAudioInput[];
    createMany?: exhibitCreateManyAudioInputEnvelope;
    set?: exhibitWhereUniqueInput | exhibitWhereUniqueInput[];
    disconnect?: exhibitWhereUniqueInput | exhibitWhereUniqueInput[];
    delete?: exhibitWhereUniqueInput | exhibitWhereUniqueInput[];
    connect?: exhibitWhereUniqueInput | exhibitWhereUniqueInput[];
    update?:
      | exhibitUpdateWithWhereUniqueWithoutAudioInput
      | exhibitUpdateWithWhereUniqueWithoutAudioInput[];
    updateMany?:
      | exhibitUpdateManyWithWhereWithoutAudioInput
      | exhibitUpdateManyWithWhereWithoutAudioInput[];
    deleteMany?: exhibitScalarWhereInput | exhibitScalarWhereInput[];
  };

  export type audioCreateNestedOneWithoutExhibitsInput = {
    create?: XOR<
      audioCreateWithoutExhibitsInput,
      audioUncheckedCreateWithoutExhibitsInput
    >;
    connectOrCreate?: audioCreateOrConnectWithoutExhibitsInput;
    connect?: audioWhereUniqueInput;
  };

  export type exhibitCreateNestedOneWithoutExhibitAudioRelationInput = {
    create?: XOR<
      exhibitCreateWithoutExhibitAudioRelationInput,
      exhibitUncheckedCreateWithoutExhibitAudioRelationInput
    >;
    connectOrCreate?: exhibitCreateOrConnectWithoutExhibitAudioRelationInput;
    connect?: exhibitWhereUniqueInput;
  };

  export type audioUpdateOneRequiredWithoutExhibitsNestedInput = {
    create?: XOR<
      audioCreateWithoutExhibitsInput,
      audioUncheckedCreateWithoutExhibitsInput
    >;
    connectOrCreate?: audioCreateOrConnectWithoutExhibitsInput;
    upsert?: audioUpsertWithoutExhibitsInput;
    connect?: audioWhereUniqueInput;
    update?: XOR<
      XOR<
        audioUpdateToOneWithWhereWithoutExhibitsInput,
        audioUpdateWithoutExhibitsInput
      >,
      audioUncheckedUpdateWithoutExhibitsInput
    >;
  };

  export type exhibitUpdateOneRequiredWithoutExhibitAudioRelationNestedInput = {
    create?: XOR<
      exhibitCreateWithoutExhibitAudioRelationInput,
      exhibitUncheckedCreateWithoutExhibitAudioRelationInput
    >;
    connectOrCreate?: exhibitCreateOrConnectWithoutExhibitAudioRelationInput;
    upsert?: exhibitUpsertWithoutExhibitAudioRelationInput;
    connect?: exhibitWhereUniqueInput;
    update?: XOR<
      XOR<
        exhibitUpdateToOneWithWhereWithoutExhibitAudioRelationInput,
        exhibitUpdateWithoutExhibitAudioRelationInput
      >,
      exhibitUncheckedUpdateWithoutExhibitAudioRelationInput
    >;
  };

  export type audioCreateNestedOneWithoutExhibitInput = {
    create?: XOR<
      audioCreateWithoutExhibitInput,
      audioUncheckedCreateWithoutExhibitInput
    >;
    connectOrCreate?: audioCreateOrConnectWithoutExhibitInput;
    connect?: audioWhereUniqueInput;
  };

  export type qrCodeCreateNestedOneWithoutExhibitInput = {
    create?: XOR<
      qrCodeCreateWithoutExhibitInput,
      qrCodeUncheckedCreateWithoutExhibitInput
    >;
    connectOrCreate?: qrCodeCreateOrConnectWithoutExhibitInput;
    connect?: qrCodeWhereUniqueInput;
  };

  export type imageCreateNestedOneWithoutExhibitInput = {
    create?: XOR<
      imageCreateWithoutExhibitInput,
      imageUncheckedCreateWithoutExhibitInput
    >;
    connectOrCreate?: imageCreateOrConnectWithoutExhibitInput;
    connect?: imageWhereUniqueInput;
  };

  export type exhibitSubtitleCreateNestedManyWithoutExhibitInput = {
    create?:
      | XOR<
          exhibitSubtitleCreateWithoutExhibitInput,
          exhibitSubtitleUncheckedCreateWithoutExhibitInput
        >
      | exhibitSubtitleCreateWithoutExhibitInput[]
      | exhibitSubtitleUncheckedCreateWithoutExhibitInput[];
    connectOrCreate?:
      | exhibitSubtitleCreateOrConnectWithoutExhibitInput
      | exhibitSubtitleCreateOrConnectWithoutExhibitInput[];
    createMany?: exhibitSubtitleCreateManyExhibitInputEnvelope;
    connect?:
      | exhibitSubtitleWhereUniqueInput
      | exhibitSubtitleWhereUniqueInput[];
  };

  export type statusCreateNestedOneWithoutExhibitsInput = {
    create?: XOR<
      statusCreateWithoutExhibitsInput,
      statusUncheckedCreateWithoutExhibitsInput
    >;
    connectOrCreate?: statusCreateOrConnectWithoutExhibitsInput;
    connect?: statusWhereUniqueInput;
  };

  export type exhibitAudioRelationCreateNestedManyWithoutExhibitInput = {
    create?:
      | XOR<
          exhibitAudioRelationCreateWithoutExhibitInput,
          exhibitAudioRelationUncheckedCreateWithoutExhibitInput
        >
      | exhibitAudioRelationCreateWithoutExhibitInput[]
      | exhibitAudioRelationUncheckedCreateWithoutExhibitInput[];
    connectOrCreate?:
      | exhibitAudioRelationCreateOrConnectWithoutExhibitInput
      | exhibitAudioRelationCreateOrConnectWithoutExhibitInput[];
    createMany?: exhibitAudioRelationCreateManyExhibitInputEnvelope;
    connect?:
      | exhibitAudioRelationWhereUniqueInput
      | exhibitAudioRelationWhereUniqueInput[];
  };

  export type exhibitSubtitleUncheckedCreateNestedManyWithoutExhibitInput = {
    create?:
      | XOR<
          exhibitSubtitleCreateWithoutExhibitInput,
          exhibitSubtitleUncheckedCreateWithoutExhibitInput
        >
      | exhibitSubtitleCreateWithoutExhibitInput[]
      | exhibitSubtitleUncheckedCreateWithoutExhibitInput[];
    connectOrCreate?:
      | exhibitSubtitleCreateOrConnectWithoutExhibitInput
      | exhibitSubtitleCreateOrConnectWithoutExhibitInput[];
    createMany?: exhibitSubtitleCreateManyExhibitInputEnvelope;
    connect?:
      | exhibitSubtitleWhereUniqueInput
      | exhibitSubtitleWhereUniqueInput[];
  };

  export type exhibitAudioRelationUncheckedCreateNestedManyWithoutExhibitInput =
    {
      create?:
        | XOR<
            exhibitAudioRelationCreateWithoutExhibitInput,
            exhibitAudioRelationUncheckedCreateWithoutExhibitInput
          >
        | exhibitAudioRelationCreateWithoutExhibitInput[]
        | exhibitAudioRelationUncheckedCreateWithoutExhibitInput[];
      connectOrCreate?:
        | exhibitAudioRelationCreateOrConnectWithoutExhibitInput
        | exhibitAudioRelationCreateOrConnectWithoutExhibitInput[];
      createMany?: exhibitAudioRelationCreateManyExhibitInputEnvelope;
      connect?:
        | exhibitAudioRelationWhereUniqueInput
        | exhibitAudioRelationWhereUniqueInput[];
    };

  export type audioUpdateOneRequiredWithoutExhibitNestedInput = {
    create?: XOR<
      audioCreateWithoutExhibitInput,
      audioUncheckedCreateWithoutExhibitInput
    >;
    connectOrCreate?: audioCreateOrConnectWithoutExhibitInput;
    upsert?: audioUpsertWithoutExhibitInput;
    connect?: audioWhereUniqueInput;
    update?: XOR<
      XOR<
        audioUpdateToOneWithWhereWithoutExhibitInput,
        audioUpdateWithoutExhibitInput
      >,
      audioUncheckedUpdateWithoutExhibitInput
    >;
  };

  export type qrCodeUpdateOneRequiredWithoutExhibitNestedInput = {
    create?: XOR<
      qrCodeCreateWithoutExhibitInput,
      qrCodeUncheckedCreateWithoutExhibitInput
    >;
    connectOrCreate?: qrCodeCreateOrConnectWithoutExhibitInput;
    upsert?: qrCodeUpsertWithoutExhibitInput;
    connect?: qrCodeWhereUniqueInput;
    update?: XOR<
      XOR<
        qrCodeUpdateToOneWithWhereWithoutExhibitInput,
        qrCodeUpdateWithoutExhibitInput
      >,
      qrCodeUncheckedUpdateWithoutExhibitInput
    >;
  };

  export type imageUpdateOneRequiredWithoutExhibitNestedInput = {
    create?: XOR<
      imageCreateWithoutExhibitInput,
      imageUncheckedCreateWithoutExhibitInput
    >;
    connectOrCreate?: imageCreateOrConnectWithoutExhibitInput;
    upsert?: imageUpsertWithoutExhibitInput;
    connect?: imageWhereUniqueInput;
    update?: XOR<
      XOR<
        imageUpdateToOneWithWhereWithoutExhibitInput,
        imageUpdateWithoutExhibitInput
      >,
      imageUncheckedUpdateWithoutExhibitInput
    >;
  };

  export type exhibitSubtitleUpdateManyWithoutExhibitNestedInput = {
    create?:
      | XOR<
          exhibitSubtitleCreateWithoutExhibitInput,
          exhibitSubtitleUncheckedCreateWithoutExhibitInput
        >
      | exhibitSubtitleCreateWithoutExhibitInput[]
      | exhibitSubtitleUncheckedCreateWithoutExhibitInput[];
    connectOrCreate?:
      | exhibitSubtitleCreateOrConnectWithoutExhibitInput
      | exhibitSubtitleCreateOrConnectWithoutExhibitInput[];
    upsert?:
      | exhibitSubtitleUpsertWithWhereUniqueWithoutExhibitInput
      | exhibitSubtitleUpsertWithWhereUniqueWithoutExhibitInput[];
    createMany?: exhibitSubtitleCreateManyExhibitInputEnvelope;
    set?: exhibitSubtitleWhereUniqueInput | exhibitSubtitleWhereUniqueInput[];
    disconnect?:
      | exhibitSubtitleWhereUniqueInput
      | exhibitSubtitleWhereUniqueInput[];
    delete?:
      | exhibitSubtitleWhereUniqueInput
      | exhibitSubtitleWhereUniqueInput[];
    connect?:
      | exhibitSubtitleWhereUniqueInput
      | exhibitSubtitleWhereUniqueInput[];
    update?:
      | exhibitSubtitleUpdateWithWhereUniqueWithoutExhibitInput
      | exhibitSubtitleUpdateWithWhereUniqueWithoutExhibitInput[];
    updateMany?:
      | exhibitSubtitleUpdateManyWithWhereWithoutExhibitInput
      | exhibitSubtitleUpdateManyWithWhereWithoutExhibitInput[];
    deleteMany?:
      | exhibitSubtitleScalarWhereInput
      | exhibitSubtitleScalarWhereInput[];
  };

  export type statusUpdateOneRequiredWithoutExhibitsNestedInput = {
    create?: XOR<
      statusCreateWithoutExhibitsInput,
      statusUncheckedCreateWithoutExhibitsInput
    >;
    connectOrCreate?: statusCreateOrConnectWithoutExhibitsInput;
    upsert?: statusUpsertWithoutExhibitsInput;
    connect?: statusWhereUniqueInput;
    update?: XOR<
      XOR<
        statusUpdateToOneWithWhereWithoutExhibitsInput,
        statusUpdateWithoutExhibitsInput
      >,
      statusUncheckedUpdateWithoutExhibitsInput
    >;
  };

  export type exhibitAudioRelationUpdateManyWithoutExhibitNestedInput = {
    create?:
      | XOR<
          exhibitAudioRelationCreateWithoutExhibitInput,
          exhibitAudioRelationUncheckedCreateWithoutExhibitInput
        >
      | exhibitAudioRelationCreateWithoutExhibitInput[]
      | exhibitAudioRelationUncheckedCreateWithoutExhibitInput[];
    connectOrCreate?:
      | exhibitAudioRelationCreateOrConnectWithoutExhibitInput
      | exhibitAudioRelationCreateOrConnectWithoutExhibitInput[];
    upsert?:
      | exhibitAudioRelationUpsertWithWhereUniqueWithoutExhibitInput
      | exhibitAudioRelationUpsertWithWhereUniqueWithoutExhibitInput[];
    createMany?: exhibitAudioRelationCreateManyExhibitInputEnvelope;
    set?:
      | exhibitAudioRelationWhereUniqueInput
      | exhibitAudioRelationWhereUniqueInput[];
    disconnect?:
      | exhibitAudioRelationWhereUniqueInput
      | exhibitAudioRelationWhereUniqueInput[];
    delete?:
      | exhibitAudioRelationWhereUniqueInput
      | exhibitAudioRelationWhereUniqueInput[];
    connect?:
      | exhibitAudioRelationWhereUniqueInput
      | exhibitAudioRelationWhereUniqueInput[];
    update?:
      | exhibitAudioRelationUpdateWithWhereUniqueWithoutExhibitInput
      | exhibitAudioRelationUpdateWithWhereUniqueWithoutExhibitInput[];
    updateMany?:
      | exhibitAudioRelationUpdateManyWithWhereWithoutExhibitInput
      | exhibitAudioRelationUpdateManyWithWhereWithoutExhibitInput[];
    deleteMany?:
      | exhibitAudioRelationScalarWhereInput
      | exhibitAudioRelationScalarWhereInput[];
  };

  export type exhibitSubtitleUncheckedUpdateManyWithoutExhibitNestedInput = {
    create?:
      | XOR<
          exhibitSubtitleCreateWithoutExhibitInput,
          exhibitSubtitleUncheckedCreateWithoutExhibitInput
        >
      | exhibitSubtitleCreateWithoutExhibitInput[]
      | exhibitSubtitleUncheckedCreateWithoutExhibitInput[];
    connectOrCreate?:
      | exhibitSubtitleCreateOrConnectWithoutExhibitInput
      | exhibitSubtitleCreateOrConnectWithoutExhibitInput[];
    upsert?:
      | exhibitSubtitleUpsertWithWhereUniqueWithoutExhibitInput
      | exhibitSubtitleUpsertWithWhereUniqueWithoutExhibitInput[];
    createMany?: exhibitSubtitleCreateManyExhibitInputEnvelope;
    set?: exhibitSubtitleWhereUniqueInput | exhibitSubtitleWhereUniqueInput[];
    disconnect?:
      | exhibitSubtitleWhereUniqueInput
      | exhibitSubtitleWhereUniqueInput[];
    delete?:
      | exhibitSubtitleWhereUniqueInput
      | exhibitSubtitleWhereUniqueInput[];
    connect?:
      | exhibitSubtitleWhereUniqueInput
      | exhibitSubtitleWhereUniqueInput[];
    update?:
      | exhibitSubtitleUpdateWithWhereUniqueWithoutExhibitInput
      | exhibitSubtitleUpdateWithWhereUniqueWithoutExhibitInput[];
    updateMany?:
      | exhibitSubtitleUpdateManyWithWhereWithoutExhibitInput
      | exhibitSubtitleUpdateManyWithWhereWithoutExhibitInput[];
    deleteMany?:
      | exhibitSubtitleScalarWhereInput
      | exhibitSubtitleScalarWhereInput[];
  };

  export type exhibitAudioRelationUncheckedUpdateManyWithoutExhibitNestedInput =
    {
      create?:
        | XOR<
            exhibitAudioRelationCreateWithoutExhibitInput,
            exhibitAudioRelationUncheckedCreateWithoutExhibitInput
          >
        | exhibitAudioRelationCreateWithoutExhibitInput[]
        | exhibitAudioRelationUncheckedCreateWithoutExhibitInput[];
      connectOrCreate?:
        | exhibitAudioRelationCreateOrConnectWithoutExhibitInput
        | exhibitAudioRelationCreateOrConnectWithoutExhibitInput[];
      upsert?:
        | exhibitAudioRelationUpsertWithWhereUniqueWithoutExhibitInput
        | exhibitAudioRelationUpsertWithWhereUniqueWithoutExhibitInput[];
      createMany?: exhibitAudioRelationCreateManyExhibitInputEnvelope;
      set?:
        | exhibitAudioRelationWhereUniqueInput
        | exhibitAudioRelationWhereUniqueInput[];
      disconnect?:
        | exhibitAudioRelationWhereUniqueInput
        | exhibitAudioRelationWhereUniqueInput[];
      delete?:
        | exhibitAudioRelationWhereUniqueInput
        | exhibitAudioRelationWhereUniqueInput[];
      connect?:
        | exhibitAudioRelationWhereUniqueInput
        | exhibitAudioRelationWhereUniqueInput[];
      update?:
        | exhibitAudioRelationUpdateWithWhereUniqueWithoutExhibitInput
        | exhibitAudioRelationUpdateWithWhereUniqueWithoutExhibitInput[];
      updateMany?:
        | exhibitAudioRelationUpdateManyWithWhereWithoutExhibitInput
        | exhibitAudioRelationUpdateManyWithWhereWithoutExhibitInput[];
      deleteMany?:
        | exhibitAudioRelationScalarWhereInput
        | exhibitAudioRelationScalarWhereInput[];
    };

  export type usersCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<
      usersCreateWithoutAuditLogsInput,
      usersUncheckedCreateWithoutAuditLogsInput
    >;
    connectOrCreate?: usersCreateOrConnectWithoutAuditLogsInput;
    connect?: usersWhereUniqueInput;
  };

  export type statusCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<
      statusCreateWithoutAuditLogsInput,
      statusUncheckedCreateWithoutAuditLogsInput
    >;
    connectOrCreate?: statusCreateOrConnectWithoutAuditLogsInput;
    connect?: statusWhereUniqueInput;
  };

  export type usersUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<
      usersCreateWithoutAuditLogsInput,
      usersUncheckedCreateWithoutAuditLogsInput
    >;
    connectOrCreate?: usersCreateOrConnectWithoutAuditLogsInput;
    upsert?: usersUpsertWithoutAuditLogsInput;
    connect?: usersWhereUniqueInput;
    update?: XOR<
      XOR<
        usersUpdateToOneWithWhereWithoutAuditLogsInput,
        usersUpdateWithoutAuditLogsInput
      >,
      usersUncheckedUpdateWithoutAuditLogsInput
    >;
  };

  export type statusUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<
      statusCreateWithoutAuditLogsInput,
      statusUncheckedCreateWithoutAuditLogsInput
    >;
    connectOrCreate?: statusCreateOrConnectWithoutAuditLogsInput;
    upsert?: statusUpsertWithoutAuditLogsInput;
    connect?: statusWhereUniqueInput;
    update?: XOR<
      XOR<
        statusUpdateToOneWithWhereWithoutAuditLogsInput,
        statusUpdateWithoutAuditLogsInput
      >,
      statusUncheckedUpdateWithoutAuditLogsInput
    >;
  };

  export type usersCreateNestedOneWithoutPhoneNumbersInput = {
    create?: XOR<
      usersCreateWithoutPhoneNumbersInput,
      usersUncheckedCreateWithoutPhoneNumbersInput
    >;
    connectOrCreate?: usersCreateOrConnectWithoutPhoneNumbersInput;
    connect?: usersWhereUniqueInput;
  };

  export type statusCreateNestedOneWithoutPhoneNumbersInput = {
    create?: XOR<
      statusCreateWithoutPhoneNumbersInput,
      statusUncheckedCreateWithoutPhoneNumbersInput
    >;
    connectOrCreate?: statusCreateOrConnectWithoutPhoneNumbersInput;
    connect?: statusWhereUniqueInput;
  };

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean;
  };

  export type usersUpdateOneRequiredWithoutPhoneNumbersNestedInput = {
    create?: XOR<
      usersCreateWithoutPhoneNumbersInput,
      usersUncheckedCreateWithoutPhoneNumbersInput
    >;
    connectOrCreate?: usersCreateOrConnectWithoutPhoneNumbersInput;
    upsert?: usersUpsertWithoutPhoneNumbersInput;
    connect?: usersWhereUniqueInput;
    update?: XOR<
      XOR<
        usersUpdateToOneWithWhereWithoutPhoneNumbersInput,
        usersUpdateWithoutPhoneNumbersInput
      >,
      usersUncheckedUpdateWithoutPhoneNumbersInput
    >;
  };

  export type statusUpdateOneRequiredWithoutPhoneNumbersNestedInput = {
    create?: XOR<
      statusCreateWithoutPhoneNumbersInput,
      statusUncheckedCreateWithoutPhoneNumbersInput
    >;
    connectOrCreate?: statusCreateOrConnectWithoutPhoneNumbersInput;
    upsert?: statusUpsertWithoutPhoneNumbersInput;
    connect?: statusWhereUniqueInput;
    update?: XOR<
      XOR<
        statusUpdateToOneWithWhereWithoutPhoneNumbersInput,
        statusUpdateWithoutPhoneNumbersInput
      >,
      statusUncheckedUpdateWithoutPhoneNumbersInput
    >;
  };

  export type usersCreateNestedOneWithoutEmailsInput = {
    create?: XOR<
      usersCreateWithoutEmailsInput,
      usersUncheckedCreateWithoutEmailsInput
    >;
    connectOrCreate?: usersCreateOrConnectWithoutEmailsInput;
    connect?: usersWhereUniqueInput;
  };

  export type statusCreateNestedOneWithoutEmailsInput = {
    create?: XOR<
      statusCreateWithoutEmailsInput,
      statusUncheckedCreateWithoutEmailsInput
    >;
    connectOrCreate?: statusCreateOrConnectWithoutEmailsInput;
    connect?: statusWhereUniqueInput;
  };

  export type usersUpdateOneRequiredWithoutEmailsNestedInput = {
    create?: XOR<
      usersCreateWithoutEmailsInput,
      usersUncheckedCreateWithoutEmailsInput
    >;
    connectOrCreate?: usersCreateOrConnectWithoutEmailsInput;
    upsert?: usersUpsertWithoutEmailsInput;
    connect?: usersWhereUniqueInput;
    update?: XOR<
      XOR<
        usersUpdateToOneWithWhereWithoutEmailsInput,
        usersUpdateWithoutEmailsInput
      >,
      usersUncheckedUpdateWithoutEmailsInput
    >;
  };

  export type statusUpdateOneRequiredWithoutEmailsNestedInput = {
    create?: XOR<
      statusCreateWithoutEmailsInput,
      statusUncheckedCreateWithoutEmailsInput
    >;
    connectOrCreate?: statusCreateOrConnectWithoutEmailsInput;
    upsert?: statusUpsertWithoutEmailsInput;
    connect?: statusWhereUniqueInput;
    update?: XOR<
      XOR<
        statusUpdateToOneWithWhereWithoutEmailsInput,
        statusUpdateWithoutEmailsInput
      >,
      statusUncheckedUpdateWithoutEmailsInput
    >;
  };

  export type usersCreateNestedOneWithoutUserRolesInput = {
    create?: XOR<
      usersCreateWithoutUserRolesInput,
      usersUncheckedCreateWithoutUserRolesInput
    >;
    connectOrCreate?: usersCreateOrConnectWithoutUserRolesInput;
    connect?: usersWhereUniqueInput;
  };

  export type roleCreateNestedOneWithoutUserRolesInput = {
    create?: XOR<
      roleCreateWithoutUserRolesInput,
      roleUncheckedCreateWithoutUserRolesInput
    >;
    connectOrCreate?: roleCreateOrConnectWithoutUserRolesInput;
    connect?: roleWhereUniqueInput;
  };

  export type usersUpdateOneRequiredWithoutUserRolesNestedInput = {
    create?: XOR<
      usersCreateWithoutUserRolesInput,
      usersUncheckedCreateWithoutUserRolesInput
    >;
    connectOrCreate?: usersCreateOrConnectWithoutUserRolesInput;
    upsert?: usersUpsertWithoutUserRolesInput;
    connect?: usersWhereUniqueInput;
    update?: XOR<
      XOR<
        usersUpdateToOneWithWhereWithoutUserRolesInput,
        usersUpdateWithoutUserRolesInput
      >,
      usersUncheckedUpdateWithoutUserRolesInput
    >;
  };

  export type roleUpdateOneRequiredWithoutUserRolesNestedInput = {
    create?: XOR<
      roleCreateWithoutUserRolesInput,
      roleUncheckedCreateWithoutUserRolesInput
    >;
    connectOrCreate?: roleCreateOrConnectWithoutUserRolesInput;
    upsert?: roleUpsertWithoutUserRolesInput;
    connect?: roleWhereUniqueInput;
    update?: XOR<
      XOR<
        roleUpdateToOneWithWhereWithoutUserRolesInput,
        roleUpdateWithoutUserRolesInput
      >,
      roleUncheckedUpdateWithoutUserRolesInput
    >;
  };

  export type IntFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type userRoleCreateNestedManyWithoutRoleInput = {
    create?:
      | XOR<
          userRoleCreateWithoutRoleInput,
          userRoleUncheckedCreateWithoutRoleInput
        >
      | userRoleCreateWithoutRoleInput[]
      | userRoleUncheckedCreateWithoutRoleInput[];
    connectOrCreate?:
      | userRoleCreateOrConnectWithoutRoleInput
      | userRoleCreateOrConnectWithoutRoleInput[];
    createMany?: userRoleCreateManyRoleInputEnvelope;
    connect?: userRoleWhereUniqueInput | userRoleWhereUniqueInput[];
  };

  export type statusCreateNestedOneWithoutRolesInput = {
    create?: XOR<
      statusCreateWithoutRolesInput,
      statusUncheckedCreateWithoutRolesInput
    >;
    connectOrCreate?: statusCreateOrConnectWithoutRolesInput;
    connect?: statusWhereUniqueInput;
  };

  export type userRoleUncheckedCreateNestedManyWithoutRoleInput = {
    create?:
      | XOR<
          userRoleCreateWithoutRoleInput,
          userRoleUncheckedCreateWithoutRoleInput
        >
      | userRoleCreateWithoutRoleInput[]
      | userRoleUncheckedCreateWithoutRoleInput[];
    connectOrCreate?:
      | userRoleCreateOrConnectWithoutRoleInput
      | userRoleCreateOrConnectWithoutRoleInput[];
    createMany?: userRoleCreateManyRoleInputEnvelope;
    connect?: userRoleWhereUniqueInput | userRoleWhereUniqueInput[];
  };

  export type userRoleUpdateManyWithoutRoleNestedInput = {
    create?:
      | XOR<
          userRoleCreateWithoutRoleInput,
          userRoleUncheckedCreateWithoutRoleInput
        >
      | userRoleCreateWithoutRoleInput[]
      | userRoleUncheckedCreateWithoutRoleInput[];
    connectOrCreate?:
      | userRoleCreateOrConnectWithoutRoleInput
      | userRoleCreateOrConnectWithoutRoleInput[];
    upsert?:
      | userRoleUpsertWithWhereUniqueWithoutRoleInput
      | userRoleUpsertWithWhereUniqueWithoutRoleInput[];
    createMany?: userRoleCreateManyRoleInputEnvelope;
    set?: userRoleWhereUniqueInput | userRoleWhereUniqueInput[];
    disconnect?: userRoleWhereUniqueInput | userRoleWhereUniqueInput[];
    delete?: userRoleWhereUniqueInput | userRoleWhereUniqueInput[];
    connect?: userRoleWhereUniqueInput | userRoleWhereUniqueInput[];
    update?:
      | userRoleUpdateWithWhereUniqueWithoutRoleInput
      | userRoleUpdateWithWhereUniqueWithoutRoleInput[];
    updateMany?:
      | userRoleUpdateManyWithWhereWithoutRoleInput
      | userRoleUpdateManyWithWhereWithoutRoleInput[];
    deleteMany?: userRoleScalarWhereInput | userRoleScalarWhereInput[];
  };

  export type statusUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<
      statusCreateWithoutRolesInput,
      statusUncheckedCreateWithoutRolesInput
    >;
    connectOrCreate?: statusCreateOrConnectWithoutRolesInput;
    upsert?: statusUpsertWithoutRolesInput;
    connect?: statusWhereUniqueInput;
    update?: XOR<
      XOR<
        statusUpdateToOneWithWhereWithoutRolesInput,
        statusUpdateWithoutRolesInput
      >,
      statusUncheckedUpdateWithoutRolesInput
    >;
  };

  export type userRoleUncheckedUpdateManyWithoutRoleNestedInput = {
    create?:
      | XOR<
          userRoleCreateWithoutRoleInput,
          userRoleUncheckedCreateWithoutRoleInput
        >
      | userRoleCreateWithoutRoleInput[]
      | userRoleUncheckedCreateWithoutRoleInput[];
    connectOrCreate?:
      | userRoleCreateOrConnectWithoutRoleInput
      | userRoleCreateOrConnectWithoutRoleInput[];
    upsert?:
      | userRoleUpsertWithWhereUniqueWithoutRoleInput
      | userRoleUpsertWithWhereUniqueWithoutRoleInput[];
    createMany?: userRoleCreateManyRoleInputEnvelope;
    set?: userRoleWhereUniqueInput | userRoleWhereUniqueInput[];
    disconnect?: userRoleWhereUniqueInput | userRoleWhereUniqueInput[];
    delete?: userRoleWhereUniqueInput | userRoleWhereUniqueInput[];
    connect?: userRoleWhereUniqueInput | userRoleWhereUniqueInput[];
    update?:
      | userRoleUpdateWithWhereUniqueWithoutRoleInput
      | userRoleUpdateWithWhereUniqueWithoutRoleInput[];
    updateMany?:
      | userRoleUpdateManyWithWhereWithoutRoleInput
      | userRoleUpdateManyWithWhereWithoutRoleInput[];
    deleteMany?: userRoleScalarWhereInput | userRoleScalarWhereInput[];
  };

  export type exhibitCreateNestedManyWithoutQrCodeInput = {
    create?:
      | XOR<
          exhibitCreateWithoutQrCodeInput,
          exhibitUncheckedCreateWithoutQrCodeInput
        >
      | exhibitCreateWithoutQrCodeInput[]
      | exhibitUncheckedCreateWithoutQrCodeInput[];
    connectOrCreate?:
      | exhibitCreateOrConnectWithoutQrCodeInput
      | exhibitCreateOrConnectWithoutQrCodeInput[];
    createMany?: exhibitCreateManyQrCodeInputEnvelope;
    connect?: exhibitWhereUniqueInput | exhibitWhereUniqueInput[];
  };

  export type statusCreateNestedOneWithoutQrcodesInput = {
    create?: XOR<
      statusCreateWithoutQrcodesInput,
      statusUncheckedCreateWithoutQrcodesInput
    >;
    connectOrCreate?: statusCreateOrConnectWithoutQrcodesInput;
    connect?: statusWhereUniqueInput;
  };

  export type exhibitUncheckedCreateNestedManyWithoutQrCodeInput = {
    create?:
      | XOR<
          exhibitCreateWithoutQrCodeInput,
          exhibitUncheckedCreateWithoutQrCodeInput
        >
      | exhibitCreateWithoutQrCodeInput[]
      | exhibitUncheckedCreateWithoutQrCodeInput[];
    connectOrCreate?:
      | exhibitCreateOrConnectWithoutQrCodeInput
      | exhibitCreateOrConnectWithoutQrCodeInput[];
    createMany?: exhibitCreateManyQrCodeInputEnvelope;
    connect?: exhibitWhereUniqueInput | exhibitWhereUniqueInput[];
  };

  export type exhibitUpdateManyWithoutQrCodeNestedInput = {
    create?:
      | XOR<
          exhibitCreateWithoutQrCodeInput,
          exhibitUncheckedCreateWithoutQrCodeInput
        >
      | exhibitCreateWithoutQrCodeInput[]
      | exhibitUncheckedCreateWithoutQrCodeInput[];
    connectOrCreate?:
      | exhibitCreateOrConnectWithoutQrCodeInput
      | exhibitCreateOrConnectWithoutQrCodeInput[];
    upsert?:
      | exhibitUpsertWithWhereUniqueWithoutQrCodeInput
      | exhibitUpsertWithWhereUniqueWithoutQrCodeInput[];
    createMany?: exhibitCreateManyQrCodeInputEnvelope;
    set?: exhibitWhereUniqueInput | exhibitWhereUniqueInput[];
    disconnect?: exhibitWhereUniqueInput | exhibitWhereUniqueInput[];
    delete?: exhibitWhereUniqueInput | exhibitWhereUniqueInput[];
    connect?: exhibitWhereUniqueInput | exhibitWhereUniqueInput[];
    update?:
      | exhibitUpdateWithWhereUniqueWithoutQrCodeInput
      | exhibitUpdateWithWhereUniqueWithoutQrCodeInput[];
    updateMany?:
      | exhibitUpdateManyWithWhereWithoutQrCodeInput
      | exhibitUpdateManyWithWhereWithoutQrCodeInput[];
    deleteMany?: exhibitScalarWhereInput | exhibitScalarWhereInput[];
  };

  export type statusUpdateOneRequiredWithoutQrcodesNestedInput = {
    create?: XOR<
      statusCreateWithoutQrcodesInput,
      statusUncheckedCreateWithoutQrcodesInput
    >;
    connectOrCreate?: statusCreateOrConnectWithoutQrcodesInput;
    upsert?: statusUpsertWithoutQrcodesInput;
    connect?: statusWhereUniqueInput;
    update?: XOR<
      XOR<
        statusUpdateToOneWithWhereWithoutQrcodesInput,
        statusUpdateWithoutQrcodesInput
      >,
      statusUncheckedUpdateWithoutQrcodesInput
    >;
  };

  export type exhibitUncheckedUpdateManyWithoutQrCodeNestedInput = {
    create?:
      | XOR<
          exhibitCreateWithoutQrCodeInput,
          exhibitUncheckedCreateWithoutQrCodeInput
        >
      | exhibitCreateWithoutQrCodeInput[]
      | exhibitUncheckedCreateWithoutQrCodeInput[];
    connectOrCreate?:
      | exhibitCreateOrConnectWithoutQrCodeInput
      | exhibitCreateOrConnectWithoutQrCodeInput[];
    upsert?:
      | exhibitUpsertWithWhereUniqueWithoutQrCodeInput
      | exhibitUpsertWithWhereUniqueWithoutQrCodeInput[];
    createMany?: exhibitCreateManyQrCodeInputEnvelope;
    set?: exhibitWhereUniqueInput | exhibitWhereUniqueInput[];
    disconnect?: exhibitWhereUniqueInput | exhibitWhereUniqueInput[];
    delete?: exhibitWhereUniqueInput | exhibitWhereUniqueInput[];
    connect?: exhibitWhereUniqueInput | exhibitWhereUniqueInput[];
    update?:
      | exhibitUpdateWithWhereUniqueWithoutQrCodeInput
      | exhibitUpdateWithWhereUniqueWithoutQrCodeInput[];
    updateMany?:
      | exhibitUpdateManyWithWhereWithoutQrCodeInput
      | exhibitUpdateManyWithWhereWithoutQrCodeInput[];
    deleteMany?: exhibitScalarWhereInput | exhibitScalarWhereInput[];
  };

  export type exhibitCreateNestedManyWithoutImageInput = {
    create?:
      | XOR<
          exhibitCreateWithoutImageInput,
          exhibitUncheckedCreateWithoutImageInput
        >
      | exhibitCreateWithoutImageInput[]
      | exhibitUncheckedCreateWithoutImageInput[];
    connectOrCreate?:
      | exhibitCreateOrConnectWithoutImageInput
      | exhibitCreateOrConnectWithoutImageInput[];
    createMany?: exhibitCreateManyImageInputEnvelope;
    connect?: exhibitWhereUniqueInput | exhibitWhereUniqueInput[];
  };

  export type statusCreateNestedOneWithoutImagesInput = {
    create?: XOR<
      statusCreateWithoutImagesInput,
      statusUncheckedCreateWithoutImagesInput
    >;
    connectOrCreate?: statusCreateOrConnectWithoutImagesInput;
    connect?: statusWhereUniqueInput;
  };

  export type exhibitUncheckedCreateNestedManyWithoutImageInput = {
    create?:
      | XOR<
          exhibitCreateWithoutImageInput,
          exhibitUncheckedCreateWithoutImageInput
        >
      | exhibitCreateWithoutImageInput[]
      | exhibitUncheckedCreateWithoutImageInput[];
    connectOrCreate?:
      | exhibitCreateOrConnectWithoutImageInput
      | exhibitCreateOrConnectWithoutImageInput[];
    createMany?: exhibitCreateManyImageInputEnvelope;
    connect?: exhibitWhereUniqueInput | exhibitWhereUniqueInput[];
  };

  export type exhibitUpdateManyWithoutImageNestedInput = {
    create?:
      | XOR<
          exhibitCreateWithoutImageInput,
          exhibitUncheckedCreateWithoutImageInput
        >
      | exhibitCreateWithoutImageInput[]
      | exhibitUncheckedCreateWithoutImageInput[];
    connectOrCreate?:
      | exhibitCreateOrConnectWithoutImageInput
      | exhibitCreateOrConnectWithoutImageInput[];
    upsert?:
      | exhibitUpsertWithWhereUniqueWithoutImageInput
      | exhibitUpsertWithWhereUniqueWithoutImageInput[];
    createMany?: exhibitCreateManyImageInputEnvelope;
    set?: exhibitWhereUniqueInput | exhibitWhereUniqueInput[];
    disconnect?: exhibitWhereUniqueInput | exhibitWhereUniqueInput[];
    delete?: exhibitWhereUniqueInput | exhibitWhereUniqueInput[];
    connect?: exhibitWhereUniqueInput | exhibitWhereUniqueInput[];
    update?:
      | exhibitUpdateWithWhereUniqueWithoutImageInput
      | exhibitUpdateWithWhereUniqueWithoutImageInput[];
    updateMany?:
      | exhibitUpdateManyWithWhereWithoutImageInput
      | exhibitUpdateManyWithWhereWithoutImageInput[];
    deleteMany?: exhibitScalarWhereInput | exhibitScalarWhereInput[];
  };

  export type statusUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<
      statusCreateWithoutImagesInput,
      statusUncheckedCreateWithoutImagesInput
    >;
    connectOrCreate?: statusCreateOrConnectWithoutImagesInput;
    upsert?: statusUpsertWithoutImagesInput;
    connect?: statusWhereUniqueInput;
    update?: XOR<
      XOR<
        statusUpdateToOneWithWhereWithoutImagesInput,
        statusUpdateWithoutImagesInput
      >,
      statusUncheckedUpdateWithoutImagesInput
    >;
  };

  export type exhibitUncheckedUpdateManyWithoutImageNestedInput = {
    create?:
      | XOR<
          exhibitCreateWithoutImageInput,
          exhibitUncheckedCreateWithoutImageInput
        >
      | exhibitCreateWithoutImageInput[]
      | exhibitUncheckedCreateWithoutImageInput[];
    connectOrCreate?:
      | exhibitCreateOrConnectWithoutImageInput
      | exhibitCreateOrConnectWithoutImageInput[];
    upsert?:
      | exhibitUpsertWithWhereUniqueWithoutImageInput
      | exhibitUpsertWithWhereUniqueWithoutImageInput[];
    createMany?: exhibitCreateManyImageInputEnvelope;
    set?: exhibitWhereUniqueInput | exhibitWhereUniqueInput[];
    disconnect?: exhibitWhereUniqueInput | exhibitWhereUniqueInput[];
    delete?: exhibitWhereUniqueInput | exhibitWhereUniqueInput[];
    connect?: exhibitWhereUniqueInput | exhibitWhereUniqueInput[];
    update?:
      | exhibitUpdateWithWhereUniqueWithoutImageInput
      | exhibitUpdateWithWhereUniqueWithoutImageInput[];
    updateMany?:
      | exhibitUpdateManyWithWhereWithoutImageInput
      | exhibitUpdateManyWithWhereWithoutImageInput[];
    deleteMany?: exhibitScalarWhereInput | exhibitScalarWhereInput[];
  };

  export type sessionCreateNestedOneWithoutEventsInput = {
    create?: XOR<
      sessionCreateWithoutEventsInput,
      sessionUncheckedCreateWithoutEventsInput
    >;
    connectOrCreate?: sessionCreateOrConnectWithoutEventsInput;
    connect?: sessionWhereUniqueInput;
  };

  export type usersCreateNestedOneWithoutEventsInput = {
    create?: XOR<
      usersCreateWithoutEventsInput,
      usersUncheckedCreateWithoutEventsInput
    >;
    connectOrCreate?: usersCreateOrConnectWithoutEventsInput;
    connect?: usersWhereUniqueInput;
  };

  export type sessionUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<
      sessionCreateWithoutEventsInput,
      sessionUncheckedCreateWithoutEventsInput
    >;
    connectOrCreate?: sessionCreateOrConnectWithoutEventsInput;
    upsert?: sessionUpsertWithoutEventsInput;
    connect?: sessionWhereUniqueInput;
    update?: XOR<
      XOR<
        sessionUpdateToOneWithWhereWithoutEventsInput,
        sessionUpdateWithoutEventsInput
      >,
      sessionUncheckedUpdateWithoutEventsInput
    >;
  };

  export type usersUpdateOneWithoutEventsNestedInput = {
    create?: XOR<
      usersCreateWithoutEventsInput,
      usersUncheckedCreateWithoutEventsInput
    >;
    connectOrCreate?: usersCreateOrConnectWithoutEventsInput;
    upsert?: usersUpsertWithoutEventsInput;
    disconnect?: usersWhereInput | boolean;
    delete?: usersWhereInput | boolean;
    connect?: usersWhereUniqueInput;
    update?: XOR<
      XOR<
        usersUpdateToOneWithWhereWithoutEventsInput,
        usersUpdateWithoutEventsInput
      >,
      usersUncheckedUpdateWithoutEventsInput
    >;
  };

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null;
  };

  export type usersCreateNestedOneWithoutSessionsInput = {
    create?: XOR<
      usersCreateWithoutSessionsInput,
      usersUncheckedCreateWithoutSessionsInput
    >;
    connectOrCreate?: usersCreateOrConnectWithoutSessionsInput;
    connect?: usersWhereUniqueInput;
  };

  export type eventCreateNestedManyWithoutSessionInput = {
    create?:
      | XOR<
          eventCreateWithoutSessionInput,
          eventUncheckedCreateWithoutSessionInput
        >
      | eventCreateWithoutSessionInput[]
      | eventUncheckedCreateWithoutSessionInput[];
    connectOrCreate?:
      | eventCreateOrConnectWithoutSessionInput
      | eventCreateOrConnectWithoutSessionInput[];
    createMany?: eventCreateManySessionInputEnvelope;
    connect?: eventWhereUniqueInput | eventWhereUniqueInput[];
  };

  export type eventUncheckedCreateNestedManyWithoutSessionInput = {
    create?:
      | XOR<
          eventCreateWithoutSessionInput,
          eventUncheckedCreateWithoutSessionInput
        >
      | eventCreateWithoutSessionInput[]
      | eventUncheckedCreateWithoutSessionInput[];
    connectOrCreate?:
      | eventCreateOrConnectWithoutSessionInput
      | eventCreateOrConnectWithoutSessionInput[];
    createMany?: eventCreateManySessionInputEnvelope;
    connect?: eventWhereUniqueInput | eventWhereUniqueInput[];
  };

  export type usersUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<
      usersCreateWithoutSessionsInput,
      usersUncheckedCreateWithoutSessionsInput
    >;
    connectOrCreate?: usersCreateOrConnectWithoutSessionsInput;
    upsert?: usersUpsertWithoutSessionsInput;
    connect?: usersWhereUniqueInput;
    update?: XOR<
      XOR<
        usersUpdateToOneWithWhereWithoutSessionsInput,
        usersUpdateWithoutSessionsInput
      >,
      usersUncheckedUpdateWithoutSessionsInput
    >;
  };

  export type eventUpdateManyWithoutSessionNestedInput = {
    create?:
      | XOR<
          eventCreateWithoutSessionInput,
          eventUncheckedCreateWithoutSessionInput
        >
      | eventCreateWithoutSessionInput[]
      | eventUncheckedCreateWithoutSessionInput[];
    connectOrCreate?:
      | eventCreateOrConnectWithoutSessionInput
      | eventCreateOrConnectWithoutSessionInput[];
    upsert?:
      | eventUpsertWithWhereUniqueWithoutSessionInput
      | eventUpsertWithWhereUniqueWithoutSessionInput[];
    createMany?: eventCreateManySessionInputEnvelope;
    set?: eventWhereUniqueInput | eventWhereUniqueInput[];
    disconnect?: eventWhereUniqueInput | eventWhereUniqueInput[];
    delete?: eventWhereUniqueInput | eventWhereUniqueInput[];
    connect?: eventWhereUniqueInput | eventWhereUniqueInput[];
    update?:
      | eventUpdateWithWhereUniqueWithoutSessionInput
      | eventUpdateWithWhereUniqueWithoutSessionInput[];
    updateMany?:
      | eventUpdateManyWithWhereWithoutSessionInput
      | eventUpdateManyWithWhereWithoutSessionInput[];
    deleteMany?: eventScalarWhereInput | eventScalarWhereInput[];
  };

  export type eventUncheckedUpdateManyWithoutSessionNestedInput = {
    create?:
      | XOR<
          eventCreateWithoutSessionInput,
          eventUncheckedCreateWithoutSessionInput
        >
      | eventCreateWithoutSessionInput[]
      | eventUncheckedCreateWithoutSessionInput[];
    connectOrCreate?:
      | eventCreateOrConnectWithoutSessionInput
      | eventCreateOrConnectWithoutSessionInput[];
    upsert?:
      | eventUpsertWithWhereUniqueWithoutSessionInput
      | eventUpsertWithWhereUniqueWithoutSessionInput[];
    createMany?: eventCreateManySessionInputEnvelope;
    set?: eventWhereUniqueInput | eventWhereUniqueInput[];
    disconnect?: eventWhereUniqueInput | eventWhereUniqueInput[];
    delete?: eventWhereUniqueInput | eventWhereUniqueInput[];
    connect?: eventWhereUniqueInput | eventWhereUniqueInput[];
    update?:
      | eventUpdateWithWhereUniqueWithoutSessionInput
      | eventUpdateWithWhereUniqueWithoutSessionInput[];
    updateMany?:
      | eventUpdateManyWithWhereWithoutSessionInput
      | eventUpdateManyWithWhereWithoutSessionInput[];
    deleteMany?: eventScalarWhereInput | eventScalarWhereInput[];
  };

  export type usersCreateNestedOneWithoutUserProfileInput = {
    create?: XOR<
      usersCreateWithoutUserProfileInput,
      usersUncheckedCreateWithoutUserProfileInput
    >;
    connectOrCreate?: usersCreateOrConnectWithoutUserProfileInput;
    connect?: usersWhereUniqueInput;
  };

  export type languageCreateNestedOneWithoutProfilesInput = {
    create?: XOR<
      languageCreateWithoutProfilesInput,
      languageUncheckedCreateWithoutProfilesInput
    >;
    connectOrCreate?: languageCreateOrConnectWithoutProfilesInput;
    connect?: languageWhereUniqueInput;
  };

  export type statusCreateNestedOneWithoutUserProfilesInput = {
    create?: XOR<
      statusCreateWithoutUserProfilesInput,
      statusUncheckedCreateWithoutUserProfilesInput
    >;
    connectOrCreate?: statusCreateOrConnectWithoutUserProfilesInput;
    connect?: statusWhereUniqueInput;
  };

  export type usersUpdateOneRequiredWithoutUserProfileNestedInput = {
    create?: XOR<
      usersCreateWithoutUserProfileInput,
      usersUncheckedCreateWithoutUserProfileInput
    >;
    connectOrCreate?: usersCreateOrConnectWithoutUserProfileInput;
    upsert?: usersUpsertWithoutUserProfileInput;
    connect?: usersWhereUniqueInput;
    update?: XOR<
      XOR<
        usersUpdateToOneWithWhereWithoutUserProfileInput,
        usersUpdateWithoutUserProfileInput
      >,
      usersUncheckedUpdateWithoutUserProfileInput
    >;
  };

  export type languageUpdateOneRequiredWithoutProfilesNestedInput = {
    create?: XOR<
      languageCreateWithoutProfilesInput,
      languageUncheckedCreateWithoutProfilesInput
    >;
    connectOrCreate?: languageCreateOrConnectWithoutProfilesInput;
    upsert?: languageUpsertWithoutProfilesInput;
    connect?: languageWhereUniqueInput;
    update?: XOR<
      XOR<
        languageUpdateToOneWithWhereWithoutProfilesInput,
        languageUpdateWithoutProfilesInput
      >,
      languageUncheckedUpdateWithoutProfilesInput
    >;
  };

  export type statusUpdateOneRequiredWithoutUserProfilesNestedInput = {
    create?: XOR<
      statusCreateWithoutUserProfilesInput,
      statusUncheckedCreateWithoutUserProfilesInput
    >;
    connectOrCreate?: statusCreateOrConnectWithoutUserProfilesInput;
    upsert?: statusUpsertWithoutUserProfilesInput;
    connect?: statusWhereUniqueInput;
    update?: XOR<
      XOR<
        statusUpdateToOneWithWhereWithoutUserProfilesInput,
        statusUpdateWithoutUserProfilesInput
      >,
      statusUncheckedUpdateWithoutUserProfilesInput
    >;
  };

  export type audioCreateNestedManyWithoutLanguageInput = {
    create?:
      | XOR<
          audioCreateWithoutLanguageInput,
          audioUncheckedCreateWithoutLanguageInput
        >
      | audioCreateWithoutLanguageInput[]
      | audioUncheckedCreateWithoutLanguageInput[];
    connectOrCreate?:
      | audioCreateOrConnectWithoutLanguageInput
      | audioCreateOrConnectWithoutLanguageInput[];
    createMany?: audioCreateManyLanguageInputEnvelope;
    connect?: audioWhereUniqueInput | audioWhereUniqueInput[];
  };

  export type userProfileCreateNestedManyWithoutLanguageInput = {
    create?:
      | XOR<
          userProfileCreateWithoutLanguageInput,
          userProfileUncheckedCreateWithoutLanguageInput
        >
      | userProfileCreateWithoutLanguageInput[]
      | userProfileUncheckedCreateWithoutLanguageInput[];
    connectOrCreate?:
      | userProfileCreateOrConnectWithoutLanguageInput
      | userProfileCreateOrConnectWithoutLanguageInput[];
    createMany?: userProfileCreateManyLanguageInputEnvelope;
    connect?: userProfileWhereUniqueInput | userProfileWhereUniqueInput[];
  };

  export type subtitleCreateNestedManyWithoutLanguageInput = {
    create?:
      | XOR<
          subtitleCreateWithoutLanguageInput,
          subtitleUncheckedCreateWithoutLanguageInput
        >
      | subtitleCreateWithoutLanguageInput[]
      | subtitleUncheckedCreateWithoutLanguageInput[];
    connectOrCreate?:
      | subtitleCreateOrConnectWithoutLanguageInput
      | subtitleCreateOrConnectWithoutLanguageInput[];
    createMany?: subtitleCreateManyLanguageInputEnvelope;
    connect?: subtitleWhereUniqueInput | subtitleWhereUniqueInput[];
  };

  export type statusCreateNestedOneWithoutLanguagesInput = {
    create?: XOR<
      statusCreateWithoutLanguagesInput,
      statusUncheckedCreateWithoutLanguagesInput
    >;
    connectOrCreate?: statusCreateOrConnectWithoutLanguagesInput;
    connect?: statusWhereUniqueInput;
  };

  export type audioUncheckedCreateNestedManyWithoutLanguageInput = {
    create?:
      | XOR<
          audioCreateWithoutLanguageInput,
          audioUncheckedCreateWithoutLanguageInput
        >
      | audioCreateWithoutLanguageInput[]
      | audioUncheckedCreateWithoutLanguageInput[];
    connectOrCreate?:
      | audioCreateOrConnectWithoutLanguageInput
      | audioCreateOrConnectWithoutLanguageInput[];
    createMany?: audioCreateManyLanguageInputEnvelope;
    connect?: audioWhereUniqueInput | audioWhereUniqueInput[];
  };

  export type userProfileUncheckedCreateNestedManyWithoutLanguageInput = {
    create?:
      | XOR<
          userProfileCreateWithoutLanguageInput,
          userProfileUncheckedCreateWithoutLanguageInput
        >
      | userProfileCreateWithoutLanguageInput[]
      | userProfileUncheckedCreateWithoutLanguageInput[];
    connectOrCreate?:
      | userProfileCreateOrConnectWithoutLanguageInput
      | userProfileCreateOrConnectWithoutLanguageInput[];
    createMany?: userProfileCreateManyLanguageInputEnvelope;
    connect?: userProfileWhereUniqueInput | userProfileWhereUniqueInput[];
  };

  export type subtitleUncheckedCreateNestedManyWithoutLanguageInput = {
    create?:
      | XOR<
          subtitleCreateWithoutLanguageInput,
          subtitleUncheckedCreateWithoutLanguageInput
        >
      | subtitleCreateWithoutLanguageInput[]
      | subtitleUncheckedCreateWithoutLanguageInput[];
    connectOrCreate?:
      | subtitleCreateOrConnectWithoutLanguageInput
      | subtitleCreateOrConnectWithoutLanguageInput[];
    createMany?: subtitleCreateManyLanguageInputEnvelope;
    connect?: subtitleWhereUniqueInput | subtitleWhereUniqueInput[];
  };

  export type audioUpdateManyWithoutLanguageNestedInput = {
    create?:
      | XOR<
          audioCreateWithoutLanguageInput,
          audioUncheckedCreateWithoutLanguageInput
        >
      | audioCreateWithoutLanguageInput[]
      | audioUncheckedCreateWithoutLanguageInput[];
    connectOrCreate?:
      | audioCreateOrConnectWithoutLanguageInput
      | audioCreateOrConnectWithoutLanguageInput[];
    upsert?:
      | audioUpsertWithWhereUniqueWithoutLanguageInput
      | audioUpsertWithWhereUniqueWithoutLanguageInput[];
    createMany?: audioCreateManyLanguageInputEnvelope;
    set?: audioWhereUniqueInput | audioWhereUniqueInput[];
    disconnect?: audioWhereUniqueInput | audioWhereUniqueInput[];
    delete?: audioWhereUniqueInput | audioWhereUniqueInput[];
    connect?: audioWhereUniqueInput | audioWhereUniqueInput[];
    update?:
      | audioUpdateWithWhereUniqueWithoutLanguageInput
      | audioUpdateWithWhereUniqueWithoutLanguageInput[];
    updateMany?:
      | audioUpdateManyWithWhereWithoutLanguageInput
      | audioUpdateManyWithWhereWithoutLanguageInput[];
    deleteMany?: audioScalarWhereInput | audioScalarWhereInput[];
  };

  export type userProfileUpdateManyWithoutLanguageNestedInput = {
    create?:
      | XOR<
          userProfileCreateWithoutLanguageInput,
          userProfileUncheckedCreateWithoutLanguageInput
        >
      | userProfileCreateWithoutLanguageInput[]
      | userProfileUncheckedCreateWithoutLanguageInput[];
    connectOrCreate?:
      | userProfileCreateOrConnectWithoutLanguageInput
      | userProfileCreateOrConnectWithoutLanguageInput[];
    upsert?:
      | userProfileUpsertWithWhereUniqueWithoutLanguageInput
      | userProfileUpsertWithWhereUniqueWithoutLanguageInput[];
    createMany?: userProfileCreateManyLanguageInputEnvelope;
    set?: userProfileWhereUniqueInput | userProfileWhereUniqueInput[];
    disconnect?: userProfileWhereUniqueInput | userProfileWhereUniqueInput[];
    delete?: userProfileWhereUniqueInput | userProfileWhereUniqueInput[];
    connect?: userProfileWhereUniqueInput | userProfileWhereUniqueInput[];
    update?:
      | userProfileUpdateWithWhereUniqueWithoutLanguageInput
      | userProfileUpdateWithWhereUniqueWithoutLanguageInput[];
    updateMany?:
      | userProfileUpdateManyWithWhereWithoutLanguageInput
      | userProfileUpdateManyWithWhereWithoutLanguageInput[];
    deleteMany?: userProfileScalarWhereInput | userProfileScalarWhereInput[];
  };

  export type subtitleUpdateManyWithoutLanguageNestedInput = {
    create?:
      | XOR<
          subtitleCreateWithoutLanguageInput,
          subtitleUncheckedCreateWithoutLanguageInput
        >
      | subtitleCreateWithoutLanguageInput[]
      | subtitleUncheckedCreateWithoutLanguageInput[];
    connectOrCreate?:
      | subtitleCreateOrConnectWithoutLanguageInput
      | subtitleCreateOrConnectWithoutLanguageInput[];
    upsert?:
      | subtitleUpsertWithWhereUniqueWithoutLanguageInput
      | subtitleUpsertWithWhereUniqueWithoutLanguageInput[];
    createMany?: subtitleCreateManyLanguageInputEnvelope;
    set?: subtitleWhereUniqueInput | subtitleWhereUniqueInput[];
    disconnect?: subtitleWhereUniqueInput | subtitleWhereUniqueInput[];
    delete?: subtitleWhereUniqueInput | subtitleWhereUniqueInput[];
    connect?: subtitleWhereUniqueInput | subtitleWhereUniqueInput[];
    update?:
      | subtitleUpdateWithWhereUniqueWithoutLanguageInput
      | subtitleUpdateWithWhereUniqueWithoutLanguageInput[];
    updateMany?:
      | subtitleUpdateManyWithWhereWithoutLanguageInput
      | subtitleUpdateManyWithWhereWithoutLanguageInput[];
    deleteMany?: subtitleScalarWhereInput | subtitleScalarWhereInput[];
  };

  export type statusUpdateOneRequiredWithoutLanguagesNestedInput = {
    create?: XOR<
      statusCreateWithoutLanguagesInput,
      statusUncheckedCreateWithoutLanguagesInput
    >;
    connectOrCreate?: statusCreateOrConnectWithoutLanguagesInput;
    upsert?: statusUpsertWithoutLanguagesInput;
    connect?: statusWhereUniqueInput;
    update?: XOR<
      XOR<
        statusUpdateToOneWithWhereWithoutLanguagesInput,
        statusUpdateWithoutLanguagesInput
      >,
      statusUncheckedUpdateWithoutLanguagesInput
    >;
  };

  export type audioUncheckedUpdateManyWithoutLanguageNestedInput = {
    create?:
      | XOR<
          audioCreateWithoutLanguageInput,
          audioUncheckedCreateWithoutLanguageInput
        >
      | audioCreateWithoutLanguageInput[]
      | audioUncheckedCreateWithoutLanguageInput[];
    connectOrCreate?:
      | audioCreateOrConnectWithoutLanguageInput
      | audioCreateOrConnectWithoutLanguageInput[];
    upsert?:
      | audioUpsertWithWhereUniqueWithoutLanguageInput
      | audioUpsertWithWhereUniqueWithoutLanguageInput[];
    createMany?: audioCreateManyLanguageInputEnvelope;
    set?: audioWhereUniqueInput | audioWhereUniqueInput[];
    disconnect?: audioWhereUniqueInput | audioWhereUniqueInput[];
    delete?: audioWhereUniqueInput | audioWhereUniqueInput[];
    connect?: audioWhereUniqueInput | audioWhereUniqueInput[];
    update?:
      | audioUpdateWithWhereUniqueWithoutLanguageInput
      | audioUpdateWithWhereUniqueWithoutLanguageInput[];
    updateMany?:
      | audioUpdateManyWithWhereWithoutLanguageInput
      | audioUpdateManyWithWhereWithoutLanguageInput[];
    deleteMany?: audioScalarWhereInput | audioScalarWhereInput[];
  };

  export type userProfileUncheckedUpdateManyWithoutLanguageNestedInput = {
    create?:
      | XOR<
          userProfileCreateWithoutLanguageInput,
          userProfileUncheckedCreateWithoutLanguageInput
        >
      | userProfileCreateWithoutLanguageInput[]
      | userProfileUncheckedCreateWithoutLanguageInput[];
    connectOrCreate?:
      | userProfileCreateOrConnectWithoutLanguageInput
      | userProfileCreateOrConnectWithoutLanguageInput[];
    upsert?:
      | userProfileUpsertWithWhereUniqueWithoutLanguageInput
      | userProfileUpsertWithWhereUniqueWithoutLanguageInput[];
    createMany?: userProfileCreateManyLanguageInputEnvelope;
    set?: userProfileWhereUniqueInput | userProfileWhereUniqueInput[];
    disconnect?: userProfileWhereUniqueInput | userProfileWhereUniqueInput[];
    delete?: userProfileWhereUniqueInput | userProfileWhereUniqueInput[];
    connect?: userProfileWhereUniqueInput | userProfileWhereUniqueInput[];
    update?:
      | userProfileUpdateWithWhereUniqueWithoutLanguageInput
      | userProfileUpdateWithWhereUniqueWithoutLanguageInput[];
    updateMany?:
      | userProfileUpdateManyWithWhereWithoutLanguageInput
      | userProfileUpdateManyWithWhereWithoutLanguageInput[];
    deleteMany?: userProfileScalarWhereInput | userProfileScalarWhereInput[];
  };

  export type subtitleUncheckedUpdateManyWithoutLanguageNestedInput = {
    create?:
      | XOR<
          subtitleCreateWithoutLanguageInput,
          subtitleUncheckedCreateWithoutLanguageInput
        >
      | subtitleCreateWithoutLanguageInput[]
      | subtitleUncheckedCreateWithoutLanguageInput[];
    connectOrCreate?:
      | subtitleCreateOrConnectWithoutLanguageInput
      | subtitleCreateOrConnectWithoutLanguageInput[];
    upsert?:
      | subtitleUpsertWithWhereUniqueWithoutLanguageInput
      | subtitleUpsertWithWhereUniqueWithoutLanguageInput[];
    createMany?: subtitleCreateManyLanguageInputEnvelope;
    set?: subtitleWhereUniqueInput | subtitleWhereUniqueInput[];
    disconnect?: subtitleWhereUniqueInput | subtitleWhereUniqueInput[];
    delete?: subtitleWhereUniqueInput | subtitleWhereUniqueInput[];
    connect?: subtitleWhereUniqueInput | subtitleWhereUniqueInput[];
    update?:
      | subtitleUpdateWithWhereUniqueWithoutLanguageInput
      | subtitleUpdateWithWhereUniqueWithoutLanguageInput[];
    updateMany?:
      | subtitleUpdateManyWithWhereWithoutLanguageInput
      | subtitleUpdateManyWithWhereWithoutLanguageInput[];
    deleteMany?: subtitleScalarWhereInput | subtitleScalarWhereInput[];
  };

  export type languageCreateNestedOneWithoutSubtitlesInput = {
    create?: XOR<
      languageCreateWithoutSubtitlesInput,
      languageUncheckedCreateWithoutSubtitlesInput
    >;
    connectOrCreate?: languageCreateOrConnectWithoutSubtitlesInput;
    connect?: languageWhereUniqueInput;
  };

  export type statusCreateNestedOneWithoutSubtitlesInput = {
    create?: XOR<
      statusCreateWithoutSubtitlesInput,
      statusUncheckedCreateWithoutSubtitlesInput
    >;
    connectOrCreate?: statusCreateOrConnectWithoutSubtitlesInput;
    connect?: statusWhereUniqueInput;
  };

  export type exhibitSubtitleCreateNestedManyWithoutSubtitleInput = {
    create?:
      | XOR<
          exhibitSubtitleCreateWithoutSubtitleInput,
          exhibitSubtitleUncheckedCreateWithoutSubtitleInput
        >
      | exhibitSubtitleCreateWithoutSubtitleInput[]
      | exhibitSubtitleUncheckedCreateWithoutSubtitleInput[];
    connectOrCreate?:
      | exhibitSubtitleCreateOrConnectWithoutSubtitleInput
      | exhibitSubtitleCreateOrConnectWithoutSubtitleInput[];
    createMany?: exhibitSubtitleCreateManySubtitleInputEnvelope;
    connect?:
      | exhibitSubtitleWhereUniqueInput
      | exhibitSubtitleWhereUniqueInput[];
  };

  export type exhibitSubtitleUncheckedCreateNestedManyWithoutSubtitleInput = {
    create?:
      | XOR<
          exhibitSubtitleCreateWithoutSubtitleInput,
          exhibitSubtitleUncheckedCreateWithoutSubtitleInput
        >
      | exhibitSubtitleCreateWithoutSubtitleInput[]
      | exhibitSubtitleUncheckedCreateWithoutSubtitleInput[];
    connectOrCreate?:
      | exhibitSubtitleCreateOrConnectWithoutSubtitleInput
      | exhibitSubtitleCreateOrConnectWithoutSubtitleInput[];
    createMany?: exhibitSubtitleCreateManySubtitleInputEnvelope;
    connect?:
      | exhibitSubtitleWhereUniqueInput
      | exhibitSubtitleWhereUniqueInput[];
  };

  export type languageUpdateOneRequiredWithoutSubtitlesNestedInput = {
    create?: XOR<
      languageCreateWithoutSubtitlesInput,
      languageUncheckedCreateWithoutSubtitlesInput
    >;
    connectOrCreate?: languageCreateOrConnectWithoutSubtitlesInput;
    upsert?: languageUpsertWithoutSubtitlesInput;
    connect?: languageWhereUniqueInput;
    update?: XOR<
      XOR<
        languageUpdateToOneWithWhereWithoutSubtitlesInput,
        languageUpdateWithoutSubtitlesInput
      >,
      languageUncheckedUpdateWithoutSubtitlesInput
    >;
  };

  export type statusUpdateOneRequiredWithoutSubtitlesNestedInput = {
    create?: XOR<
      statusCreateWithoutSubtitlesInput,
      statusUncheckedCreateWithoutSubtitlesInput
    >;
    connectOrCreate?: statusCreateOrConnectWithoutSubtitlesInput;
    upsert?: statusUpsertWithoutSubtitlesInput;
    connect?: statusWhereUniqueInput;
    update?: XOR<
      XOR<
        statusUpdateToOneWithWhereWithoutSubtitlesInput,
        statusUpdateWithoutSubtitlesInput
      >,
      statusUncheckedUpdateWithoutSubtitlesInput
    >;
  };

  export type exhibitSubtitleUpdateManyWithoutSubtitleNestedInput = {
    create?:
      | XOR<
          exhibitSubtitleCreateWithoutSubtitleInput,
          exhibitSubtitleUncheckedCreateWithoutSubtitleInput
        >
      | exhibitSubtitleCreateWithoutSubtitleInput[]
      | exhibitSubtitleUncheckedCreateWithoutSubtitleInput[];
    connectOrCreate?:
      | exhibitSubtitleCreateOrConnectWithoutSubtitleInput
      | exhibitSubtitleCreateOrConnectWithoutSubtitleInput[];
    upsert?:
      | exhibitSubtitleUpsertWithWhereUniqueWithoutSubtitleInput
      | exhibitSubtitleUpsertWithWhereUniqueWithoutSubtitleInput[];
    createMany?: exhibitSubtitleCreateManySubtitleInputEnvelope;
    set?: exhibitSubtitleWhereUniqueInput | exhibitSubtitleWhereUniqueInput[];
    disconnect?:
      | exhibitSubtitleWhereUniqueInput
      | exhibitSubtitleWhereUniqueInput[];
    delete?:
      | exhibitSubtitleWhereUniqueInput
      | exhibitSubtitleWhereUniqueInput[];
    connect?:
      | exhibitSubtitleWhereUniqueInput
      | exhibitSubtitleWhereUniqueInput[];
    update?:
      | exhibitSubtitleUpdateWithWhereUniqueWithoutSubtitleInput
      | exhibitSubtitleUpdateWithWhereUniqueWithoutSubtitleInput[];
    updateMany?:
      | exhibitSubtitleUpdateManyWithWhereWithoutSubtitleInput
      | exhibitSubtitleUpdateManyWithWhereWithoutSubtitleInput[];
    deleteMany?:
      | exhibitSubtitleScalarWhereInput
      | exhibitSubtitleScalarWhereInput[];
  };

  export type exhibitSubtitleUncheckedUpdateManyWithoutSubtitleNestedInput = {
    create?:
      | XOR<
          exhibitSubtitleCreateWithoutSubtitleInput,
          exhibitSubtitleUncheckedCreateWithoutSubtitleInput
        >
      | exhibitSubtitleCreateWithoutSubtitleInput[]
      | exhibitSubtitleUncheckedCreateWithoutSubtitleInput[];
    connectOrCreate?:
      | exhibitSubtitleCreateOrConnectWithoutSubtitleInput
      | exhibitSubtitleCreateOrConnectWithoutSubtitleInput[];
    upsert?:
      | exhibitSubtitleUpsertWithWhereUniqueWithoutSubtitleInput
      | exhibitSubtitleUpsertWithWhereUniqueWithoutSubtitleInput[];
    createMany?: exhibitSubtitleCreateManySubtitleInputEnvelope;
    set?: exhibitSubtitleWhereUniqueInput | exhibitSubtitleWhereUniqueInput[];
    disconnect?:
      | exhibitSubtitleWhereUniqueInput
      | exhibitSubtitleWhereUniqueInput[];
    delete?:
      | exhibitSubtitleWhereUniqueInput
      | exhibitSubtitleWhereUniqueInput[];
    connect?:
      | exhibitSubtitleWhereUniqueInput
      | exhibitSubtitleWhereUniqueInput[];
    update?:
      | exhibitSubtitleUpdateWithWhereUniqueWithoutSubtitleInput
      | exhibitSubtitleUpdateWithWhereUniqueWithoutSubtitleInput[];
    updateMany?:
      | exhibitSubtitleUpdateManyWithWhereWithoutSubtitleInput
      | exhibitSubtitleUpdateManyWithWhereWithoutSubtitleInput[];
    deleteMany?:
      | exhibitSubtitleScalarWhereInput
      | exhibitSubtitleScalarWhereInput[];
  };

  export type exhibitCreateNestedOneWithoutSubtitlesInput = {
    create?: XOR<
      exhibitCreateWithoutSubtitlesInput,
      exhibitUncheckedCreateWithoutSubtitlesInput
    >;
    connectOrCreate?: exhibitCreateOrConnectWithoutSubtitlesInput;
    connect?: exhibitWhereUniqueInput;
  };

  export type subtitleCreateNestedOneWithoutExhibitsInput = {
    create?: XOR<
      subtitleCreateWithoutExhibitsInput,
      subtitleUncheckedCreateWithoutExhibitsInput
    >;
    connectOrCreate?: subtitleCreateOrConnectWithoutExhibitsInput;
    connect?: subtitleWhereUniqueInput;
  };

  export type exhibitUpdateOneRequiredWithoutSubtitlesNestedInput = {
    create?: XOR<
      exhibitCreateWithoutSubtitlesInput,
      exhibitUncheckedCreateWithoutSubtitlesInput
    >;
    connectOrCreate?: exhibitCreateOrConnectWithoutSubtitlesInput;
    upsert?: exhibitUpsertWithoutSubtitlesInput;
    connect?: exhibitWhereUniqueInput;
    update?: XOR<
      XOR<
        exhibitUpdateToOneWithWhereWithoutSubtitlesInput,
        exhibitUpdateWithoutSubtitlesInput
      >,
      exhibitUncheckedUpdateWithoutSubtitlesInput
    >;
  };

  export type subtitleUpdateOneRequiredWithoutExhibitsNestedInput = {
    create?: XOR<
      subtitleCreateWithoutExhibitsInput,
      subtitleUncheckedCreateWithoutExhibitsInput
    >;
    connectOrCreate?: subtitleCreateOrConnectWithoutExhibitsInput;
    upsert?: subtitleUpsertWithoutExhibitsInput;
    connect?: subtitleWhereUniqueInput;
    update?: XOR<
      XOR<
        subtitleUpdateToOneWithWhereWithoutExhibitsInput,
        subtitleUpdateWithoutExhibitsInput
      >,
      subtitleUncheckedUpdateWithoutExhibitsInput
    >;
  };

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedUuidFilter<$PrismaModel> | string;
  };

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatFilter<$PrismaModel> | number;
  };

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null;
  };

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type phoneNumberCreateWithoutUserInput = {
    phoneNumberId?: string;
    phoneNumber: string;
    verified: boolean;
    isPrimary: boolean;
    createdAt: Date | string;
    status: statusCreateNestedOneWithoutPhoneNumbersInput;
  };

  export type phoneNumberUncheckedCreateWithoutUserInput = {
    phoneNumberId?: string;
    phoneNumber: string;
    verified: boolean;
    isPrimary: boolean;
    createdAt: Date | string;
    statusCode: string;
  };

  export type phoneNumberCreateOrConnectWithoutUserInput = {
    where: phoneNumberWhereUniqueInput;
    create: XOR<
      phoneNumberCreateWithoutUserInput,
      phoneNumberUncheckedCreateWithoutUserInput
    >;
  };

  export type phoneNumberCreateManyUserInputEnvelope = {
    data: phoneNumberCreateManyUserInput | phoneNumberCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type emailCreateWithoutUserInput = {
    emailId?: string;
    email: string;
    verified: boolean;
    isPrimary: boolean;
    createdAt: Date | string;
    status: statusCreateNestedOneWithoutEmailsInput;
  };

  export type emailUncheckedCreateWithoutUserInput = {
    emailId?: string;
    email: string;
    verified: boolean;
    isPrimary: boolean;
    createdAt: Date | string;
    statusCode: string;
  };

  export type emailCreateOrConnectWithoutUserInput = {
    where: emailWhereUniqueInput;
    create: XOR<
      emailCreateWithoutUserInput,
      emailUncheckedCreateWithoutUserInput
    >;
  };

  export type emailCreateManyUserInputEnvelope = {
    data: emailCreateManyUserInput | emailCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type userProfileCreateWithoutUserInput = {
    userProfileId?: string;
    fName: string;
    lName: string;
    gender: string;
    dob: Date | string;
    modifiedBy: string;
    createdBy: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    language: languageCreateNestedOneWithoutProfilesInput;
    status: statusCreateNestedOneWithoutUserProfilesInput;
  };

  export type userProfileUncheckedCreateWithoutUserInput = {
    userProfileId?: string;
    fName: string;
    lName: string;
    languageCode: string;
    gender: string;
    dob: Date | string;
    modifiedBy: string;
    createdBy: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    statusCode: string;
  };

  export type userProfileCreateOrConnectWithoutUserInput = {
    where: userProfileWhereUniqueInput;
    create: XOR<
      userProfileCreateWithoutUserInput,
      userProfileUncheckedCreateWithoutUserInput
    >;
  };

  export type sessionCreateWithoutUserInput = {
    sessionId?: string;
    deviceInfo: string;
    isActive: boolean;
    createdAt: Date | string;
    events?: eventCreateNestedManyWithoutSessionInput;
  };

  export type sessionUncheckedCreateWithoutUserInput = {
    sessionId?: string;
    deviceInfo: string;
    isActive: boolean;
    createdAt: Date | string;
    events?: eventUncheckedCreateNestedManyWithoutSessionInput;
  };

  export type sessionCreateOrConnectWithoutUserInput = {
    where: sessionWhereUniqueInput;
    create: XOR<
      sessionCreateWithoutUserInput,
      sessionUncheckedCreateWithoutUserInput
    >;
  };

  export type sessionCreateManyUserInputEnvelope = {
    data: sessionCreateManyUserInput | sessionCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type auditLogCreateWithoutUserInput = {
    auditLogId?: string;
    ipAddress: string;
    entityName: string;
    entityId: string;
    actionType: string;
    oldValue: string;
    newValue: string;
    timestamp: Date | string;
    status: statusCreateNestedOneWithoutAuditLogsInput;
  };

  export type auditLogUncheckedCreateWithoutUserInput = {
    auditLogId?: string;
    ipAddress: string;
    entityName: string;
    entityId: string;
    actionType: string;
    oldValue: string;
    newValue: string;
    timestamp: Date | string;
    statusCode: string;
  };

  export type auditLogCreateOrConnectWithoutUserInput = {
    where: auditLogWhereUniqueInput;
    create: XOR<
      auditLogCreateWithoutUserInput,
      auditLogUncheckedCreateWithoutUserInput
    >;
  };

  export type auditLogCreateManyUserInputEnvelope = {
    data: auditLogCreateManyUserInput | auditLogCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type eventCreateWithoutUsersInput = {
    eventId?: string;
    entityId: number;
    entityName: string;
    timestamp: Date | string;
    session: sessionCreateNestedOneWithoutEventsInput;
  };

  export type eventUncheckedCreateWithoutUsersInput = {
    eventId?: string;
    sessionId: string;
    entityId: number;
    entityName: string;
    timestamp: Date | string;
  };

  export type eventCreateOrConnectWithoutUsersInput = {
    where: eventWhereUniqueInput;
    create: XOR<
      eventCreateWithoutUsersInput,
      eventUncheckedCreateWithoutUsersInput
    >;
  };

  export type eventCreateManyUsersInputEnvelope = {
    data: eventCreateManyUsersInput | eventCreateManyUsersInput[];
    skipDuplicates?: boolean;
  };

  export type userRoleCreateWithoutUserInput = {
    role: roleCreateNestedOneWithoutUserRolesInput;
  };

  export type userRoleUncheckedCreateWithoutUserInput = {
    roleId: number;
  };

  export type userRoleCreateOrConnectWithoutUserInput = {
    where: userRoleWhereUniqueInput;
    create: XOR<
      userRoleCreateWithoutUserInput,
      userRoleUncheckedCreateWithoutUserInput
    >;
  };

  export type userRoleCreateManyUserInputEnvelope = {
    data: userRoleCreateManyUserInput | userRoleCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type statusCreateWithoutUsersInput = {
    statusCode: string;
    description: string;
    audios?: audioCreateNestedManyWithoutStatusInput;
    exhibits?: exhibitCreateNestedManyWithoutStatusInput;
    phoneNumbers?: phoneNumberCreateNestedManyWithoutStatusInput;
    emails?: emailCreateNestedManyWithoutStatusInput;
    roles?: roleCreateNestedManyWithoutStatusInput;
    qrcodes?: qrCodeCreateNestedManyWithoutStatusInput;
    images?: imageCreateNestedManyWithoutStatusInput;
    subtitles?: subtitleCreateNestedManyWithoutStatusInput;
    languages?: languageCreateNestedManyWithoutStatusInput;
    auditLogs?: auditLogCreateNestedManyWithoutStatusInput;
    userProfiles?: userProfileCreateNestedManyWithoutStatusInput;
  };

  export type statusUncheckedCreateWithoutUsersInput = {
    statusCode: string;
    description: string;
    audios?: audioUncheckedCreateNestedManyWithoutStatusInput;
    exhibits?: exhibitUncheckedCreateNestedManyWithoutStatusInput;
    phoneNumbers?: phoneNumberUncheckedCreateNestedManyWithoutStatusInput;
    emails?: emailUncheckedCreateNestedManyWithoutStatusInput;
    roles?: roleUncheckedCreateNestedManyWithoutStatusInput;
    qrcodes?: qrCodeUncheckedCreateNestedManyWithoutStatusInput;
    images?: imageUncheckedCreateNestedManyWithoutStatusInput;
    subtitles?: subtitleUncheckedCreateNestedManyWithoutStatusInput;
    languages?: languageUncheckedCreateNestedManyWithoutStatusInput;
    auditLogs?: auditLogUncheckedCreateNestedManyWithoutStatusInput;
    userProfiles?: userProfileUncheckedCreateNestedManyWithoutStatusInput;
  };

  export type statusCreateOrConnectWithoutUsersInput = {
    where: statusWhereUniqueInput;
    create: XOR<
      statusCreateWithoutUsersInput,
      statusUncheckedCreateWithoutUsersInput
    >;
  };

  export type phoneNumberUpsertWithWhereUniqueWithoutUserInput = {
    where: phoneNumberWhereUniqueInput;
    update: XOR<
      phoneNumberUpdateWithoutUserInput,
      phoneNumberUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      phoneNumberCreateWithoutUserInput,
      phoneNumberUncheckedCreateWithoutUserInput
    >;
  };

  export type phoneNumberUpdateWithWhereUniqueWithoutUserInput = {
    where: phoneNumberWhereUniqueInput;
    data: XOR<
      phoneNumberUpdateWithoutUserInput,
      phoneNumberUncheckedUpdateWithoutUserInput
    >;
  };

  export type phoneNumberUpdateManyWithWhereWithoutUserInput = {
    where: phoneNumberScalarWhereInput;
    data: XOR<
      phoneNumberUpdateManyMutationInput,
      phoneNumberUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type phoneNumberScalarWhereInput = {
    AND?: phoneNumberScalarWhereInput | phoneNumberScalarWhereInput[];
    OR?: phoneNumberScalarWhereInput[];
    NOT?: phoneNumberScalarWhereInput | phoneNumberScalarWhereInput[];
    phoneNumberId?: UuidFilter<"phoneNumber"> | string;
    userId?: UuidFilter<"phoneNumber"> | string;
    phoneNumber?: StringFilter<"phoneNumber"> | string;
    verified?: BoolFilter<"phoneNumber"> | boolean;
    isPrimary?: BoolFilter<"phoneNumber"> | boolean;
    createdAt?: DateTimeFilter<"phoneNumber"> | Date | string;
    statusCode?: StringFilter<"phoneNumber"> | string;
  };

  export type emailUpsertWithWhereUniqueWithoutUserInput = {
    where: emailWhereUniqueInput;
    update: XOR<
      emailUpdateWithoutUserInput,
      emailUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      emailCreateWithoutUserInput,
      emailUncheckedCreateWithoutUserInput
    >;
  };

  export type emailUpdateWithWhereUniqueWithoutUserInput = {
    where: emailWhereUniqueInput;
    data: XOR<
      emailUpdateWithoutUserInput,
      emailUncheckedUpdateWithoutUserInput
    >;
  };

  export type emailUpdateManyWithWhereWithoutUserInput = {
    where: emailScalarWhereInput;
    data: XOR<
      emailUpdateManyMutationInput,
      emailUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type emailScalarWhereInput = {
    AND?: emailScalarWhereInput | emailScalarWhereInput[];
    OR?: emailScalarWhereInput[];
    NOT?: emailScalarWhereInput | emailScalarWhereInput[];
    emailId?: UuidFilter<"email"> | string;
    userId?: UuidFilter<"email"> | string;
    email?: StringFilter<"email"> | string;
    verified?: BoolFilter<"email"> | boolean;
    isPrimary?: BoolFilter<"email"> | boolean;
    createdAt?: DateTimeFilter<"email"> | Date | string;
    statusCode?: StringFilter<"email"> | string;
  };

  export type userProfileUpsertWithoutUserInput = {
    update: XOR<
      userProfileUpdateWithoutUserInput,
      userProfileUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      userProfileCreateWithoutUserInput,
      userProfileUncheckedCreateWithoutUserInput
    >;
    where?: userProfileWhereInput;
  };

  export type userProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: userProfileWhereInput;
    data: XOR<
      userProfileUpdateWithoutUserInput,
      userProfileUncheckedUpdateWithoutUserInput
    >;
  };

  export type userProfileUpdateWithoutUserInput = {
    userProfileId?: StringFieldUpdateOperationsInput | string;
    fName?: StringFieldUpdateOperationsInput | string;
    lName?: StringFieldUpdateOperationsInput | string;
    gender?: StringFieldUpdateOperationsInput | string;
    dob?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedBy?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    language?: languageUpdateOneRequiredWithoutProfilesNestedInput;
    status?: statusUpdateOneRequiredWithoutUserProfilesNestedInput;
  };

  export type userProfileUncheckedUpdateWithoutUserInput = {
    userProfileId?: StringFieldUpdateOperationsInput | string;
    fName?: StringFieldUpdateOperationsInput | string;
    lName?: StringFieldUpdateOperationsInput | string;
    languageCode?: StringFieldUpdateOperationsInput | string;
    gender?: StringFieldUpdateOperationsInput | string;
    dob?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedBy?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
  };

  export type sessionUpsertWithWhereUniqueWithoutUserInput = {
    where: sessionWhereUniqueInput;
    update: XOR<
      sessionUpdateWithoutUserInput,
      sessionUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      sessionCreateWithoutUserInput,
      sessionUncheckedCreateWithoutUserInput
    >;
  };

  export type sessionUpdateWithWhereUniqueWithoutUserInput = {
    where: sessionWhereUniqueInput;
    data: XOR<
      sessionUpdateWithoutUserInput,
      sessionUncheckedUpdateWithoutUserInput
    >;
  };

  export type sessionUpdateManyWithWhereWithoutUserInput = {
    where: sessionScalarWhereInput;
    data: XOR<
      sessionUpdateManyMutationInput,
      sessionUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type sessionScalarWhereInput = {
    AND?: sessionScalarWhereInput | sessionScalarWhereInput[];
    OR?: sessionScalarWhereInput[];
    NOT?: sessionScalarWhereInput | sessionScalarWhereInput[];
    sessionId?: UuidFilter<"session"> | string;
    userId?: UuidFilter<"session"> | string;
    deviceInfo?: StringFilter<"session"> | string;
    isActive?: BoolFilter<"session"> | boolean;
    createdAt?: DateTimeFilter<"session"> | Date | string;
  };

  export type auditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: auditLogWhereUniqueInput;
    update: XOR<
      auditLogUpdateWithoutUserInput,
      auditLogUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      auditLogCreateWithoutUserInput,
      auditLogUncheckedCreateWithoutUserInput
    >;
  };

  export type auditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: auditLogWhereUniqueInput;
    data: XOR<
      auditLogUpdateWithoutUserInput,
      auditLogUncheckedUpdateWithoutUserInput
    >;
  };

  export type auditLogUpdateManyWithWhereWithoutUserInput = {
    where: auditLogScalarWhereInput;
    data: XOR<
      auditLogUpdateManyMutationInput,
      auditLogUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type auditLogScalarWhereInput = {
    AND?: auditLogScalarWhereInput | auditLogScalarWhereInput[];
    OR?: auditLogScalarWhereInput[];
    NOT?: auditLogScalarWhereInput | auditLogScalarWhereInput[];
    auditLogId?: UuidFilter<"auditLog"> | string;
    userId?: UuidFilter<"auditLog"> | string;
    ipAddress?: StringFilter<"auditLog"> | string;
    entityName?: StringFilter<"auditLog"> | string;
    entityId?: StringFilter<"auditLog"> | string;
    actionType?: StringFilter<"auditLog"> | string;
    oldValue?: StringFilter<"auditLog"> | string;
    newValue?: StringFilter<"auditLog"> | string;
    timestamp?: DateTimeFilter<"auditLog"> | Date | string;
    statusCode?: StringFilter<"auditLog"> | string;
  };

  export type eventUpsertWithWhereUniqueWithoutUsersInput = {
    where: eventWhereUniqueInput;
    update: XOR<
      eventUpdateWithoutUsersInput,
      eventUncheckedUpdateWithoutUsersInput
    >;
    create: XOR<
      eventCreateWithoutUsersInput,
      eventUncheckedCreateWithoutUsersInput
    >;
  };

  export type eventUpdateWithWhereUniqueWithoutUsersInput = {
    where: eventWhereUniqueInput;
    data: XOR<
      eventUpdateWithoutUsersInput,
      eventUncheckedUpdateWithoutUsersInput
    >;
  };

  export type eventUpdateManyWithWhereWithoutUsersInput = {
    where: eventScalarWhereInput;
    data: XOR<
      eventUpdateManyMutationInput,
      eventUncheckedUpdateManyWithoutUsersInput
    >;
  };

  export type eventScalarWhereInput = {
    AND?: eventScalarWhereInput | eventScalarWhereInput[];
    OR?: eventScalarWhereInput[];
    NOT?: eventScalarWhereInput | eventScalarWhereInput[];
    eventId?: UuidFilter<"event"> | string;
    sessionId?: UuidFilter<"event"> | string;
    entityId?: IntFilter<"event"> | number;
    entityName?: StringFilter<"event"> | string;
    timestamp?: DateTimeFilter<"event"> | Date | string;
    usersUserId?: UuidNullableFilter<"event"> | string | null;
  };

  export type userRoleUpsertWithWhereUniqueWithoutUserInput = {
    where: userRoleWhereUniqueInput;
    update: XOR<
      userRoleUpdateWithoutUserInput,
      userRoleUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      userRoleCreateWithoutUserInput,
      userRoleUncheckedCreateWithoutUserInput
    >;
  };

  export type userRoleUpdateWithWhereUniqueWithoutUserInput = {
    where: userRoleWhereUniqueInput;
    data: XOR<
      userRoleUpdateWithoutUserInput,
      userRoleUncheckedUpdateWithoutUserInput
    >;
  };

  export type userRoleUpdateManyWithWhereWithoutUserInput = {
    where: userRoleScalarWhereInput;
    data: XOR<
      userRoleUpdateManyMutationInput,
      userRoleUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type userRoleScalarWhereInput = {
    AND?: userRoleScalarWhereInput | userRoleScalarWhereInput[];
    OR?: userRoleScalarWhereInput[];
    NOT?: userRoleScalarWhereInput | userRoleScalarWhereInput[];
    userId?: UuidFilter<"userRole"> | string;
    roleId?: IntFilter<"userRole"> | number;
  };

  export type statusUpsertWithoutUsersInput = {
    update: XOR<
      statusUpdateWithoutUsersInput,
      statusUncheckedUpdateWithoutUsersInput
    >;
    create: XOR<
      statusCreateWithoutUsersInput,
      statusUncheckedCreateWithoutUsersInput
    >;
    where?: statusWhereInput;
  };

  export type statusUpdateToOneWithWhereWithoutUsersInput = {
    where?: statusWhereInput;
    data: XOR<
      statusUpdateWithoutUsersInput,
      statusUncheckedUpdateWithoutUsersInput
    >;
  };

  export type statusUpdateWithoutUsersInput = {
    statusCode?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    audios?: audioUpdateManyWithoutStatusNestedInput;
    exhibits?: exhibitUpdateManyWithoutStatusNestedInput;
    phoneNumbers?: phoneNumberUpdateManyWithoutStatusNestedInput;
    emails?: emailUpdateManyWithoutStatusNestedInput;
    roles?: roleUpdateManyWithoutStatusNestedInput;
    qrcodes?: qrCodeUpdateManyWithoutStatusNestedInput;
    images?: imageUpdateManyWithoutStatusNestedInput;
    subtitles?: subtitleUpdateManyWithoutStatusNestedInput;
    languages?: languageUpdateManyWithoutStatusNestedInput;
    auditLogs?: auditLogUpdateManyWithoutStatusNestedInput;
    userProfiles?: userProfileUpdateManyWithoutStatusNestedInput;
  };

  export type statusUncheckedUpdateWithoutUsersInput = {
    statusCode?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    audios?: audioUncheckedUpdateManyWithoutStatusNestedInput;
    exhibits?: exhibitUncheckedUpdateManyWithoutStatusNestedInput;
    phoneNumbers?: phoneNumberUncheckedUpdateManyWithoutStatusNestedInput;
    emails?: emailUncheckedUpdateManyWithoutStatusNestedInput;
    roles?: roleUncheckedUpdateManyWithoutStatusNestedInput;
    qrcodes?: qrCodeUncheckedUpdateManyWithoutStatusNestedInput;
    images?: imageUncheckedUpdateManyWithoutStatusNestedInput;
    subtitles?: subtitleUncheckedUpdateManyWithoutStatusNestedInput;
    languages?: languageUncheckedUpdateManyWithoutStatusNestedInput;
    auditLogs?: auditLogUncheckedUpdateManyWithoutStatusNestedInput;
    userProfiles?: userProfileUncheckedUpdateManyWithoutStatusNestedInput;
  };

  export type usersCreateWithoutStatusInput = {
    userId?: string;
    username: string;
    password: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    phoneNumbers?: phoneNumberCreateNestedManyWithoutUserInput;
    emails?: emailCreateNestedManyWithoutUserInput;
    userProfile?: userProfileCreateNestedOneWithoutUserInput;
    sessions?: sessionCreateNestedManyWithoutUserInput;
    auditLogs?: auditLogCreateNestedManyWithoutUserInput;
    events?: eventCreateNestedManyWithoutUsersInput;
    userRoles?: userRoleCreateNestedManyWithoutUserInput;
  };

  export type usersUncheckedCreateWithoutStatusInput = {
    userId?: string;
    username: string;
    password: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    phoneNumbers?: phoneNumberUncheckedCreateNestedManyWithoutUserInput;
    emails?: emailUncheckedCreateNestedManyWithoutUserInput;
    userProfile?: userProfileUncheckedCreateNestedOneWithoutUserInput;
    sessions?: sessionUncheckedCreateNestedManyWithoutUserInput;
    auditLogs?: auditLogUncheckedCreateNestedManyWithoutUserInput;
    events?: eventUncheckedCreateNestedManyWithoutUsersInput;
    userRoles?: userRoleUncheckedCreateNestedManyWithoutUserInput;
  };

  export type usersCreateOrConnectWithoutStatusInput = {
    where: usersWhereUniqueInput;
    create: XOR<
      usersCreateWithoutStatusInput,
      usersUncheckedCreateWithoutStatusInput
    >;
  };

  export type usersCreateManyStatusInputEnvelope = {
    data: usersCreateManyStatusInput | usersCreateManyStatusInput[];
    skipDuplicates?: boolean;
  };

  export type audioCreateWithoutStatusInput = {
    audioId?: string;
    fileUrl: string;
    description: string;
    createdBy: string;
    createdAt: Date | string;
    language: languageCreateNestedOneWithoutAudiosInput;
    exhibits?: exhibitAudioRelationCreateNestedManyWithoutAudioInput;
    exhibit?: exhibitCreateNestedManyWithoutAudioInput;
  };

  export type audioUncheckedCreateWithoutStatusInput = {
    audioId?: string;
    fileUrl: string;
    description: string;
    createdBy: string;
    languageId: string;
    createdAt: Date | string;
    exhibits?: exhibitAudioRelationUncheckedCreateNestedManyWithoutAudioInput;
    exhibit?: exhibitUncheckedCreateNestedManyWithoutAudioInput;
  };

  export type audioCreateOrConnectWithoutStatusInput = {
    where: audioWhereUniqueInput;
    create: XOR<
      audioCreateWithoutStatusInput,
      audioUncheckedCreateWithoutStatusInput
    >;
  };

  export type audioCreateManyStatusInputEnvelope = {
    data: audioCreateManyStatusInput | audioCreateManyStatusInput[];
    skipDuplicates?: boolean;
  };

  export type exhibitCreateWithoutStatusInput = {
    exhibitId?: string;
    title: string;
    description: string;
    createdBy: string;
    modifiedBy: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    audio: audioCreateNestedOneWithoutExhibitInput;
    qrCode: qrCodeCreateNestedOneWithoutExhibitInput;
    image: imageCreateNestedOneWithoutExhibitInput;
    subtitles?: exhibitSubtitleCreateNestedManyWithoutExhibitInput;
    exhibitAudioRelation?: exhibitAudioRelationCreateNestedManyWithoutExhibitInput;
  };

  export type exhibitUncheckedCreateWithoutStatusInput = {
    exhibitId?: string;
    title: string;
    description: string;
    audioId: string;
    createdBy: string;
    modifiedBy: string;
    qrCodeId: string;
    imageId: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    subtitles?: exhibitSubtitleUncheckedCreateNestedManyWithoutExhibitInput;
    exhibitAudioRelation?: exhibitAudioRelationUncheckedCreateNestedManyWithoutExhibitInput;
  };

  export type exhibitCreateOrConnectWithoutStatusInput = {
    where: exhibitWhereUniqueInput;
    create: XOR<
      exhibitCreateWithoutStatusInput,
      exhibitUncheckedCreateWithoutStatusInput
    >;
  };

  export type exhibitCreateManyStatusInputEnvelope = {
    data: exhibitCreateManyStatusInput | exhibitCreateManyStatusInput[];
    skipDuplicates?: boolean;
  };

  export type phoneNumberCreateWithoutStatusInput = {
    phoneNumberId?: string;
    phoneNumber: string;
    verified: boolean;
    isPrimary: boolean;
    createdAt: Date | string;
    user: usersCreateNestedOneWithoutPhoneNumbersInput;
  };

  export type phoneNumberUncheckedCreateWithoutStatusInput = {
    phoneNumberId?: string;
    userId: string;
    phoneNumber: string;
    verified: boolean;
    isPrimary: boolean;
    createdAt: Date | string;
  };

  export type phoneNumberCreateOrConnectWithoutStatusInput = {
    where: phoneNumberWhereUniqueInput;
    create: XOR<
      phoneNumberCreateWithoutStatusInput,
      phoneNumberUncheckedCreateWithoutStatusInput
    >;
  };

  export type phoneNumberCreateManyStatusInputEnvelope = {
    data: phoneNumberCreateManyStatusInput | phoneNumberCreateManyStatusInput[];
    skipDuplicates?: boolean;
  };

  export type emailCreateWithoutStatusInput = {
    emailId?: string;
    email: string;
    verified: boolean;
    isPrimary: boolean;
    createdAt: Date | string;
    user: usersCreateNestedOneWithoutEmailsInput;
  };

  export type emailUncheckedCreateWithoutStatusInput = {
    emailId?: string;
    userId: string;
    email: string;
    verified: boolean;
    isPrimary: boolean;
    createdAt: Date | string;
  };

  export type emailCreateOrConnectWithoutStatusInput = {
    where: emailWhereUniqueInput;
    create: XOR<
      emailCreateWithoutStatusInput,
      emailUncheckedCreateWithoutStatusInput
    >;
  };

  export type emailCreateManyStatusInputEnvelope = {
    data: emailCreateManyStatusInput | emailCreateManyStatusInput[];
    skipDuplicates?: boolean;
  };

  export type roleCreateWithoutStatusInput = {
    roleName: string;
    description: string;
    userRoles?: userRoleCreateNestedManyWithoutRoleInput;
  };

  export type roleUncheckedCreateWithoutStatusInput = {
    roleId?: number;
    roleName: string;
    description: string;
    userRoles?: userRoleUncheckedCreateNestedManyWithoutRoleInput;
  };

  export type roleCreateOrConnectWithoutStatusInput = {
    where: roleWhereUniqueInput;
    create: XOR<
      roleCreateWithoutStatusInput,
      roleUncheckedCreateWithoutStatusInput
    >;
  };

  export type roleCreateManyStatusInputEnvelope = {
    data: roleCreateManyStatusInput | roleCreateManyStatusInput[];
    skipDuplicates?: boolean;
  };

  export type qrCodeCreateWithoutStatusInput = {
    qrCodeId?: string;
    qrLink: string;
    createdBy: string;
    createdAt: Date | string;
    exhibit?: exhibitCreateNestedManyWithoutQrCodeInput;
  };

  export type qrCodeUncheckedCreateWithoutStatusInput = {
    qrCodeId?: string;
    qrLink: string;
    createdBy: string;
    createdAt: Date | string;
    exhibit?: exhibitUncheckedCreateNestedManyWithoutQrCodeInput;
  };

  export type qrCodeCreateOrConnectWithoutStatusInput = {
    where: qrCodeWhereUniqueInput;
    create: XOR<
      qrCodeCreateWithoutStatusInput,
      qrCodeUncheckedCreateWithoutStatusInput
    >;
  };

  export type qrCodeCreateManyStatusInputEnvelope = {
    data: qrCodeCreateManyStatusInput | qrCodeCreateManyStatusInput[];
    skipDuplicates?: boolean;
  };

  export type imageCreateWithoutStatusInput = {
    imageId?: string;
    description: string;
    createdBy: string;
    createdAt: Date | string;
    exhibit?: exhibitCreateNestedManyWithoutImageInput;
  };

  export type imageUncheckedCreateWithoutStatusInput = {
    imageId?: string;
    description: string;
    createdBy: string;
    createdAt: Date | string;
    exhibit?: exhibitUncheckedCreateNestedManyWithoutImageInput;
  };

  export type imageCreateOrConnectWithoutStatusInput = {
    where: imageWhereUniqueInput;
    create: XOR<
      imageCreateWithoutStatusInput,
      imageUncheckedCreateWithoutStatusInput
    >;
  };

  export type imageCreateManyStatusInputEnvelope = {
    data: imageCreateManyStatusInput | imageCreateManyStatusInput[];
    skipDuplicates?: boolean;
  };

  export type subtitleCreateWithoutStatusInput = {
    subtitleId?: string;
    subtitleText: string;
    createdBy: string;
    modifiedBy: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    language: languageCreateNestedOneWithoutSubtitlesInput;
    exhibits?: exhibitSubtitleCreateNestedManyWithoutSubtitleInput;
  };

  export type subtitleUncheckedCreateWithoutStatusInput = {
    subtitleId?: string;
    subtitleText: string;
    languageCode: string;
    createdBy: string;
    modifiedBy: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    exhibits?: exhibitSubtitleUncheckedCreateNestedManyWithoutSubtitleInput;
  };

  export type subtitleCreateOrConnectWithoutStatusInput = {
    where: subtitleWhereUniqueInput;
    create: XOR<
      subtitleCreateWithoutStatusInput,
      subtitleUncheckedCreateWithoutStatusInput
    >;
  };

  export type subtitleCreateManyStatusInputEnvelope = {
    data: subtitleCreateManyStatusInput | subtitleCreateManyStatusInput[];
    skipDuplicates?: boolean;
  };

  export type languageCreateWithoutStatusInput = {
    languageCode: string;
    languageName: string;
    audios?: audioCreateNestedManyWithoutLanguageInput;
    profiles?: userProfileCreateNestedManyWithoutLanguageInput;
    subtitles?: subtitleCreateNestedManyWithoutLanguageInput;
  };

  export type languageUncheckedCreateWithoutStatusInput = {
    languageCode: string;
    languageName: string;
    audios?: audioUncheckedCreateNestedManyWithoutLanguageInput;
    profiles?: userProfileUncheckedCreateNestedManyWithoutLanguageInput;
    subtitles?: subtitleUncheckedCreateNestedManyWithoutLanguageInput;
  };

  export type languageCreateOrConnectWithoutStatusInput = {
    where: languageWhereUniqueInput;
    create: XOR<
      languageCreateWithoutStatusInput,
      languageUncheckedCreateWithoutStatusInput
    >;
  };

  export type languageCreateManyStatusInputEnvelope = {
    data: languageCreateManyStatusInput | languageCreateManyStatusInput[];
    skipDuplicates?: boolean;
  };

  export type auditLogCreateWithoutStatusInput = {
    auditLogId?: string;
    ipAddress: string;
    entityName: string;
    entityId: string;
    actionType: string;
    oldValue: string;
    newValue: string;
    timestamp: Date | string;
    user: usersCreateNestedOneWithoutAuditLogsInput;
  };

  export type auditLogUncheckedCreateWithoutStatusInput = {
    auditLogId?: string;
    userId: string;
    ipAddress: string;
    entityName: string;
    entityId: string;
    actionType: string;
    oldValue: string;
    newValue: string;
    timestamp: Date | string;
  };

  export type auditLogCreateOrConnectWithoutStatusInput = {
    where: auditLogWhereUniqueInput;
    create: XOR<
      auditLogCreateWithoutStatusInput,
      auditLogUncheckedCreateWithoutStatusInput
    >;
  };

  export type auditLogCreateManyStatusInputEnvelope = {
    data: auditLogCreateManyStatusInput | auditLogCreateManyStatusInput[];
    skipDuplicates?: boolean;
  };

  export type userProfileCreateWithoutStatusInput = {
    userProfileId?: string;
    fName: string;
    lName: string;
    gender: string;
    dob: Date | string;
    modifiedBy: string;
    createdBy: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    user: usersCreateNestedOneWithoutUserProfileInput;
    language: languageCreateNestedOneWithoutProfilesInput;
  };

  export type userProfileUncheckedCreateWithoutStatusInput = {
    userProfileId?: string;
    userId: string;
    fName: string;
    lName: string;
    languageCode: string;
    gender: string;
    dob: Date | string;
    modifiedBy: string;
    createdBy: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
  };

  export type userProfileCreateOrConnectWithoutStatusInput = {
    where: userProfileWhereUniqueInput;
    create: XOR<
      userProfileCreateWithoutStatusInput,
      userProfileUncheckedCreateWithoutStatusInput
    >;
  };

  export type userProfileCreateManyStatusInputEnvelope = {
    data: userProfileCreateManyStatusInput | userProfileCreateManyStatusInput[];
    skipDuplicates?: boolean;
  };

  export type usersUpsertWithWhereUniqueWithoutStatusInput = {
    where: usersWhereUniqueInput;
    update: XOR<
      usersUpdateWithoutStatusInput,
      usersUncheckedUpdateWithoutStatusInput
    >;
    create: XOR<
      usersCreateWithoutStatusInput,
      usersUncheckedCreateWithoutStatusInput
    >;
  };

  export type usersUpdateWithWhereUniqueWithoutStatusInput = {
    where: usersWhereUniqueInput;
    data: XOR<
      usersUpdateWithoutStatusInput,
      usersUncheckedUpdateWithoutStatusInput
    >;
  };

  export type usersUpdateManyWithWhereWithoutStatusInput = {
    where: usersScalarWhereInput;
    data: XOR<
      usersUpdateManyMutationInput,
      usersUncheckedUpdateManyWithoutStatusInput
    >;
  };

  export type usersScalarWhereInput = {
    AND?: usersScalarWhereInput | usersScalarWhereInput[];
    OR?: usersScalarWhereInput[];
    NOT?: usersScalarWhereInput | usersScalarWhereInput[];
    userId?: UuidFilter<"users"> | string;
    username?: StringFilter<"users"> | string;
    password?: StringFilter<"users"> | string;
    createdAt?: DateTimeFilter<"users"> | Date | string;
    modifiedAt?: DateTimeFilter<"users"> | Date | string;
    statusCode?: StringFilter<"users"> | string;
  };

  export type audioUpsertWithWhereUniqueWithoutStatusInput = {
    where: audioWhereUniqueInput;
    update: XOR<
      audioUpdateWithoutStatusInput,
      audioUncheckedUpdateWithoutStatusInput
    >;
    create: XOR<
      audioCreateWithoutStatusInput,
      audioUncheckedCreateWithoutStatusInput
    >;
  };

  export type audioUpdateWithWhereUniqueWithoutStatusInput = {
    where: audioWhereUniqueInput;
    data: XOR<
      audioUpdateWithoutStatusInput,
      audioUncheckedUpdateWithoutStatusInput
    >;
  };

  export type audioUpdateManyWithWhereWithoutStatusInput = {
    where: audioScalarWhereInput;
    data: XOR<
      audioUpdateManyMutationInput,
      audioUncheckedUpdateManyWithoutStatusInput
    >;
  };

  export type audioScalarWhereInput = {
    AND?: audioScalarWhereInput | audioScalarWhereInput[];
    OR?: audioScalarWhereInput[];
    NOT?: audioScalarWhereInput | audioScalarWhereInput[];
    audioId?: UuidFilter<"audio"> | string;
    fileUrl?: StringFilter<"audio"> | string;
    description?: StringFilter<"audio"> | string;
    createdBy?: UuidFilter<"audio"> | string;
    languageId?: StringFilter<"audio"> | string;
    createdAt?: DateTimeFilter<"audio"> | Date | string;
    statusCode?: StringFilter<"audio"> | string;
  };

  export type exhibitUpsertWithWhereUniqueWithoutStatusInput = {
    where: exhibitWhereUniqueInput;
    update: XOR<
      exhibitUpdateWithoutStatusInput,
      exhibitUncheckedUpdateWithoutStatusInput
    >;
    create: XOR<
      exhibitCreateWithoutStatusInput,
      exhibitUncheckedCreateWithoutStatusInput
    >;
  };

  export type exhibitUpdateWithWhereUniqueWithoutStatusInput = {
    where: exhibitWhereUniqueInput;
    data: XOR<
      exhibitUpdateWithoutStatusInput,
      exhibitUncheckedUpdateWithoutStatusInput
    >;
  };

  export type exhibitUpdateManyWithWhereWithoutStatusInput = {
    where: exhibitScalarWhereInput;
    data: XOR<
      exhibitUpdateManyMutationInput,
      exhibitUncheckedUpdateManyWithoutStatusInput
    >;
  };

  export type exhibitScalarWhereInput = {
    AND?: exhibitScalarWhereInput | exhibitScalarWhereInput[];
    OR?: exhibitScalarWhereInput[];
    NOT?: exhibitScalarWhereInput | exhibitScalarWhereInput[];
    exhibitId?: UuidFilter<"exhibit"> | string;
    title?: StringFilter<"exhibit"> | string;
    description?: StringFilter<"exhibit"> | string;
    audioId?: UuidFilter<"exhibit"> | string;
    createdBy?: UuidFilter<"exhibit"> | string;
    modifiedBy?: UuidFilter<"exhibit"> | string;
    qrCodeId?: UuidFilter<"exhibit"> | string;
    imageId?: UuidFilter<"exhibit"> | string;
    createdAt?: DateTimeFilter<"exhibit"> | Date | string;
    modifiedAt?: DateTimeFilter<"exhibit"> | Date | string;
    statusCode?: StringFilter<"exhibit"> | string;
  };

  export type phoneNumberUpsertWithWhereUniqueWithoutStatusInput = {
    where: phoneNumberWhereUniqueInput;
    update: XOR<
      phoneNumberUpdateWithoutStatusInput,
      phoneNumberUncheckedUpdateWithoutStatusInput
    >;
    create: XOR<
      phoneNumberCreateWithoutStatusInput,
      phoneNumberUncheckedCreateWithoutStatusInput
    >;
  };

  export type phoneNumberUpdateWithWhereUniqueWithoutStatusInput = {
    where: phoneNumberWhereUniqueInput;
    data: XOR<
      phoneNumberUpdateWithoutStatusInput,
      phoneNumberUncheckedUpdateWithoutStatusInput
    >;
  };

  export type phoneNumberUpdateManyWithWhereWithoutStatusInput = {
    where: phoneNumberScalarWhereInput;
    data: XOR<
      phoneNumberUpdateManyMutationInput,
      phoneNumberUncheckedUpdateManyWithoutStatusInput
    >;
  };

  export type emailUpsertWithWhereUniqueWithoutStatusInput = {
    where: emailWhereUniqueInput;
    update: XOR<
      emailUpdateWithoutStatusInput,
      emailUncheckedUpdateWithoutStatusInput
    >;
    create: XOR<
      emailCreateWithoutStatusInput,
      emailUncheckedCreateWithoutStatusInput
    >;
  };

  export type emailUpdateWithWhereUniqueWithoutStatusInput = {
    where: emailWhereUniqueInput;
    data: XOR<
      emailUpdateWithoutStatusInput,
      emailUncheckedUpdateWithoutStatusInput
    >;
  };

  export type emailUpdateManyWithWhereWithoutStatusInput = {
    where: emailScalarWhereInput;
    data: XOR<
      emailUpdateManyMutationInput,
      emailUncheckedUpdateManyWithoutStatusInput
    >;
  };

  export type roleUpsertWithWhereUniqueWithoutStatusInput = {
    where: roleWhereUniqueInput;
    update: XOR<
      roleUpdateWithoutStatusInput,
      roleUncheckedUpdateWithoutStatusInput
    >;
    create: XOR<
      roleCreateWithoutStatusInput,
      roleUncheckedCreateWithoutStatusInput
    >;
  };

  export type roleUpdateWithWhereUniqueWithoutStatusInput = {
    where: roleWhereUniqueInput;
    data: XOR<
      roleUpdateWithoutStatusInput,
      roleUncheckedUpdateWithoutStatusInput
    >;
  };

  export type roleUpdateManyWithWhereWithoutStatusInput = {
    where: roleScalarWhereInput;
    data: XOR<
      roleUpdateManyMutationInput,
      roleUncheckedUpdateManyWithoutStatusInput
    >;
  };

  export type roleScalarWhereInput = {
    AND?: roleScalarWhereInput | roleScalarWhereInput[];
    OR?: roleScalarWhereInput[];
    NOT?: roleScalarWhereInput | roleScalarWhereInput[];
    roleId?: IntFilter<"role"> | number;
    roleName?: StringFilter<"role"> | string;
    description?: StringFilter<"role"> | string;
    statusCode?: StringFilter<"role"> | string;
  };

  export type qrCodeUpsertWithWhereUniqueWithoutStatusInput = {
    where: qrCodeWhereUniqueInput;
    update: XOR<
      qrCodeUpdateWithoutStatusInput,
      qrCodeUncheckedUpdateWithoutStatusInput
    >;
    create: XOR<
      qrCodeCreateWithoutStatusInput,
      qrCodeUncheckedCreateWithoutStatusInput
    >;
  };

  export type qrCodeUpdateWithWhereUniqueWithoutStatusInput = {
    where: qrCodeWhereUniqueInput;
    data: XOR<
      qrCodeUpdateWithoutStatusInput,
      qrCodeUncheckedUpdateWithoutStatusInput
    >;
  };

  export type qrCodeUpdateManyWithWhereWithoutStatusInput = {
    where: qrCodeScalarWhereInput;
    data: XOR<
      qrCodeUpdateManyMutationInput,
      qrCodeUncheckedUpdateManyWithoutStatusInput
    >;
  };

  export type qrCodeScalarWhereInput = {
    AND?: qrCodeScalarWhereInput | qrCodeScalarWhereInput[];
    OR?: qrCodeScalarWhereInput[];
    NOT?: qrCodeScalarWhereInput | qrCodeScalarWhereInput[];
    qrCodeId?: UuidFilter<"qrCode"> | string;
    qrLink?: StringFilter<"qrCode"> | string;
    createdBy?: UuidFilter<"qrCode"> | string;
    createdAt?: DateTimeFilter<"qrCode"> | Date | string;
    statusCode?: StringFilter<"qrCode"> | string;
  };

  export type imageUpsertWithWhereUniqueWithoutStatusInput = {
    where: imageWhereUniqueInput;
    update: XOR<
      imageUpdateWithoutStatusInput,
      imageUncheckedUpdateWithoutStatusInput
    >;
    create: XOR<
      imageCreateWithoutStatusInput,
      imageUncheckedCreateWithoutStatusInput
    >;
  };

  export type imageUpdateWithWhereUniqueWithoutStatusInput = {
    where: imageWhereUniqueInput;
    data: XOR<
      imageUpdateWithoutStatusInput,
      imageUncheckedUpdateWithoutStatusInput
    >;
  };

  export type imageUpdateManyWithWhereWithoutStatusInput = {
    where: imageScalarWhereInput;
    data: XOR<
      imageUpdateManyMutationInput,
      imageUncheckedUpdateManyWithoutStatusInput
    >;
  };

  export type imageScalarWhereInput = {
    AND?: imageScalarWhereInput | imageScalarWhereInput[];
    OR?: imageScalarWhereInput[];
    NOT?: imageScalarWhereInput | imageScalarWhereInput[];
    imageId?: UuidFilter<"image"> | string;
    description?: StringFilter<"image"> | string;
    createdBy?: UuidFilter<"image"> | string;
    createdAt?: DateTimeFilter<"image"> | Date | string;
    statusCode?: StringFilter<"image"> | string;
  };

  export type subtitleUpsertWithWhereUniqueWithoutStatusInput = {
    where: subtitleWhereUniqueInput;
    update: XOR<
      subtitleUpdateWithoutStatusInput,
      subtitleUncheckedUpdateWithoutStatusInput
    >;
    create: XOR<
      subtitleCreateWithoutStatusInput,
      subtitleUncheckedCreateWithoutStatusInput
    >;
  };

  export type subtitleUpdateWithWhereUniqueWithoutStatusInput = {
    where: subtitleWhereUniqueInput;
    data: XOR<
      subtitleUpdateWithoutStatusInput,
      subtitleUncheckedUpdateWithoutStatusInput
    >;
  };

  export type subtitleUpdateManyWithWhereWithoutStatusInput = {
    where: subtitleScalarWhereInput;
    data: XOR<
      subtitleUpdateManyMutationInput,
      subtitleUncheckedUpdateManyWithoutStatusInput
    >;
  };

  export type subtitleScalarWhereInput = {
    AND?: subtitleScalarWhereInput | subtitleScalarWhereInput[];
    OR?: subtitleScalarWhereInput[];
    NOT?: subtitleScalarWhereInput | subtitleScalarWhereInput[];
    subtitleId?: UuidFilter<"subtitle"> | string;
    subtitleText?: StringFilter<"subtitle"> | string;
    languageCode?: StringFilter<"subtitle"> | string;
    createdBy?: UuidFilter<"subtitle"> | string;
    modifiedBy?: UuidFilter<"subtitle"> | string;
    createdAt?: DateTimeFilter<"subtitle"> | Date | string;
    modifiedAt?: DateTimeFilter<"subtitle"> | Date | string;
    statusCode?: StringFilter<"subtitle"> | string;
  };

  export type languageUpsertWithWhereUniqueWithoutStatusInput = {
    where: languageWhereUniqueInput;
    update: XOR<
      languageUpdateWithoutStatusInput,
      languageUncheckedUpdateWithoutStatusInput
    >;
    create: XOR<
      languageCreateWithoutStatusInput,
      languageUncheckedCreateWithoutStatusInput
    >;
  };

  export type languageUpdateWithWhereUniqueWithoutStatusInput = {
    where: languageWhereUniqueInput;
    data: XOR<
      languageUpdateWithoutStatusInput,
      languageUncheckedUpdateWithoutStatusInput
    >;
  };

  export type languageUpdateManyWithWhereWithoutStatusInput = {
    where: languageScalarWhereInput;
    data: XOR<
      languageUpdateManyMutationInput,
      languageUncheckedUpdateManyWithoutStatusInput
    >;
  };

  export type languageScalarWhereInput = {
    AND?: languageScalarWhereInput | languageScalarWhereInput[];
    OR?: languageScalarWhereInput[];
    NOT?: languageScalarWhereInput | languageScalarWhereInput[];
    languageCode?: StringFilter<"language"> | string;
    languageName?: StringFilter<"language"> | string;
    statusCode?: StringFilter<"language"> | string;
  };

  export type auditLogUpsertWithWhereUniqueWithoutStatusInput = {
    where: auditLogWhereUniqueInput;
    update: XOR<
      auditLogUpdateWithoutStatusInput,
      auditLogUncheckedUpdateWithoutStatusInput
    >;
    create: XOR<
      auditLogCreateWithoutStatusInput,
      auditLogUncheckedCreateWithoutStatusInput
    >;
  };

  export type auditLogUpdateWithWhereUniqueWithoutStatusInput = {
    where: auditLogWhereUniqueInput;
    data: XOR<
      auditLogUpdateWithoutStatusInput,
      auditLogUncheckedUpdateWithoutStatusInput
    >;
  };

  export type auditLogUpdateManyWithWhereWithoutStatusInput = {
    where: auditLogScalarWhereInput;
    data: XOR<
      auditLogUpdateManyMutationInput,
      auditLogUncheckedUpdateManyWithoutStatusInput
    >;
  };

  export type userProfileUpsertWithWhereUniqueWithoutStatusInput = {
    where: userProfileWhereUniqueInput;
    update: XOR<
      userProfileUpdateWithoutStatusInput,
      userProfileUncheckedUpdateWithoutStatusInput
    >;
    create: XOR<
      userProfileCreateWithoutStatusInput,
      userProfileUncheckedCreateWithoutStatusInput
    >;
  };

  export type userProfileUpdateWithWhereUniqueWithoutStatusInput = {
    where: userProfileWhereUniqueInput;
    data: XOR<
      userProfileUpdateWithoutStatusInput,
      userProfileUncheckedUpdateWithoutStatusInput
    >;
  };

  export type userProfileUpdateManyWithWhereWithoutStatusInput = {
    where: userProfileScalarWhereInput;
    data: XOR<
      userProfileUpdateManyMutationInput,
      userProfileUncheckedUpdateManyWithoutStatusInput
    >;
  };

  export type userProfileScalarWhereInput = {
    AND?: userProfileScalarWhereInput | userProfileScalarWhereInput[];
    OR?: userProfileScalarWhereInput[];
    NOT?: userProfileScalarWhereInput | userProfileScalarWhereInput[];
    userProfileId?: UuidFilter<"userProfile"> | string;
    userId?: UuidFilter<"userProfile"> | string;
    fName?: StringFilter<"userProfile"> | string;
    lName?: StringFilter<"userProfile"> | string;
    languageCode?: StringFilter<"userProfile"> | string;
    gender?: StringFilter<"userProfile"> | string;
    dob?: DateTimeFilter<"userProfile"> | Date | string;
    modifiedBy?: UuidFilter<"userProfile"> | string;
    createdBy?: UuidFilter<"userProfile"> | string;
    createdAt?: DateTimeFilter<"userProfile"> | Date | string;
    modifiedAt?: DateTimeFilter<"userProfile"> | Date | string;
    statusCode?: StringFilter<"userProfile"> | string;
  };

  export type languageCreateWithoutAudiosInput = {
    languageCode: string;
    languageName: string;
    profiles?: userProfileCreateNestedManyWithoutLanguageInput;
    subtitles?: subtitleCreateNestedManyWithoutLanguageInput;
    status: statusCreateNestedOneWithoutLanguagesInput;
  };

  export type languageUncheckedCreateWithoutAudiosInput = {
    languageCode: string;
    languageName: string;
    statusCode: string;
    profiles?: userProfileUncheckedCreateNestedManyWithoutLanguageInput;
    subtitles?: subtitleUncheckedCreateNestedManyWithoutLanguageInput;
  };

  export type languageCreateOrConnectWithoutAudiosInput = {
    where: languageWhereUniqueInput;
    create: XOR<
      languageCreateWithoutAudiosInput,
      languageUncheckedCreateWithoutAudiosInput
    >;
  };

  export type statusCreateWithoutAudiosInput = {
    statusCode: string;
    description: string;
    users?: usersCreateNestedManyWithoutStatusInput;
    exhibits?: exhibitCreateNestedManyWithoutStatusInput;
    phoneNumbers?: phoneNumberCreateNestedManyWithoutStatusInput;
    emails?: emailCreateNestedManyWithoutStatusInput;
    roles?: roleCreateNestedManyWithoutStatusInput;
    qrcodes?: qrCodeCreateNestedManyWithoutStatusInput;
    images?: imageCreateNestedManyWithoutStatusInput;
    subtitles?: subtitleCreateNestedManyWithoutStatusInput;
    languages?: languageCreateNestedManyWithoutStatusInput;
    auditLogs?: auditLogCreateNestedManyWithoutStatusInput;
    userProfiles?: userProfileCreateNestedManyWithoutStatusInput;
  };

  export type statusUncheckedCreateWithoutAudiosInput = {
    statusCode: string;
    description: string;
    users?: usersUncheckedCreateNestedManyWithoutStatusInput;
    exhibits?: exhibitUncheckedCreateNestedManyWithoutStatusInput;
    phoneNumbers?: phoneNumberUncheckedCreateNestedManyWithoutStatusInput;
    emails?: emailUncheckedCreateNestedManyWithoutStatusInput;
    roles?: roleUncheckedCreateNestedManyWithoutStatusInput;
    qrcodes?: qrCodeUncheckedCreateNestedManyWithoutStatusInput;
    images?: imageUncheckedCreateNestedManyWithoutStatusInput;
    subtitles?: subtitleUncheckedCreateNestedManyWithoutStatusInput;
    languages?: languageUncheckedCreateNestedManyWithoutStatusInput;
    auditLogs?: auditLogUncheckedCreateNestedManyWithoutStatusInput;
    userProfiles?: userProfileUncheckedCreateNestedManyWithoutStatusInput;
  };

  export type statusCreateOrConnectWithoutAudiosInput = {
    where: statusWhereUniqueInput;
    create: XOR<
      statusCreateWithoutAudiosInput,
      statusUncheckedCreateWithoutAudiosInput
    >;
  };

  export type exhibitAudioRelationCreateWithoutAudioInput = {
    exhibit: exhibitCreateNestedOneWithoutExhibitAudioRelationInput;
  };

  export type exhibitAudioRelationUncheckedCreateWithoutAudioInput = {
    exhibitId: string;
  };

  export type exhibitAudioRelationCreateOrConnectWithoutAudioInput = {
    where: exhibitAudioRelationWhereUniqueInput;
    create: XOR<
      exhibitAudioRelationCreateWithoutAudioInput,
      exhibitAudioRelationUncheckedCreateWithoutAudioInput
    >;
  };

  export type exhibitAudioRelationCreateManyAudioInputEnvelope = {
    data:
      | exhibitAudioRelationCreateManyAudioInput
      | exhibitAudioRelationCreateManyAudioInput[];
    skipDuplicates?: boolean;
  };

  export type exhibitCreateWithoutAudioInput = {
    exhibitId?: string;
    title: string;
    description: string;
    createdBy: string;
    modifiedBy: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    qrCode: qrCodeCreateNestedOneWithoutExhibitInput;
    image: imageCreateNestedOneWithoutExhibitInput;
    subtitles?: exhibitSubtitleCreateNestedManyWithoutExhibitInput;
    status: statusCreateNestedOneWithoutExhibitsInput;
    exhibitAudioRelation?: exhibitAudioRelationCreateNestedManyWithoutExhibitInput;
  };

  export type exhibitUncheckedCreateWithoutAudioInput = {
    exhibitId?: string;
    title: string;
    description: string;
    createdBy: string;
    modifiedBy: string;
    qrCodeId: string;
    imageId: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    statusCode: string;
    subtitles?: exhibitSubtitleUncheckedCreateNestedManyWithoutExhibitInput;
    exhibitAudioRelation?: exhibitAudioRelationUncheckedCreateNestedManyWithoutExhibitInput;
  };

  export type exhibitCreateOrConnectWithoutAudioInput = {
    where: exhibitWhereUniqueInput;
    create: XOR<
      exhibitCreateWithoutAudioInput,
      exhibitUncheckedCreateWithoutAudioInput
    >;
  };

  export type exhibitCreateManyAudioInputEnvelope = {
    data: exhibitCreateManyAudioInput | exhibitCreateManyAudioInput[];
    skipDuplicates?: boolean;
  };

  export type languageUpsertWithoutAudiosInput = {
    update: XOR<
      languageUpdateWithoutAudiosInput,
      languageUncheckedUpdateWithoutAudiosInput
    >;
    create: XOR<
      languageCreateWithoutAudiosInput,
      languageUncheckedCreateWithoutAudiosInput
    >;
    where?: languageWhereInput;
  };

  export type languageUpdateToOneWithWhereWithoutAudiosInput = {
    where?: languageWhereInput;
    data: XOR<
      languageUpdateWithoutAudiosInput,
      languageUncheckedUpdateWithoutAudiosInput
    >;
  };

  export type languageUpdateWithoutAudiosInput = {
    languageCode?: StringFieldUpdateOperationsInput | string;
    languageName?: StringFieldUpdateOperationsInput | string;
    profiles?: userProfileUpdateManyWithoutLanguageNestedInput;
    subtitles?: subtitleUpdateManyWithoutLanguageNestedInput;
    status?: statusUpdateOneRequiredWithoutLanguagesNestedInput;
  };

  export type languageUncheckedUpdateWithoutAudiosInput = {
    languageCode?: StringFieldUpdateOperationsInput | string;
    languageName?: StringFieldUpdateOperationsInput | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
    profiles?: userProfileUncheckedUpdateManyWithoutLanguageNestedInput;
    subtitles?: subtitleUncheckedUpdateManyWithoutLanguageNestedInput;
  };

  export type statusUpsertWithoutAudiosInput = {
    update: XOR<
      statusUpdateWithoutAudiosInput,
      statusUncheckedUpdateWithoutAudiosInput
    >;
    create: XOR<
      statusCreateWithoutAudiosInput,
      statusUncheckedCreateWithoutAudiosInput
    >;
    where?: statusWhereInput;
  };

  export type statusUpdateToOneWithWhereWithoutAudiosInput = {
    where?: statusWhereInput;
    data: XOR<
      statusUpdateWithoutAudiosInput,
      statusUncheckedUpdateWithoutAudiosInput
    >;
  };

  export type statusUpdateWithoutAudiosInput = {
    statusCode?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    users?: usersUpdateManyWithoutStatusNestedInput;
    exhibits?: exhibitUpdateManyWithoutStatusNestedInput;
    phoneNumbers?: phoneNumberUpdateManyWithoutStatusNestedInput;
    emails?: emailUpdateManyWithoutStatusNestedInput;
    roles?: roleUpdateManyWithoutStatusNestedInput;
    qrcodes?: qrCodeUpdateManyWithoutStatusNestedInput;
    images?: imageUpdateManyWithoutStatusNestedInput;
    subtitles?: subtitleUpdateManyWithoutStatusNestedInput;
    languages?: languageUpdateManyWithoutStatusNestedInput;
    auditLogs?: auditLogUpdateManyWithoutStatusNestedInput;
    userProfiles?: userProfileUpdateManyWithoutStatusNestedInput;
  };

  export type statusUncheckedUpdateWithoutAudiosInput = {
    statusCode?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    users?: usersUncheckedUpdateManyWithoutStatusNestedInput;
    exhibits?: exhibitUncheckedUpdateManyWithoutStatusNestedInput;
    phoneNumbers?: phoneNumberUncheckedUpdateManyWithoutStatusNestedInput;
    emails?: emailUncheckedUpdateManyWithoutStatusNestedInput;
    roles?: roleUncheckedUpdateManyWithoutStatusNestedInput;
    qrcodes?: qrCodeUncheckedUpdateManyWithoutStatusNestedInput;
    images?: imageUncheckedUpdateManyWithoutStatusNestedInput;
    subtitles?: subtitleUncheckedUpdateManyWithoutStatusNestedInput;
    languages?: languageUncheckedUpdateManyWithoutStatusNestedInput;
    auditLogs?: auditLogUncheckedUpdateManyWithoutStatusNestedInput;
    userProfiles?: userProfileUncheckedUpdateManyWithoutStatusNestedInput;
  };

  export type exhibitAudioRelationUpsertWithWhereUniqueWithoutAudioInput = {
    where: exhibitAudioRelationWhereUniqueInput;
    update: XOR<
      exhibitAudioRelationUpdateWithoutAudioInput,
      exhibitAudioRelationUncheckedUpdateWithoutAudioInput
    >;
    create: XOR<
      exhibitAudioRelationCreateWithoutAudioInput,
      exhibitAudioRelationUncheckedCreateWithoutAudioInput
    >;
  };

  export type exhibitAudioRelationUpdateWithWhereUniqueWithoutAudioInput = {
    where: exhibitAudioRelationWhereUniqueInput;
    data: XOR<
      exhibitAudioRelationUpdateWithoutAudioInput,
      exhibitAudioRelationUncheckedUpdateWithoutAudioInput
    >;
  };

  export type exhibitAudioRelationUpdateManyWithWhereWithoutAudioInput = {
    where: exhibitAudioRelationScalarWhereInput;
    data: XOR<
      exhibitAudioRelationUpdateManyMutationInput,
      exhibitAudioRelationUncheckedUpdateManyWithoutAudioInput
    >;
  };

  export type exhibitAudioRelationScalarWhereInput = {
    AND?:
      | exhibitAudioRelationScalarWhereInput
      | exhibitAudioRelationScalarWhereInput[];
    OR?: exhibitAudioRelationScalarWhereInput[];
    NOT?:
      | exhibitAudioRelationScalarWhereInput
      | exhibitAudioRelationScalarWhereInput[];
    audioId?: UuidFilter<"exhibitAudioRelation"> | string;
    exhibitId?: UuidFilter<"exhibitAudioRelation"> | string;
  };

  export type exhibitUpsertWithWhereUniqueWithoutAudioInput = {
    where: exhibitWhereUniqueInput;
    update: XOR<
      exhibitUpdateWithoutAudioInput,
      exhibitUncheckedUpdateWithoutAudioInput
    >;
    create: XOR<
      exhibitCreateWithoutAudioInput,
      exhibitUncheckedCreateWithoutAudioInput
    >;
  };

  export type exhibitUpdateWithWhereUniqueWithoutAudioInput = {
    where: exhibitWhereUniqueInput;
    data: XOR<
      exhibitUpdateWithoutAudioInput,
      exhibitUncheckedUpdateWithoutAudioInput
    >;
  };

  export type exhibitUpdateManyWithWhereWithoutAudioInput = {
    where: exhibitScalarWhereInput;
    data: XOR<
      exhibitUpdateManyMutationInput,
      exhibitUncheckedUpdateManyWithoutAudioInput
    >;
  };

  export type audioCreateWithoutExhibitsInput = {
    audioId?: string;
    fileUrl: string;
    description: string;
    createdBy: string;
    createdAt: Date | string;
    language: languageCreateNestedOneWithoutAudiosInput;
    status: statusCreateNestedOneWithoutAudiosInput;
    exhibit?: exhibitCreateNestedManyWithoutAudioInput;
  };

  export type audioUncheckedCreateWithoutExhibitsInput = {
    audioId?: string;
    fileUrl: string;
    description: string;
    createdBy: string;
    languageId: string;
    createdAt: Date | string;
    statusCode: string;
    exhibit?: exhibitUncheckedCreateNestedManyWithoutAudioInput;
  };

  export type audioCreateOrConnectWithoutExhibitsInput = {
    where: audioWhereUniqueInput;
    create: XOR<
      audioCreateWithoutExhibitsInput,
      audioUncheckedCreateWithoutExhibitsInput
    >;
  };

  export type exhibitCreateWithoutExhibitAudioRelationInput = {
    exhibitId?: string;
    title: string;
    description: string;
    createdBy: string;
    modifiedBy: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    audio: audioCreateNestedOneWithoutExhibitInput;
    qrCode: qrCodeCreateNestedOneWithoutExhibitInput;
    image: imageCreateNestedOneWithoutExhibitInput;
    subtitles?: exhibitSubtitleCreateNestedManyWithoutExhibitInput;
    status: statusCreateNestedOneWithoutExhibitsInput;
  };

  export type exhibitUncheckedCreateWithoutExhibitAudioRelationInput = {
    exhibitId?: string;
    title: string;
    description: string;
    audioId: string;
    createdBy: string;
    modifiedBy: string;
    qrCodeId: string;
    imageId: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    statusCode: string;
    subtitles?: exhibitSubtitleUncheckedCreateNestedManyWithoutExhibitInput;
  };

  export type exhibitCreateOrConnectWithoutExhibitAudioRelationInput = {
    where: exhibitWhereUniqueInput;
    create: XOR<
      exhibitCreateWithoutExhibitAudioRelationInput,
      exhibitUncheckedCreateWithoutExhibitAudioRelationInput
    >;
  };

  export type audioUpsertWithoutExhibitsInput = {
    update: XOR<
      audioUpdateWithoutExhibitsInput,
      audioUncheckedUpdateWithoutExhibitsInput
    >;
    create: XOR<
      audioCreateWithoutExhibitsInput,
      audioUncheckedCreateWithoutExhibitsInput
    >;
    where?: audioWhereInput;
  };

  export type audioUpdateToOneWithWhereWithoutExhibitsInput = {
    where?: audioWhereInput;
    data: XOR<
      audioUpdateWithoutExhibitsInput,
      audioUncheckedUpdateWithoutExhibitsInput
    >;
  };

  export type audioUpdateWithoutExhibitsInput = {
    audioId?: StringFieldUpdateOperationsInput | string;
    fileUrl?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    language?: languageUpdateOneRequiredWithoutAudiosNestedInput;
    status?: statusUpdateOneRequiredWithoutAudiosNestedInput;
    exhibit?: exhibitUpdateManyWithoutAudioNestedInput;
  };

  export type audioUncheckedUpdateWithoutExhibitsInput = {
    audioId?: StringFieldUpdateOperationsInput | string;
    fileUrl?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    languageId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
    exhibit?: exhibitUncheckedUpdateManyWithoutAudioNestedInput;
  };

  export type exhibitUpsertWithoutExhibitAudioRelationInput = {
    update: XOR<
      exhibitUpdateWithoutExhibitAudioRelationInput,
      exhibitUncheckedUpdateWithoutExhibitAudioRelationInput
    >;
    create: XOR<
      exhibitCreateWithoutExhibitAudioRelationInput,
      exhibitUncheckedCreateWithoutExhibitAudioRelationInput
    >;
    where?: exhibitWhereInput;
  };

  export type exhibitUpdateToOneWithWhereWithoutExhibitAudioRelationInput = {
    where?: exhibitWhereInput;
    data: XOR<
      exhibitUpdateWithoutExhibitAudioRelationInput,
      exhibitUncheckedUpdateWithoutExhibitAudioRelationInput
    >;
  };

  export type exhibitUpdateWithoutExhibitAudioRelationInput = {
    exhibitId?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    modifiedBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    audio?: audioUpdateOneRequiredWithoutExhibitNestedInput;
    qrCode?: qrCodeUpdateOneRequiredWithoutExhibitNestedInput;
    image?: imageUpdateOneRequiredWithoutExhibitNestedInput;
    subtitles?: exhibitSubtitleUpdateManyWithoutExhibitNestedInput;
    status?: statusUpdateOneRequiredWithoutExhibitsNestedInput;
  };

  export type exhibitUncheckedUpdateWithoutExhibitAudioRelationInput = {
    exhibitId?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    audioId?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    modifiedBy?: StringFieldUpdateOperationsInput | string;
    qrCodeId?: StringFieldUpdateOperationsInput | string;
    imageId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
    subtitles?: exhibitSubtitleUncheckedUpdateManyWithoutExhibitNestedInput;
  };

  export type audioCreateWithoutExhibitInput = {
    audioId?: string;
    fileUrl: string;
    description: string;
    createdBy: string;
    createdAt: Date | string;
    language: languageCreateNestedOneWithoutAudiosInput;
    status: statusCreateNestedOneWithoutAudiosInput;
    exhibits?: exhibitAudioRelationCreateNestedManyWithoutAudioInput;
  };

  export type audioUncheckedCreateWithoutExhibitInput = {
    audioId?: string;
    fileUrl: string;
    description: string;
    createdBy: string;
    languageId: string;
    createdAt: Date | string;
    statusCode: string;
    exhibits?: exhibitAudioRelationUncheckedCreateNestedManyWithoutAudioInput;
  };

  export type audioCreateOrConnectWithoutExhibitInput = {
    where: audioWhereUniqueInput;
    create: XOR<
      audioCreateWithoutExhibitInput,
      audioUncheckedCreateWithoutExhibitInput
    >;
  };

  export type qrCodeCreateWithoutExhibitInput = {
    qrCodeId?: string;
    qrLink: string;
    createdBy: string;
    createdAt: Date | string;
    status: statusCreateNestedOneWithoutQrcodesInput;
  };

  export type qrCodeUncheckedCreateWithoutExhibitInput = {
    qrCodeId?: string;
    qrLink: string;
    createdBy: string;
    createdAt: Date | string;
    statusCode: string;
  };

  export type qrCodeCreateOrConnectWithoutExhibitInput = {
    where: qrCodeWhereUniqueInput;
    create: XOR<
      qrCodeCreateWithoutExhibitInput,
      qrCodeUncheckedCreateWithoutExhibitInput
    >;
  };

  export type imageCreateWithoutExhibitInput = {
    imageId?: string;
    description: string;
    createdBy: string;
    createdAt: Date | string;
    status: statusCreateNestedOneWithoutImagesInput;
  };

  export type imageUncheckedCreateWithoutExhibitInput = {
    imageId?: string;
    description: string;
    createdBy: string;
    createdAt: Date | string;
    statusCode: string;
  };

  export type imageCreateOrConnectWithoutExhibitInput = {
    where: imageWhereUniqueInput;
    create: XOR<
      imageCreateWithoutExhibitInput,
      imageUncheckedCreateWithoutExhibitInput
    >;
  };

  export type exhibitSubtitleCreateWithoutExhibitInput = {
    createdAt: Date | string;
    subtitle: subtitleCreateNestedOneWithoutExhibitsInput;
  };

  export type exhibitSubtitleUncheckedCreateWithoutExhibitInput = {
    subtitleId: string;
    createdAt: Date | string;
  };

  export type exhibitSubtitleCreateOrConnectWithoutExhibitInput = {
    where: exhibitSubtitleWhereUniqueInput;
    create: XOR<
      exhibitSubtitleCreateWithoutExhibitInput,
      exhibitSubtitleUncheckedCreateWithoutExhibitInput
    >;
  };

  export type exhibitSubtitleCreateManyExhibitInputEnvelope = {
    data:
      | exhibitSubtitleCreateManyExhibitInput
      | exhibitSubtitleCreateManyExhibitInput[];
    skipDuplicates?: boolean;
  };

  export type statusCreateWithoutExhibitsInput = {
    statusCode: string;
    description: string;
    users?: usersCreateNestedManyWithoutStatusInput;
    audios?: audioCreateNestedManyWithoutStatusInput;
    phoneNumbers?: phoneNumberCreateNestedManyWithoutStatusInput;
    emails?: emailCreateNestedManyWithoutStatusInput;
    roles?: roleCreateNestedManyWithoutStatusInput;
    qrcodes?: qrCodeCreateNestedManyWithoutStatusInput;
    images?: imageCreateNestedManyWithoutStatusInput;
    subtitles?: subtitleCreateNestedManyWithoutStatusInput;
    languages?: languageCreateNestedManyWithoutStatusInput;
    auditLogs?: auditLogCreateNestedManyWithoutStatusInput;
    userProfiles?: userProfileCreateNestedManyWithoutStatusInput;
  };

  export type statusUncheckedCreateWithoutExhibitsInput = {
    statusCode: string;
    description: string;
    users?: usersUncheckedCreateNestedManyWithoutStatusInput;
    audios?: audioUncheckedCreateNestedManyWithoutStatusInput;
    phoneNumbers?: phoneNumberUncheckedCreateNestedManyWithoutStatusInput;
    emails?: emailUncheckedCreateNestedManyWithoutStatusInput;
    roles?: roleUncheckedCreateNestedManyWithoutStatusInput;
    qrcodes?: qrCodeUncheckedCreateNestedManyWithoutStatusInput;
    images?: imageUncheckedCreateNestedManyWithoutStatusInput;
    subtitles?: subtitleUncheckedCreateNestedManyWithoutStatusInput;
    languages?: languageUncheckedCreateNestedManyWithoutStatusInput;
    auditLogs?: auditLogUncheckedCreateNestedManyWithoutStatusInput;
    userProfiles?: userProfileUncheckedCreateNestedManyWithoutStatusInput;
  };

  export type statusCreateOrConnectWithoutExhibitsInput = {
    where: statusWhereUniqueInput;
    create: XOR<
      statusCreateWithoutExhibitsInput,
      statusUncheckedCreateWithoutExhibitsInput
    >;
  };

  export type exhibitAudioRelationCreateWithoutExhibitInput = {
    audio: audioCreateNestedOneWithoutExhibitsInput;
  };

  export type exhibitAudioRelationUncheckedCreateWithoutExhibitInput = {
    audioId: string;
  };

  export type exhibitAudioRelationCreateOrConnectWithoutExhibitInput = {
    where: exhibitAudioRelationWhereUniqueInput;
    create: XOR<
      exhibitAudioRelationCreateWithoutExhibitInput,
      exhibitAudioRelationUncheckedCreateWithoutExhibitInput
    >;
  };

  export type exhibitAudioRelationCreateManyExhibitInputEnvelope = {
    data:
      | exhibitAudioRelationCreateManyExhibitInput
      | exhibitAudioRelationCreateManyExhibitInput[];
    skipDuplicates?: boolean;
  };

  export type audioUpsertWithoutExhibitInput = {
    update: XOR<
      audioUpdateWithoutExhibitInput,
      audioUncheckedUpdateWithoutExhibitInput
    >;
    create: XOR<
      audioCreateWithoutExhibitInput,
      audioUncheckedCreateWithoutExhibitInput
    >;
    where?: audioWhereInput;
  };

  export type audioUpdateToOneWithWhereWithoutExhibitInput = {
    where?: audioWhereInput;
    data: XOR<
      audioUpdateWithoutExhibitInput,
      audioUncheckedUpdateWithoutExhibitInput
    >;
  };

  export type audioUpdateWithoutExhibitInput = {
    audioId?: StringFieldUpdateOperationsInput | string;
    fileUrl?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    language?: languageUpdateOneRequiredWithoutAudiosNestedInput;
    status?: statusUpdateOneRequiredWithoutAudiosNestedInput;
    exhibits?: exhibitAudioRelationUpdateManyWithoutAudioNestedInput;
  };

  export type audioUncheckedUpdateWithoutExhibitInput = {
    audioId?: StringFieldUpdateOperationsInput | string;
    fileUrl?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    languageId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
    exhibits?: exhibitAudioRelationUncheckedUpdateManyWithoutAudioNestedInput;
  };

  export type qrCodeUpsertWithoutExhibitInput = {
    update: XOR<
      qrCodeUpdateWithoutExhibitInput,
      qrCodeUncheckedUpdateWithoutExhibitInput
    >;
    create: XOR<
      qrCodeCreateWithoutExhibitInput,
      qrCodeUncheckedCreateWithoutExhibitInput
    >;
    where?: qrCodeWhereInput;
  };

  export type qrCodeUpdateToOneWithWhereWithoutExhibitInput = {
    where?: qrCodeWhereInput;
    data: XOR<
      qrCodeUpdateWithoutExhibitInput,
      qrCodeUncheckedUpdateWithoutExhibitInput
    >;
  };

  export type qrCodeUpdateWithoutExhibitInput = {
    qrCodeId?: StringFieldUpdateOperationsInput | string;
    qrLink?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    status?: statusUpdateOneRequiredWithoutQrcodesNestedInput;
  };

  export type qrCodeUncheckedUpdateWithoutExhibitInput = {
    qrCodeId?: StringFieldUpdateOperationsInput | string;
    qrLink?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
  };

  export type imageUpsertWithoutExhibitInput = {
    update: XOR<
      imageUpdateWithoutExhibitInput,
      imageUncheckedUpdateWithoutExhibitInput
    >;
    create: XOR<
      imageCreateWithoutExhibitInput,
      imageUncheckedCreateWithoutExhibitInput
    >;
    where?: imageWhereInput;
  };

  export type imageUpdateToOneWithWhereWithoutExhibitInput = {
    where?: imageWhereInput;
    data: XOR<
      imageUpdateWithoutExhibitInput,
      imageUncheckedUpdateWithoutExhibitInput
    >;
  };

  export type imageUpdateWithoutExhibitInput = {
    imageId?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    status?: statusUpdateOneRequiredWithoutImagesNestedInput;
  };

  export type imageUncheckedUpdateWithoutExhibitInput = {
    imageId?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
  };

  export type exhibitSubtitleUpsertWithWhereUniqueWithoutExhibitInput = {
    where: exhibitSubtitleWhereUniqueInput;
    update: XOR<
      exhibitSubtitleUpdateWithoutExhibitInput,
      exhibitSubtitleUncheckedUpdateWithoutExhibitInput
    >;
    create: XOR<
      exhibitSubtitleCreateWithoutExhibitInput,
      exhibitSubtitleUncheckedCreateWithoutExhibitInput
    >;
  };

  export type exhibitSubtitleUpdateWithWhereUniqueWithoutExhibitInput = {
    where: exhibitSubtitleWhereUniqueInput;
    data: XOR<
      exhibitSubtitleUpdateWithoutExhibitInput,
      exhibitSubtitleUncheckedUpdateWithoutExhibitInput
    >;
  };

  export type exhibitSubtitleUpdateManyWithWhereWithoutExhibitInput = {
    where: exhibitSubtitleScalarWhereInput;
    data: XOR<
      exhibitSubtitleUpdateManyMutationInput,
      exhibitSubtitleUncheckedUpdateManyWithoutExhibitInput
    >;
  };

  export type exhibitSubtitleScalarWhereInput = {
    AND?: exhibitSubtitleScalarWhereInput | exhibitSubtitleScalarWhereInput[];
    OR?: exhibitSubtitleScalarWhereInput[];
    NOT?: exhibitSubtitleScalarWhereInput | exhibitSubtitleScalarWhereInput[];
    exhibitId?: UuidFilter<"exhibitSubtitle"> | string;
    subtitleId?: UuidFilter<"exhibitSubtitle"> | string;
    createdAt?: DateTimeFilter<"exhibitSubtitle"> | Date | string;
  };

  export type statusUpsertWithoutExhibitsInput = {
    update: XOR<
      statusUpdateWithoutExhibitsInput,
      statusUncheckedUpdateWithoutExhibitsInput
    >;
    create: XOR<
      statusCreateWithoutExhibitsInput,
      statusUncheckedCreateWithoutExhibitsInput
    >;
    where?: statusWhereInput;
  };

  export type statusUpdateToOneWithWhereWithoutExhibitsInput = {
    where?: statusWhereInput;
    data: XOR<
      statusUpdateWithoutExhibitsInput,
      statusUncheckedUpdateWithoutExhibitsInput
    >;
  };

  export type statusUpdateWithoutExhibitsInput = {
    statusCode?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    users?: usersUpdateManyWithoutStatusNestedInput;
    audios?: audioUpdateManyWithoutStatusNestedInput;
    phoneNumbers?: phoneNumberUpdateManyWithoutStatusNestedInput;
    emails?: emailUpdateManyWithoutStatusNestedInput;
    roles?: roleUpdateManyWithoutStatusNestedInput;
    qrcodes?: qrCodeUpdateManyWithoutStatusNestedInput;
    images?: imageUpdateManyWithoutStatusNestedInput;
    subtitles?: subtitleUpdateManyWithoutStatusNestedInput;
    languages?: languageUpdateManyWithoutStatusNestedInput;
    auditLogs?: auditLogUpdateManyWithoutStatusNestedInput;
    userProfiles?: userProfileUpdateManyWithoutStatusNestedInput;
  };

  export type statusUncheckedUpdateWithoutExhibitsInput = {
    statusCode?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    users?: usersUncheckedUpdateManyWithoutStatusNestedInput;
    audios?: audioUncheckedUpdateManyWithoutStatusNestedInput;
    phoneNumbers?: phoneNumberUncheckedUpdateManyWithoutStatusNestedInput;
    emails?: emailUncheckedUpdateManyWithoutStatusNestedInput;
    roles?: roleUncheckedUpdateManyWithoutStatusNestedInput;
    qrcodes?: qrCodeUncheckedUpdateManyWithoutStatusNestedInput;
    images?: imageUncheckedUpdateManyWithoutStatusNestedInput;
    subtitles?: subtitleUncheckedUpdateManyWithoutStatusNestedInput;
    languages?: languageUncheckedUpdateManyWithoutStatusNestedInput;
    auditLogs?: auditLogUncheckedUpdateManyWithoutStatusNestedInput;
    userProfiles?: userProfileUncheckedUpdateManyWithoutStatusNestedInput;
  };

  export type exhibitAudioRelationUpsertWithWhereUniqueWithoutExhibitInput = {
    where: exhibitAudioRelationWhereUniqueInput;
    update: XOR<
      exhibitAudioRelationUpdateWithoutExhibitInput,
      exhibitAudioRelationUncheckedUpdateWithoutExhibitInput
    >;
    create: XOR<
      exhibitAudioRelationCreateWithoutExhibitInput,
      exhibitAudioRelationUncheckedCreateWithoutExhibitInput
    >;
  };

  export type exhibitAudioRelationUpdateWithWhereUniqueWithoutExhibitInput = {
    where: exhibitAudioRelationWhereUniqueInput;
    data: XOR<
      exhibitAudioRelationUpdateWithoutExhibitInput,
      exhibitAudioRelationUncheckedUpdateWithoutExhibitInput
    >;
  };

  export type exhibitAudioRelationUpdateManyWithWhereWithoutExhibitInput = {
    where: exhibitAudioRelationScalarWhereInput;
    data: XOR<
      exhibitAudioRelationUpdateManyMutationInput,
      exhibitAudioRelationUncheckedUpdateManyWithoutExhibitInput
    >;
  };

  export type usersCreateWithoutAuditLogsInput = {
    userId?: string;
    username: string;
    password: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    phoneNumbers?: phoneNumberCreateNestedManyWithoutUserInput;
    emails?: emailCreateNestedManyWithoutUserInput;
    userProfile?: userProfileCreateNestedOneWithoutUserInput;
    sessions?: sessionCreateNestedManyWithoutUserInput;
    events?: eventCreateNestedManyWithoutUsersInput;
    userRoles?: userRoleCreateNestedManyWithoutUserInput;
    status: statusCreateNestedOneWithoutUsersInput;
  };

  export type usersUncheckedCreateWithoutAuditLogsInput = {
    userId?: string;
    username: string;
    password: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    statusCode: string;
    phoneNumbers?: phoneNumberUncheckedCreateNestedManyWithoutUserInput;
    emails?: emailUncheckedCreateNestedManyWithoutUserInput;
    userProfile?: userProfileUncheckedCreateNestedOneWithoutUserInput;
    sessions?: sessionUncheckedCreateNestedManyWithoutUserInput;
    events?: eventUncheckedCreateNestedManyWithoutUsersInput;
    userRoles?: userRoleUncheckedCreateNestedManyWithoutUserInput;
  };

  export type usersCreateOrConnectWithoutAuditLogsInput = {
    where: usersWhereUniqueInput;
    create: XOR<
      usersCreateWithoutAuditLogsInput,
      usersUncheckedCreateWithoutAuditLogsInput
    >;
  };

  export type statusCreateWithoutAuditLogsInput = {
    statusCode: string;
    description: string;
    users?: usersCreateNestedManyWithoutStatusInput;
    audios?: audioCreateNestedManyWithoutStatusInput;
    exhibits?: exhibitCreateNestedManyWithoutStatusInput;
    phoneNumbers?: phoneNumberCreateNestedManyWithoutStatusInput;
    emails?: emailCreateNestedManyWithoutStatusInput;
    roles?: roleCreateNestedManyWithoutStatusInput;
    qrcodes?: qrCodeCreateNestedManyWithoutStatusInput;
    images?: imageCreateNestedManyWithoutStatusInput;
    subtitles?: subtitleCreateNestedManyWithoutStatusInput;
    languages?: languageCreateNestedManyWithoutStatusInput;
    userProfiles?: userProfileCreateNestedManyWithoutStatusInput;
  };

  export type statusUncheckedCreateWithoutAuditLogsInput = {
    statusCode: string;
    description: string;
    users?: usersUncheckedCreateNestedManyWithoutStatusInput;
    audios?: audioUncheckedCreateNestedManyWithoutStatusInput;
    exhibits?: exhibitUncheckedCreateNestedManyWithoutStatusInput;
    phoneNumbers?: phoneNumberUncheckedCreateNestedManyWithoutStatusInput;
    emails?: emailUncheckedCreateNestedManyWithoutStatusInput;
    roles?: roleUncheckedCreateNestedManyWithoutStatusInput;
    qrcodes?: qrCodeUncheckedCreateNestedManyWithoutStatusInput;
    images?: imageUncheckedCreateNestedManyWithoutStatusInput;
    subtitles?: subtitleUncheckedCreateNestedManyWithoutStatusInput;
    languages?: languageUncheckedCreateNestedManyWithoutStatusInput;
    userProfiles?: userProfileUncheckedCreateNestedManyWithoutStatusInput;
  };

  export type statusCreateOrConnectWithoutAuditLogsInput = {
    where: statusWhereUniqueInput;
    create: XOR<
      statusCreateWithoutAuditLogsInput,
      statusUncheckedCreateWithoutAuditLogsInput
    >;
  };

  export type usersUpsertWithoutAuditLogsInput = {
    update: XOR<
      usersUpdateWithoutAuditLogsInput,
      usersUncheckedUpdateWithoutAuditLogsInput
    >;
    create: XOR<
      usersCreateWithoutAuditLogsInput,
      usersUncheckedCreateWithoutAuditLogsInput
    >;
    where?: usersWhereInput;
  };

  export type usersUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: usersWhereInput;
    data: XOR<
      usersUpdateWithoutAuditLogsInput,
      usersUncheckedUpdateWithoutAuditLogsInput
    >;
  };

  export type usersUpdateWithoutAuditLogsInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    phoneNumbers?: phoneNumberUpdateManyWithoutUserNestedInput;
    emails?: emailUpdateManyWithoutUserNestedInput;
    userProfile?: userProfileUpdateOneWithoutUserNestedInput;
    sessions?: sessionUpdateManyWithoutUserNestedInput;
    events?: eventUpdateManyWithoutUsersNestedInput;
    userRoles?: userRoleUpdateManyWithoutUserNestedInput;
    status?: statusUpdateOneRequiredWithoutUsersNestedInput;
  };

  export type usersUncheckedUpdateWithoutAuditLogsInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
    phoneNumbers?: phoneNumberUncheckedUpdateManyWithoutUserNestedInput;
    emails?: emailUncheckedUpdateManyWithoutUserNestedInput;
    userProfile?: userProfileUncheckedUpdateOneWithoutUserNestedInput;
    sessions?: sessionUncheckedUpdateManyWithoutUserNestedInput;
    events?: eventUncheckedUpdateManyWithoutUsersNestedInput;
    userRoles?: userRoleUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type statusUpsertWithoutAuditLogsInput = {
    update: XOR<
      statusUpdateWithoutAuditLogsInput,
      statusUncheckedUpdateWithoutAuditLogsInput
    >;
    create: XOR<
      statusCreateWithoutAuditLogsInput,
      statusUncheckedCreateWithoutAuditLogsInput
    >;
    where?: statusWhereInput;
  };

  export type statusUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: statusWhereInput;
    data: XOR<
      statusUpdateWithoutAuditLogsInput,
      statusUncheckedUpdateWithoutAuditLogsInput
    >;
  };

  export type statusUpdateWithoutAuditLogsInput = {
    statusCode?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    users?: usersUpdateManyWithoutStatusNestedInput;
    audios?: audioUpdateManyWithoutStatusNestedInput;
    exhibits?: exhibitUpdateManyWithoutStatusNestedInput;
    phoneNumbers?: phoneNumberUpdateManyWithoutStatusNestedInput;
    emails?: emailUpdateManyWithoutStatusNestedInput;
    roles?: roleUpdateManyWithoutStatusNestedInput;
    qrcodes?: qrCodeUpdateManyWithoutStatusNestedInput;
    images?: imageUpdateManyWithoutStatusNestedInput;
    subtitles?: subtitleUpdateManyWithoutStatusNestedInput;
    languages?: languageUpdateManyWithoutStatusNestedInput;
    userProfiles?: userProfileUpdateManyWithoutStatusNestedInput;
  };

  export type statusUncheckedUpdateWithoutAuditLogsInput = {
    statusCode?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    users?: usersUncheckedUpdateManyWithoutStatusNestedInput;
    audios?: audioUncheckedUpdateManyWithoutStatusNestedInput;
    exhibits?: exhibitUncheckedUpdateManyWithoutStatusNestedInput;
    phoneNumbers?: phoneNumberUncheckedUpdateManyWithoutStatusNestedInput;
    emails?: emailUncheckedUpdateManyWithoutStatusNestedInput;
    roles?: roleUncheckedUpdateManyWithoutStatusNestedInput;
    qrcodes?: qrCodeUncheckedUpdateManyWithoutStatusNestedInput;
    images?: imageUncheckedUpdateManyWithoutStatusNestedInput;
    subtitles?: subtitleUncheckedUpdateManyWithoutStatusNestedInput;
    languages?: languageUncheckedUpdateManyWithoutStatusNestedInput;
    userProfiles?: userProfileUncheckedUpdateManyWithoutStatusNestedInput;
  };

  export type usersCreateWithoutPhoneNumbersInput = {
    userId?: string;
    username: string;
    password: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    emails?: emailCreateNestedManyWithoutUserInput;
    userProfile?: userProfileCreateNestedOneWithoutUserInput;
    sessions?: sessionCreateNestedManyWithoutUserInput;
    auditLogs?: auditLogCreateNestedManyWithoutUserInput;
    events?: eventCreateNestedManyWithoutUsersInput;
    userRoles?: userRoleCreateNestedManyWithoutUserInput;
    status: statusCreateNestedOneWithoutUsersInput;
  };

  export type usersUncheckedCreateWithoutPhoneNumbersInput = {
    userId?: string;
    username: string;
    password: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    statusCode: string;
    emails?: emailUncheckedCreateNestedManyWithoutUserInput;
    userProfile?: userProfileUncheckedCreateNestedOneWithoutUserInput;
    sessions?: sessionUncheckedCreateNestedManyWithoutUserInput;
    auditLogs?: auditLogUncheckedCreateNestedManyWithoutUserInput;
    events?: eventUncheckedCreateNestedManyWithoutUsersInput;
    userRoles?: userRoleUncheckedCreateNestedManyWithoutUserInput;
  };

  export type usersCreateOrConnectWithoutPhoneNumbersInput = {
    where: usersWhereUniqueInput;
    create: XOR<
      usersCreateWithoutPhoneNumbersInput,
      usersUncheckedCreateWithoutPhoneNumbersInput
    >;
  };

  export type statusCreateWithoutPhoneNumbersInput = {
    statusCode: string;
    description: string;
    users?: usersCreateNestedManyWithoutStatusInput;
    audios?: audioCreateNestedManyWithoutStatusInput;
    exhibits?: exhibitCreateNestedManyWithoutStatusInput;
    emails?: emailCreateNestedManyWithoutStatusInput;
    roles?: roleCreateNestedManyWithoutStatusInput;
    qrcodes?: qrCodeCreateNestedManyWithoutStatusInput;
    images?: imageCreateNestedManyWithoutStatusInput;
    subtitles?: subtitleCreateNestedManyWithoutStatusInput;
    languages?: languageCreateNestedManyWithoutStatusInput;
    auditLogs?: auditLogCreateNestedManyWithoutStatusInput;
    userProfiles?: userProfileCreateNestedManyWithoutStatusInput;
  };

  export type statusUncheckedCreateWithoutPhoneNumbersInput = {
    statusCode: string;
    description: string;
    users?: usersUncheckedCreateNestedManyWithoutStatusInput;
    audios?: audioUncheckedCreateNestedManyWithoutStatusInput;
    exhibits?: exhibitUncheckedCreateNestedManyWithoutStatusInput;
    emails?: emailUncheckedCreateNestedManyWithoutStatusInput;
    roles?: roleUncheckedCreateNestedManyWithoutStatusInput;
    qrcodes?: qrCodeUncheckedCreateNestedManyWithoutStatusInput;
    images?: imageUncheckedCreateNestedManyWithoutStatusInput;
    subtitles?: subtitleUncheckedCreateNestedManyWithoutStatusInput;
    languages?: languageUncheckedCreateNestedManyWithoutStatusInput;
    auditLogs?: auditLogUncheckedCreateNestedManyWithoutStatusInput;
    userProfiles?: userProfileUncheckedCreateNestedManyWithoutStatusInput;
  };

  export type statusCreateOrConnectWithoutPhoneNumbersInput = {
    where: statusWhereUniqueInput;
    create: XOR<
      statusCreateWithoutPhoneNumbersInput,
      statusUncheckedCreateWithoutPhoneNumbersInput
    >;
  };

  export type usersUpsertWithoutPhoneNumbersInput = {
    update: XOR<
      usersUpdateWithoutPhoneNumbersInput,
      usersUncheckedUpdateWithoutPhoneNumbersInput
    >;
    create: XOR<
      usersCreateWithoutPhoneNumbersInput,
      usersUncheckedCreateWithoutPhoneNumbersInput
    >;
    where?: usersWhereInput;
  };

  export type usersUpdateToOneWithWhereWithoutPhoneNumbersInput = {
    where?: usersWhereInput;
    data: XOR<
      usersUpdateWithoutPhoneNumbersInput,
      usersUncheckedUpdateWithoutPhoneNumbersInput
    >;
  };

  export type usersUpdateWithoutPhoneNumbersInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    emails?: emailUpdateManyWithoutUserNestedInput;
    userProfile?: userProfileUpdateOneWithoutUserNestedInput;
    sessions?: sessionUpdateManyWithoutUserNestedInput;
    auditLogs?: auditLogUpdateManyWithoutUserNestedInput;
    events?: eventUpdateManyWithoutUsersNestedInput;
    userRoles?: userRoleUpdateManyWithoutUserNestedInput;
    status?: statusUpdateOneRequiredWithoutUsersNestedInput;
  };

  export type usersUncheckedUpdateWithoutPhoneNumbersInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
    emails?: emailUncheckedUpdateManyWithoutUserNestedInput;
    userProfile?: userProfileUncheckedUpdateOneWithoutUserNestedInput;
    sessions?: sessionUncheckedUpdateManyWithoutUserNestedInput;
    auditLogs?: auditLogUncheckedUpdateManyWithoutUserNestedInput;
    events?: eventUncheckedUpdateManyWithoutUsersNestedInput;
    userRoles?: userRoleUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type statusUpsertWithoutPhoneNumbersInput = {
    update: XOR<
      statusUpdateWithoutPhoneNumbersInput,
      statusUncheckedUpdateWithoutPhoneNumbersInput
    >;
    create: XOR<
      statusCreateWithoutPhoneNumbersInput,
      statusUncheckedCreateWithoutPhoneNumbersInput
    >;
    where?: statusWhereInput;
  };

  export type statusUpdateToOneWithWhereWithoutPhoneNumbersInput = {
    where?: statusWhereInput;
    data: XOR<
      statusUpdateWithoutPhoneNumbersInput,
      statusUncheckedUpdateWithoutPhoneNumbersInput
    >;
  };

  export type statusUpdateWithoutPhoneNumbersInput = {
    statusCode?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    users?: usersUpdateManyWithoutStatusNestedInput;
    audios?: audioUpdateManyWithoutStatusNestedInput;
    exhibits?: exhibitUpdateManyWithoutStatusNestedInput;
    emails?: emailUpdateManyWithoutStatusNestedInput;
    roles?: roleUpdateManyWithoutStatusNestedInput;
    qrcodes?: qrCodeUpdateManyWithoutStatusNestedInput;
    images?: imageUpdateManyWithoutStatusNestedInput;
    subtitles?: subtitleUpdateManyWithoutStatusNestedInput;
    languages?: languageUpdateManyWithoutStatusNestedInput;
    auditLogs?: auditLogUpdateManyWithoutStatusNestedInput;
    userProfiles?: userProfileUpdateManyWithoutStatusNestedInput;
  };

  export type statusUncheckedUpdateWithoutPhoneNumbersInput = {
    statusCode?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    users?: usersUncheckedUpdateManyWithoutStatusNestedInput;
    audios?: audioUncheckedUpdateManyWithoutStatusNestedInput;
    exhibits?: exhibitUncheckedUpdateManyWithoutStatusNestedInput;
    emails?: emailUncheckedUpdateManyWithoutStatusNestedInput;
    roles?: roleUncheckedUpdateManyWithoutStatusNestedInput;
    qrcodes?: qrCodeUncheckedUpdateManyWithoutStatusNestedInput;
    images?: imageUncheckedUpdateManyWithoutStatusNestedInput;
    subtitles?: subtitleUncheckedUpdateManyWithoutStatusNestedInput;
    languages?: languageUncheckedUpdateManyWithoutStatusNestedInput;
    auditLogs?: auditLogUncheckedUpdateManyWithoutStatusNestedInput;
    userProfiles?: userProfileUncheckedUpdateManyWithoutStatusNestedInput;
  };

  export type usersCreateWithoutEmailsInput = {
    userId?: string;
    username: string;
    password: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    phoneNumbers?: phoneNumberCreateNestedManyWithoutUserInput;
    userProfile?: userProfileCreateNestedOneWithoutUserInput;
    sessions?: sessionCreateNestedManyWithoutUserInput;
    auditLogs?: auditLogCreateNestedManyWithoutUserInput;
    events?: eventCreateNestedManyWithoutUsersInput;
    userRoles?: userRoleCreateNestedManyWithoutUserInput;
    status: statusCreateNestedOneWithoutUsersInput;
  };

  export type usersUncheckedCreateWithoutEmailsInput = {
    userId?: string;
    username: string;
    password: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    statusCode: string;
    phoneNumbers?: phoneNumberUncheckedCreateNestedManyWithoutUserInput;
    userProfile?: userProfileUncheckedCreateNestedOneWithoutUserInput;
    sessions?: sessionUncheckedCreateNestedManyWithoutUserInput;
    auditLogs?: auditLogUncheckedCreateNestedManyWithoutUserInput;
    events?: eventUncheckedCreateNestedManyWithoutUsersInput;
    userRoles?: userRoleUncheckedCreateNestedManyWithoutUserInput;
  };

  export type usersCreateOrConnectWithoutEmailsInput = {
    where: usersWhereUniqueInput;
    create: XOR<
      usersCreateWithoutEmailsInput,
      usersUncheckedCreateWithoutEmailsInput
    >;
  };

  export type statusCreateWithoutEmailsInput = {
    statusCode: string;
    description: string;
    users?: usersCreateNestedManyWithoutStatusInput;
    audios?: audioCreateNestedManyWithoutStatusInput;
    exhibits?: exhibitCreateNestedManyWithoutStatusInput;
    phoneNumbers?: phoneNumberCreateNestedManyWithoutStatusInput;
    roles?: roleCreateNestedManyWithoutStatusInput;
    qrcodes?: qrCodeCreateNestedManyWithoutStatusInput;
    images?: imageCreateNestedManyWithoutStatusInput;
    subtitles?: subtitleCreateNestedManyWithoutStatusInput;
    languages?: languageCreateNestedManyWithoutStatusInput;
    auditLogs?: auditLogCreateNestedManyWithoutStatusInput;
    userProfiles?: userProfileCreateNestedManyWithoutStatusInput;
  };

  export type statusUncheckedCreateWithoutEmailsInput = {
    statusCode: string;
    description: string;
    users?: usersUncheckedCreateNestedManyWithoutStatusInput;
    audios?: audioUncheckedCreateNestedManyWithoutStatusInput;
    exhibits?: exhibitUncheckedCreateNestedManyWithoutStatusInput;
    phoneNumbers?: phoneNumberUncheckedCreateNestedManyWithoutStatusInput;
    roles?: roleUncheckedCreateNestedManyWithoutStatusInput;
    qrcodes?: qrCodeUncheckedCreateNestedManyWithoutStatusInput;
    images?: imageUncheckedCreateNestedManyWithoutStatusInput;
    subtitles?: subtitleUncheckedCreateNestedManyWithoutStatusInput;
    languages?: languageUncheckedCreateNestedManyWithoutStatusInput;
    auditLogs?: auditLogUncheckedCreateNestedManyWithoutStatusInput;
    userProfiles?: userProfileUncheckedCreateNestedManyWithoutStatusInput;
  };

  export type statusCreateOrConnectWithoutEmailsInput = {
    where: statusWhereUniqueInput;
    create: XOR<
      statusCreateWithoutEmailsInput,
      statusUncheckedCreateWithoutEmailsInput
    >;
  };

  export type usersUpsertWithoutEmailsInput = {
    update: XOR<
      usersUpdateWithoutEmailsInput,
      usersUncheckedUpdateWithoutEmailsInput
    >;
    create: XOR<
      usersCreateWithoutEmailsInput,
      usersUncheckedCreateWithoutEmailsInput
    >;
    where?: usersWhereInput;
  };

  export type usersUpdateToOneWithWhereWithoutEmailsInput = {
    where?: usersWhereInput;
    data: XOR<
      usersUpdateWithoutEmailsInput,
      usersUncheckedUpdateWithoutEmailsInput
    >;
  };

  export type usersUpdateWithoutEmailsInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    phoneNumbers?: phoneNumberUpdateManyWithoutUserNestedInput;
    userProfile?: userProfileUpdateOneWithoutUserNestedInput;
    sessions?: sessionUpdateManyWithoutUserNestedInput;
    auditLogs?: auditLogUpdateManyWithoutUserNestedInput;
    events?: eventUpdateManyWithoutUsersNestedInput;
    userRoles?: userRoleUpdateManyWithoutUserNestedInput;
    status?: statusUpdateOneRequiredWithoutUsersNestedInput;
  };

  export type usersUncheckedUpdateWithoutEmailsInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
    phoneNumbers?: phoneNumberUncheckedUpdateManyWithoutUserNestedInput;
    userProfile?: userProfileUncheckedUpdateOneWithoutUserNestedInput;
    sessions?: sessionUncheckedUpdateManyWithoutUserNestedInput;
    auditLogs?: auditLogUncheckedUpdateManyWithoutUserNestedInput;
    events?: eventUncheckedUpdateManyWithoutUsersNestedInput;
    userRoles?: userRoleUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type statusUpsertWithoutEmailsInput = {
    update: XOR<
      statusUpdateWithoutEmailsInput,
      statusUncheckedUpdateWithoutEmailsInput
    >;
    create: XOR<
      statusCreateWithoutEmailsInput,
      statusUncheckedCreateWithoutEmailsInput
    >;
    where?: statusWhereInput;
  };

  export type statusUpdateToOneWithWhereWithoutEmailsInput = {
    where?: statusWhereInput;
    data: XOR<
      statusUpdateWithoutEmailsInput,
      statusUncheckedUpdateWithoutEmailsInput
    >;
  };

  export type statusUpdateWithoutEmailsInput = {
    statusCode?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    users?: usersUpdateManyWithoutStatusNestedInput;
    audios?: audioUpdateManyWithoutStatusNestedInput;
    exhibits?: exhibitUpdateManyWithoutStatusNestedInput;
    phoneNumbers?: phoneNumberUpdateManyWithoutStatusNestedInput;
    roles?: roleUpdateManyWithoutStatusNestedInput;
    qrcodes?: qrCodeUpdateManyWithoutStatusNestedInput;
    images?: imageUpdateManyWithoutStatusNestedInput;
    subtitles?: subtitleUpdateManyWithoutStatusNestedInput;
    languages?: languageUpdateManyWithoutStatusNestedInput;
    auditLogs?: auditLogUpdateManyWithoutStatusNestedInput;
    userProfiles?: userProfileUpdateManyWithoutStatusNestedInput;
  };

  export type statusUncheckedUpdateWithoutEmailsInput = {
    statusCode?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    users?: usersUncheckedUpdateManyWithoutStatusNestedInput;
    audios?: audioUncheckedUpdateManyWithoutStatusNestedInput;
    exhibits?: exhibitUncheckedUpdateManyWithoutStatusNestedInput;
    phoneNumbers?: phoneNumberUncheckedUpdateManyWithoutStatusNestedInput;
    roles?: roleUncheckedUpdateManyWithoutStatusNestedInput;
    qrcodes?: qrCodeUncheckedUpdateManyWithoutStatusNestedInput;
    images?: imageUncheckedUpdateManyWithoutStatusNestedInput;
    subtitles?: subtitleUncheckedUpdateManyWithoutStatusNestedInput;
    languages?: languageUncheckedUpdateManyWithoutStatusNestedInput;
    auditLogs?: auditLogUncheckedUpdateManyWithoutStatusNestedInput;
    userProfiles?: userProfileUncheckedUpdateManyWithoutStatusNestedInput;
  };

  export type usersCreateWithoutUserRolesInput = {
    userId?: string;
    username: string;
    password: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    phoneNumbers?: phoneNumberCreateNestedManyWithoutUserInput;
    emails?: emailCreateNestedManyWithoutUserInput;
    userProfile?: userProfileCreateNestedOneWithoutUserInput;
    sessions?: sessionCreateNestedManyWithoutUserInput;
    auditLogs?: auditLogCreateNestedManyWithoutUserInput;
    events?: eventCreateNestedManyWithoutUsersInput;
    status: statusCreateNestedOneWithoutUsersInput;
  };

  export type usersUncheckedCreateWithoutUserRolesInput = {
    userId?: string;
    username: string;
    password: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    statusCode: string;
    phoneNumbers?: phoneNumberUncheckedCreateNestedManyWithoutUserInput;
    emails?: emailUncheckedCreateNestedManyWithoutUserInput;
    userProfile?: userProfileUncheckedCreateNestedOneWithoutUserInput;
    sessions?: sessionUncheckedCreateNestedManyWithoutUserInput;
    auditLogs?: auditLogUncheckedCreateNestedManyWithoutUserInput;
    events?: eventUncheckedCreateNestedManyWithoutUsersInput;
  };

  export type usersCreateOrConnectWithoutUserRolesInput = {
    where: usersWhereUniqueInput;
    create: XOR<
      usersCreateWithoutUserRolesInput,
      usersUncheckedCreateWithoutUserRolesInput
    >;
  };

  export type roleCreateWithoutUserRolesInput = {
    roleName: string;
    description: string;
    status: statusCreateNestedOneWithoutRolesInput;
  };

  export type roleUncheckedCreateWithoutUserRolesInput = {
    roleId?: number;
    roleName: string;
    description: string;
    statusCode: string;
  };

  export type roleCreateOrConnectWithoutUserRolesInput = {
    where: roleWhereUniqueInput;
    create: XOR<
      roleCreateWithoutUserRolesInput,
      roleUncheckedCreateWithoutUserRolesInput
    >;
  };

  export type usersUpsertWithoutUserRolesInput = {
    update: XOR<
      usersUpdateWithoutUserRolesInput,
      usersUncheckedUpdateWithoutUserRolesInput
    >;
    create: XOR<
      usersCreateWithoutUserRolesInput,
      usersUncheckedCreateWithoutUserRolesInput
    >;
    where?: usersWhereInput;
  };

  export type usersUpdateToOneWithWhereWithoutUserRolesInput = {
    where?: usersWhereInput;
    data: XOR<
      usersUpdateWithoutUserRolesInput,
      usersUncheckedUpdateWithoutUserRolesInput
    >;
  };

  export type usersUpdateWithoutUserRolesInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    phoneNumbers?: phoneNumberUpdateManyWithoutUserNestedInput;
    emails?: emailUpdateManyWithoutUserNestedInput;
    userProfile?: userProfileUpdateOneWithoutUserNestedInput;
    sessions?: sessionUpdateManyWithoutUserNestedInput;
    auditLogs?: auditLogUpdateManyWithoutUserNestedInput;
    events?: eventUpdateManyWithoutUsersNestedInput;
    status?: statusUpdateOneRequiredWithoutUsersNestedInput;
  };

  export type usersUncheckedUpdateWithoutUserRolesInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
    phoneNumbers?: phoneNumberUncheckedUpdateManyWithoutUserNestedInput;
    emails?: emailUncheckedUpdateManyWithoutUserNestedInput;
    userProfile?: userProfileUncheckedUpdateOneWithoutUserNestedInput;
    sessions?: sessionUncheckedUpdateManyWithoutUserNestedInput;
    auditLogs?: auditLogUncheckedUpdateManyWithoutUserNestedInput;
    events?: eventUncheckedUpdateManyWithoutUsersNestedInput;
  };

  export type roleUpsertWithoutUserRolesInput = {
    update: XOR<
      roleUpdateWithoutUserRolesInput,
      roleUncheckedUpdateWithoutUserRolesInput
    >;
    create: XOR<
      roleCreateWithoutUserRolesInput,
      roleUncheckedCreateWithoutUserRolesInput
    >;
    where?: roleWhereInput;
  };

  export type roleUpdateToOneWithWhereWithoutUserRolesInput = {
    where?: roleWhereInput;
    data: XOR<
      roleUpdateWithoutUserRolesInput,
      roleUncheckedUpdateWithoutUserRolesInput
    >;
  };

  export type roleUpdateWithoutUserRolesInput = {
    roleName?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    status?: statusUpdateOneRequiredWithoutRolesNestedInput;
  };

  export type roleUncheckedUpdateWithoutUserRolesInput = {
    roleId?: IntFieldUpdateOperationsInput | number;
    roleName?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
  };

  export type userRoleCreateWithoutRoleInput = {
    user: usersCreateNestedOneWithoutUserRolesInput;
  };

  export type userRoleUncheckedCreateWithoutRoleInput = {
    userId: string;
  };

  export type userRoleCreateOrConnectWithoutRoleInput = {
    where: userRoleWhereUniqueInput;
    create: XOR<
      userRoleCreateWithoutRoleInput,
      userRoleUncheckedCreateWithoutRoleInput
    >;
  };

  export type userRoleCreateManyRoleInputEnvelope = {
    data: userRoleCreateManyRoleInput | userRoleCreateManyRoleInput[];
    skipDuplicates?: boolean;
  };

  export type statusCreateWithoutRolesInput = {
    statusCode: string;
    description: string;
    users?: usersCreateNestedManyWithoutStatusInput;
    audios?: audioCreateNestedManyWithoutStatusInput;
    exhibits?: exhibitCreateNestedManyWithoutStatusInput;
    phoneNumbers?: phoneNumberCreateNestedManyWithoutStatusInput;
    emails?: emailCreateNestedManyWithoutStatusInput;
    qrcodes?: qrCodeCreateNestedManyWithoutStatusInput;
    images?: imageCreateNestedManyWithoutStatusInput;
    subtitles?: subtitleCreateNestedManyWithoutStatusInput;
    languages?: languageCreateNestedManyWithoutStatusInput;
    auditLogs?: auditLogCreateNestedManyWithoutStatusInput;
    userProfiles?: userProfileCreateNestedManyWithoutStatusInput;
  };

  export type statusUncheckedCreateWithoutRolesInput = {
    statusCode: string;
    description: string;
    users?: usersUncheckedCreateNestedManyWithoutStatusInput;
    audios?: audioUncheckedCreateNestedManyWithoutStatusInput;
    exhibits?: exhibitUncheckedCreateNestedManyWithoutStatusInput;
    phoneNumbers?: phoneNumberUncheckedCreateNestedManyWithoutStatusInput;
    emails?: emailUncheckedCreateNestedManyWithoutStatusInput;
    qrcodes?: qrCodeUncheckedCreateNestedManyWithoutStatusInput;
    images?: imageUncheckedCreateNestedManyWithoutStatusInput;
    subtitles?: subtitleUncheckedCreateNestedManyWithoutStatusInput;
    languages?: languageUncheckedCreateNestedManyWithoutStatusInput;
    auditLogs?: auditLogUncheckedCreateNestedManyWithoutStatusInput;
    userProfiles?: userProfileUncheckedCreateNestedManyWithoutStatusInput;
  };

  export type statusCreateOrConnectWithoutRolesInput = {
    where: statusWhereUniqueInput;
    create: XOR<
      statusCreateWithoutRolesInput,
      statusUncheckedCreateWithoutRolesInput
    >;
  };

  export type userRoleUpsertWithWhereUniqueWithoutRoleInput = {
    where: userRoleWhereUniqueInput;
    update: XOR<
      userRoleUpdateWithoutRoleInput,
      userRoleUncheckedUpdateWithoutRoleInput
    >;
    create: XOR<
      userRoleCreateWithoutRoleInput,
      userRoleUncheckedCreateWithoutRoleInput
    >;
  };

  export type userRoleUpdateWithWhereUniqueWithoutRoleInput = {
    where: userRoleWhereUniqueInput;
    data: XOR<
      userRoleUpdateWithoutRoleInput,
      userRoleUncheckedUpdateWithoutRoleInput
    >;
  };

  export type userRoleUpdateManyWithWhereWithoutRoleInput = {
    where: userRoleScalarWhereInput;
    data: XOR<
      userRoleUpdateManyMutationInput,
      userRoleUncheckedUpdateManyWithoutRoleInput
    >;
  };

  export type statusUpsertWithoutRolesInput = {
    update: XOR<
      statusUpdateWithoutRolesInput,
      statusUncheckedUpdateWithoutRolesInput
    >;
    create: XOR<
      statusCreateWithoutRolesInput,
      statusUncheckedCreateWithoutRolesInput
    >;
    where?: statusWhereInput;
  };

  export type statusUpdateToOneWithWhereWithoutRolesInput = {
    where?: statusWhereInput;
    data: XOR<
      statusUpdateWithoutRolesInput,
      statusUncheckedUpdateWithoutRolesInput
    >;
  };

  export type statusUpdateWithoutRolesInput = {
    statusCode?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    users?: usersUpdateManyWithoutStatusNestedInput;
    audios?: audioUpdateManyWithoutStatusNestedInput;
    exhibits?: exhibitUpdateManyWithoutStatusNestedInput;
    phoneNumbers?: phoneNumberUpdateManyWithoutStatusNestedInput;
    emails?: emailUpdateManyWithoutStatusNestedInput;
    qrcodes?: qrCodeUpdateManyWithoutStatusNestedInput;
    images?: imageUpdateManyWithoutStatusNestedInput;
    subtitles?: subtitleUpdateManyWithoutStatusNestedInput;
    languages?: languageUpdateManyWithoutStatusNestedInput;
    auditLogs?: auditLogUpdateManyWithoutStatusNestedInput;
    userProfiles?: userProfileUpdateManyWithoutStatusNestedInput;
  };

  export type statusUncheckedUpdateWithoutRolesInput = {
    statusCode?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    users?: usersUncheckedUpdateManyWithoutStatusNestedInput;
    audios?: audioUncheckedUpdateManyWithoutStatusNestedInput;
    exhibits?: exhibitUncheckedUpdateManyWithoutStatusNestedInput;
    phoneNumbers?: phoneNumberUncheckedUpdateManyWithoutStatusNestedInput;
    emails?: emailUncheckedUpdateManyWithoutStatusNestedInput;
    qrcodes?: qrCodeUncheckedUpdateManyWithoutStatusNestedInput;
    images?: imageUncheckedUpdateManyWithoutStatusNestedInput;
    subtitles?: subtitleUncheckedUpdateManyWithoutStatusNestedInput;
    languages?: languageUncheckedUpdateManyWithoutStatusNestedInput;
    auditLogs?: auditLogUncheckedUpdateManyWithoutStatusNestedInput;
    userProfiles?: userProfileUncheckedUpdateManyWithoutStatusNestedInput;
  };

  export type exhibitCreateWithoutQrCodeInput = {
    exhibitId?: string;
    title: string;
    description: string;
    createdBy: string;
    modifiedBy: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    audio: audioCreateNestedOneWithoutExhibitInput;
    image: imageCreateNestedOneWithoutExhibitInput;
    subtitles?: exhibitSubtitleCreateNestedManyWithoutExhibitInput;
    status: statusCreateNestedOneWithoutExhibitsInput;
    exhibitAudioRelation?: exhibitAudioRelationCreateNestedManyWithoutExhibitInput;
  };

  export type exhibitUncheckedCreateWithoutQrCodeInput = {
    exhibitId?: string;
    title: string;
    description: string;
    audioId: string;
    createdBy: string;
    modifiedBy: string;
    imageId: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    statusCode: string;
    subtitles?: exhibitSubtitleUncheckedCreateNestedManyWithoutExhibitInput;
    exhibitAudioRelation?: exhibitAudioRelationUncheckedCreateNestedManyWithoutExhibitInput;
  };

  export type exhibitCreateOrConnectWithoutQrCodeInput = {
    where: exhibitWhereUniqueInput;
    create: XOR<
      exhibitCreateWithoutQrCodeInput,
      exhibitUncheckedCreateWithoutQrCodeInput
    >;
  };

  export type exhibitCreateManyQrCodeInputEnvelope = {
    data: exhibitCreateManyQrCodeInput | exhibitCreateManyQrCodeInput[];
    skipDuplicates?: boolean;
  };

  export type statusCreateWithoutQrcodesInput = {
    statusCode: string;
    description: string;
    users?: usersCreateNestedManyWithoutStatusInput;
    audios?: audioCreateNestedManyWithoutStatusInput;
    exhibits?: exhibitCreateNestedManyWithoutStatusInput;
    phoneNumbers?: phoneNumberCreateNestedManyWithoutStatusInput;
    emails?: emailCreateNestedManyWithoutStatusInput;
    roles?: roleCreateNestedManyWithoutStatusInput;
    images?: imageCreateNestedManyWithoutStatusInput;
    subtitles?: subtitleCreateNestedManyWithoutStatusInput;
    languages?: languageCreateNestedManyWithoutStatusInput;
    auditLogs?: auditLogCreateNestedManyWithoutStatusInput;
    userProfiles?: userProfileCreateNestedManyWithoutStatusInput;
  };

  export type statusUncheckedCreateWithoutQrcodesInput = {
    statusCode: string;
    description: string;
    users?: usersUncheckedCreateNestedManyWithoutStatusInput;
    audios?: audioUncheckedCreateNestedManyWithoutStatusInput;
    exhibits?: exhibitUncheckedCreateNestedManyWithoutStatusInput;
    phoneNumbers?: phoneNumberUncheckedCreateNestedManyWithoutStatusInput;
    emails?: emailUncheckedCreateNestedManyWithoutStatusInput;
    roles?: roleUncheckedCreateNestedManyWithoutStatusInput;
    images?: imageUncheckedCreateNestedManyWithoutStatusInput;
    subtitles?: subtitleUncheckedCreateNestedManyWithoutStatusInput;
    languages?: languageUncheckedCreateNestedManyWithoutStatusInput;
    auditLogs?: auditLogUncheckedCreateNestedManyWithoutStatusInput;
    userProfiles?: userProfileUncheckedCreateNestedManyWithoutStatusInput;
  };

  export type statusCreateOrConnectWithoutQrcodesInput = {
    where: statusWhereUniqueInput;
    create: XOR<
      statusCreateWithoutQrcodesInput,
      statusUncheckedCreateWithoutQrcodesInput
    >;
  };

  export type exhibitUpsertWithWhereUniqueWithoutQrCodeInput = {
    where: exhibitWhereUniqueInput;
    update: XOR<
      exhibitUpdateWithoutQrCodeInput,
      exhibitUncheckedUpdateWithoutQrCodeInput
    >;
    create: XOR<
      exhibitCreateWithoutQrCodeInput,
      exhibitUncheckedCreateWithoutQrCodeInput
    >;
  };

  export type exhibitUpdateWithWhereUniqueWithoutQrCodeInput = {
    where: exhibitWhereUniqueInput;
    data: XOR<
      exhibitUpdateWithoutQrCodeInput,
      exhibitUncheckedUpdateWithoutQrCodeInput
    >;
  };

  export type exhibitUpdateManyWithWhereWithoutQrCodeInput = {
    where: exhibitScalarWhereInput;
    data: XOR<
      exhibitUpdateManyMutationInput,
      exhibitUncheckedUpdateManyWithoutQrCodeInput
    >;
  };

  export type statusUpsertWithoutQrcodesInput = {
    update: XOR<
      statusUpdateWithoutQrcodesInput,
      statusUncheckedUpdateWithoutQrcodesInput
    >;
    create: XOR<
      statusCreateWithoutQrcodesInput,
      statusUncheckedCreateWithoutQrcodesInput
    >;
    where?: statusWhereInput;
  };

  export type statusUpdateToOneWithWhereWithoutQrcodesInput = {
    where?: statusWhereInput;
    data: XOR<
      statusUpdateWithoutQrcodesInput,
      statusUncheckedUpdateWithoutQrcodesInput
    >;
  };

  export type statusUpdateWithoutQrcodesInput = {
    statusCode?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    users?: usersUpdateManyWithoutStatusNestedInput;
    audios?: audioUpdateManyWithoutStatusNestedInput;
    exhibits?: exhibitUpdateManyWithoutStatusNestedInput;
    phoneNumbers?: phoneNumberUpdateManyWithoutStatusNestedInput;
    emails?: emailUpdateManyWithoutStatusNestedInput;
    roles?: roleUpdateManyWithoutStatusNestedInput;
    images?: imageUpdateManyWithoutStatusNestedInput;
    subtitles?: subtitleUpdateManyWithoutStatusNestedInput;
    languages?: languageUpdateManyWithoutStatusNestedInput;
    auditLogs?: auditLogUpdateManyWithoutStatusNestedInput;
    userProfiles?: userProfileUpdateManyWithoutStatusNestedInput;
  };

  export type statusUncheckedUpdateWithoutQrcodesInput = {
    statusCode?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    users?: usersUncheckedUpdateManyWithoutStatusNestedInput;
    audios?: audioUncheckedUpdateManyWithoutStatusNestedInput;
    exhibits?: exhibitUncheckedUpdateManyWithoutStatusNestedInput;
    phoneNumbers?: phoneNumberUncheckedUpdateManyWithoutStatusNestedInput;
    emails?: emailUncheckedUpdateManyWithoutStatusNestedInput;
    roles?: roleUncheckedUpdateManyWithoutStatusNestedInput;
    images?: imageUncheckedUpdateManyWithoutStatusNestedInput;
    subtitles?: subtitleUncheckedUpdateManyWithoutStatusNestedInput;
    languages?: languageUncheckedUpdateManyWithoutStatusNestedInput;
    auditLogs?: auditLogUncheckedUpdateManyWithoutStatusNestedInput;
    userProfiles?: userProfileUncheckedUpdateManyWithoutStatusNestedInput;
  };

  export type exhibitCreateWithoutImageInput = {
    exhibitId?: string;
    title: string;
    description: string;
    createdBy: string;
    modifiedBy: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    audio: audioCreateNestedOneWithoutExhibitInput;
    qrCode: qrCodeCreateNestedOneWithoutExhibitInput;
    subtitles?: exhibitSubtitleCreateNestedManyWithoutExhibitInput;
    status: statusCreateNestedOneWithoutExhibitsInput;
    exhibitAudioRelation?: exhibitAudioRelationCreateNestedManyWithoutExhibitInput;
  };

  export type exhibitUncheckedCreateWithoutImageInput = {
    exhibitId?: string;
    title: string;
    description: string;
    audioId: string;
    createdBy: string;
    modifiedBy: string;
    qrCodeId: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    statusCode: string;
    subtitles?: exhibitSubtitleUncheckedCreateNestedManyWithoutExhibitInput;
    exhibitAudioRelation?: exhibitAudioRelationUncheckedCreateNestedManyWithoutExhibitInput;
  };

  export type exhibitCreateOrConnectWithoutImageInput = {
    where: exhibitWhereUniqueInput;
    create: XOR<
      exhibitCreateWithoutImageInput,
      exhibitUncheckedCreateWithoutImageInput
    >;
  };

  export type exhibitCreateManyImageInputEnvelope = {
    data: exhibitCreateManyImageInput | exhibitCreateManyImageInput[];
    skipDuplicates?: boolean;
  };

  export type statusCreateWithoutImagesInput = {
    statusCode: string;
    description: string;
    users?: usersCreateNestedManyWithoutStatusInput;
    audios?: audioCreateNestedManyWithoutStatusInput;
    exhibits?: exhibitCreateNestedManyWithoutStatusInput;
    phoneNumbers?: phoneNumberCreateNestedManyWithoutStatusInput;
    emails?: emailCreateNestedManyWithoutStatusInput;
    roles?: roleCreateNestedManyWithoutStatusInput;
    qrcodes?: qrCodeCreateNestedManyWithoutStatusInput;
    subtitles?: subtitleCreateNestedManyWithoutStatusInput;
    languages?: languageCreateNestedManyWithoutStatusInput;
    auditLogs?: auditLogCreateNestedManyWithoutStatusInput;
    userProfiles?: userProfileCreateNestedManyWithoutStatusInput;
  };

  export type statusUncheckedCreateWithoutImagesInput = {
    statusCode: string;
    description: string;
    users?: usersUncheckedCreateNestedManyWithoutStatusInput;
    audios?: audioUncheckedCreateNestedManyWithoutStatusInput;
    exhibits?: exhibitUncheckedCreateNestedManyWithoutStatusInput;
    phoneNumbers?: phoneNumberUncheckedCreateNestedManyWithoutStatusInput;
    emails?: emailUncheckedCreateNestedManyWithoutStatusInput;
    roles?: roleUncheckedCreateNestedManyWithoutStatusInput;
    qrcodes?: qrCodeUncheckedCreateNestedManyWithoutStatusInput;
    subtitles?: subtitleUncheckedCreateNestedManyWithoutStatusInput;
    languages?: languageUncheckedCreateNestedManyWithoutStatusInput;
    auditLogs?: auditLogUncheckedCreateNestedManyWithoutStatusInput;
    userProfiles?: userProfileUncheckedCreateNestedManyWithoutStatusInput;
  };

  export type statusCreateOrConnectWithoutImagesInput = {
    where: statusWhereUniqueInput;
    create: XOR<
      statusCreateWithoutImagesInput,
      statusUncheckedCreateWithoutImagesInput
    >;
  };

  export type exhibitUpsertWithWhereUniqueWithoutImageInput = {
    where: exhibitWhereUniqueInput;
    update: XOR<
      exhibitUpdateWithoutImageInput,
      exhibitUncheckedUpdateWithoutImageInput
    >;
    create: XOR<
      exhibitCreateWithoutImageInput,
      exhibitUncheckedCreateWithoutImageInput
    >;
  };

  export type exhibitUpdateWithWhereUniqueWithoutImageInput = {
    where: exhibitWhereUniqueInput;
    data: XOR<
      exhibitUpdateWithoutImageInput,
      exhibitUncheckedUpdateWithoutImageInput
    >;
  };

  export type exhibitUpdateManyWithWhereWithoutImageInput = {
    where: exhibitScalarWhereInput;
    data: XOR<
      exhibitUpdateManyMutationInput,
      exhibitUncheckedUpdateManyWithoutImageInput
    >;
  };

  export type statusUpsertWithoutImagesInput = {
    update: XOR<
      statusUpdateWithoutImagesInput,
      statusUncheckedUpdateWithoutImagesInput
    >;
    create: XOR<
      statusCreateWithoutImagesInput,
      statusUncheckedCreateWithoutImagesInput
    >;
    where?: statusWhereInput;
  };

  export type statusUpdateToOneWithWhereWithoutImagesInput = {
    where?: statusWhereInput;
    data: XOR<
      statusUpdateWithoutImagesInput,
      statusUncheckedUpdateWithoutImagesInput
    >;
  };

  export type statusUpdateWithoutImagesInput = {
    statusCode?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    users?: usersUpdateManyWithoutStatusNestedInput;
    audios?: audioUpdateManyWithoutStatusNestedInput;
    exhibits?: exhibitUpdateManyWithoutStatusNestedInput;
    phoneNumbers?: phoneNumberUpdateManyWithoutStatusNestedInput;
    emails?: emailUpdateManyWithoutStatusNestedInput;
    roles?: roleUpdateManyWithoutStatusNestedInput;
    qrcodes?: qrCodeUpdateManyWithoutStatusNestedInput;
    subtitles?: subtitleUpdateManyWithoutStatusNestedInput;
    languages?: languageUpdateManyWithoutStatusNestedInput;
    auditLogs?: auditLogUpdateManyWithoutStatusNestedInput;
    userProfiles?: userProfileUpdateManyWithoutStatusNestedInput;
  };

  export type statusUncheckedUpdateWithoutImagesInput = {
    statusCode?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    users?: usersUncheckedUpdateManyWithoutStatusNestedInput;
    audios?: audioUncheckedUpdateManyWithoutStatusNestedInput;
    exhibits?: exhibitUncheckedUpdateManyWithoutStatusNestedInput;
    phoneNumbers?: phoneNumberUncheckedUpdateManyWithoutStatusNestedInput;
    emails?: emailUncheckedUpdateManyWithoutStatusNestedInput;
    roles?: roleUncheckedUpdateManyWithoutStatusNestedInput;
    qrcodes?: qrCodeUncheckedUpdateManyWithoutStatusNestedInput;
    subtitles?: subtitleUncheckedUpdateManyWithoutStatusNestedInput;
    languages?: languageUncheckedUpdateManyWithoutStatusNestedInput;
    auditLogs?: auditLogUncheckedUpdateManyWithoutStatusNestedInput;
    userProfiles?: userProfileUncheckedUpdateManyWithoutStatusNestedInput;
  };

  export type sessionCreateWithoutEventsInput = {
    sessionId?: string;
    deviceInfo: string;
    isActive: boolean;
    createdAt: Date | string;
    user: usersCreateNestedOneWithoutSessionsInput;
  };

  export type sessionUncheckedCreateWithoutEventsInput = {
    sessionId?: string;
    userId: string;
    deviceInfo: string;
    isActive: boolean;
    createdAt: Date | string;
  };

  export type sessionCreateOrConnectWithoutEventsInput = {
    where: sessionWhereUniqueInput;
    create: XOR<
      sessionCreateWithoutEventsInput,
      sessionUncheckedCreateWithoutEventsInput
    >;
  };

  export type usersCreateWithoutEventsInput = {
    userId?: string;
    username: string;
    password: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    phoneNumbers?: phoneNumberCreateNestedManyWithoutUserInput;
    emails?: emailCreateNestedManyWithoutUserInput;
    userProfile?: userProfileCreateNestedOneWithoutUserInput;
    sessions?: sessionCreateNestedManyWithoutUserInput;
    auditLogs?: auditLogCreateNestedManyWithoutUserInput;
    userRoles?: userRoleCreateNestedManyWithoutUserInput;
    status: statusCreateNestedOneWithoutUsersInput;
  };

  export type usersUncheckedCreateWithoutEventsInput = {
    userId?: string;
    username: string;
    password: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    statusCode: string;
    phoneNumbers?: phoneNumberUncheckedCreateNestedManyWithoutUserInput;
    emails?: emailUncheckedCreateNestedManyWithoutUserInput;
    userProfile?: userProfileUncheckedCreateNestedOneWithoutUserInput;
    sessions?: sessionUncheckedCreateNestedManyWithoutUserInput;
    auditLogs?: auditLogUncheckedCreateNestedManyWithoutUserInput;
    userRoles?: userRoleUncheckedCreateNestedManyWithoutUserInput;
  };

  export type usersCreateOrConnectWithoutEventsInput = {
    where: usersWhereUniqueInput;
    create: XOR<
      usersCreateWithoutEventsInput,
      usersUncheckedCreateWithoutEventsInput
    >;
  };

  export type sessionUpsertWithoutEventsInput = {
    update: XOR<
      sessionUpdateWithoutEventsInput,
      sessionUncheckedUpdateWithoutEventsInput
    >;
    create: XOR<
      sessionCreateWithoutEventsInput,
      sessionUncheckedCreateWithoutEventsInput
    >;
    where?: sessionWhereInput;
  };

  export type sessionUpdateToOneWithWhereWithoutEventsInput = {
    where?: sessionWhereInput;
    data: XOR<
      sessionUpdateWithoutEventsInput,
      sessionUncheckedUpdateWithoutEventsInput
    >;
  };

  export type sessionUpdateWithoutEventsInput = {
    sessionId?: StringFieldUpdateOperationsInput | string;
    deviceInfo?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: usersUpdateOneRequiredWithoutSessionsNestedInput;
  };

  export type sessionUncheckedUpdateWithoutEventsInput = {
    sessionId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    deviceInfo?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type usersUpsertWithoutEventsInput = {
    update: XOR<
      usersUpdateWithoutEventsInput,
      usersUncheckedUpdateWithoutEventsInput
    >;
    create: XOR<
      usersCreateWithoutEventsInput,
      usersUncheckedCreateWithoutEventsInput
    >;
    where?: usersWhereInput;
  };

  export type usersUpdateToOneWithWhereWithoutEventsInput = {
    where?: usersWhereInput;
    data: XOR<
      usersUpdateWithoutEventsInput,
      usersUncheckedUpdateWithoutEventsInput
    >;
  };

  export type usersUpdateWithoutEventsInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    phoneNumbers?: phoneNumberUpdateManyWithoutUserNestedInput;
    emails?: emailUpdateManyWithoutUserNestedInput;
    userProfile?: userProfileUpdateOneWithoutUserNestedInput;
    sessions?: sessionUpdateManyWithoutUserNestedInput;
    auditLogs?: auditLogUpdateManyWithoutUserNestedInput;
    userRoles?: userRoleUpdateManyWithoutUserNestedInput;
    status?: statusUpdateOneRequiredWithoutUsersNestedInput;
  };

  export type usersUncheckedUpdateWithoutEventsInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
    phoneNumbers?: phoneNumberUncheckedUpdateManyWithoutUserNestedInput;
    emails?: emailUncheckedUpdateManyWithoutUserNestedInput;
    userProfile?: userProfileUncheckedUpdateOneWithoutUserNestedInput;
    sessions?: sessionUncheckedUpdateManyWithoutUserNestedInput;
    auditLogs?: auditLogUncheckedUpdateManyWithoutUserNestedInput;
    userRoles?: userRoleUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type usersCreateWithoutSessionsInput = {
    userId?: string;
    username: string;
    password: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    phoneNumbers?: phoneNumberCreateNestedManyWithoutUserInput;
    emails?: emailCreateNestedManyWithoutUserInput;
    userProfile?: userProfileCreateNestedOneWithoutUserInput;
    auditLogs?: auditLogCreateNestedManyWithoutUserInput;
    events?: eventCreateNestedManyWithoutUsersInput;
    userRoles?: userRoleCreateNestedManyWithoutUserInput;
    status: statusCreateNestedOneWithoutUsersInput;
  };

  export type usersUncheckedCreateWithoutSessionsInput = {
    userId?: string;
    username: string;
    password: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    statusCode: string;
    phoneNumbers?: phoneNumberUncheckedCreateNestedManyWithoutUserInput;
    emails?: emailUncheckedCreateNestedManyWithoutUserInput;
    userProfile?: userProfileUncheckedCreateNestedOneWithoutUserInput;
    auditLogs?: auditLogUncheckedCreateNestedManyWithoutUserInput;
    events?: eventUncheckedCreateNestedManyWithoutUsersInput;
    userRoles?: userRoleUncheckedCreateNestedManyWithoutUserInput;
  };

  export type usersCreateOrConnectWithoutSessionsInput = {
    where: usersWhereUniqueInput;
    create: XOR<
      usersCreateWithoutSessionsInput,
      usersUncheckedCreateWithoutSessionsInput
    >;
  };

  export type eventCreateWithoutSessionInput = {
    eventId?: string;
    entityId: number;
    entityName: string;
    timestamp: Date | string;
    users?: usersCreateNestedOneWithoutEventsInput;
  };

  export type eventUncheckedCreateWithoutSessionInput = {
    eventId?: string;
    entityId: number;
    entityName: string;
    timestamp: Date | string;
    usersUserId?: string | null;
  };

  export type eventCreateOrConnectWithoutSessionInput = {
    where: eventWhereUniqueInput;
    create: XOR<
      eventCreateWithoutSessionInput,
      eventUncheckedCreateWithoutSessionInput
    >;
  };

  export type eventCreateManySessionInputEnvelope = {
    data: eventCreateManySessionInput | eventCreateManySessionInput[];
    skipDuplicates?: boolean;
  };

  export type usersUpsertWithoutSessionsInput = {
    update: XOR<
      usersUpdateWithoutSessionsInput,
      usersUncheckedUpdateWithoutSessionsInput
    >;
    create: XOR<
      usersCreateWithoutSessionsInput,
      usersUncheckedCreateWithoutSessionsInput
    >;
    where?: usersWhereInput;
  };

  export type usersUpdateToOneWithWhereWithoutSessionsInput = {
    where?: usersWhereInput;
    data: XOR<
      usersUpdateWithoutSessionsInput,
      usersUncheckedUpdateWithoutSessionsInput
    >;
  };

  export type usersUpdateWithoutSessionsInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    phoneNumbers?: phoneNumberUpdateManyWithoutUserNestedInput;
    emails?: emailUpdateManyWithoutUserNestedInput;
    userProfile?: userProfileUpdateOneWithoutUserNestedInput;
    auditLogs?: auditLogUpdateManyWithoutUserNestedInput;
    events?: eventUpdateManyWithoutUsersNestedInput;
    userRoles?: userRoleUpdateManyWithoutUserNestedInput;
    status?: statusUpdateOneRequiredWithoutUsersNestedInput;
  };

  export type usersUncheckedUpdateWithoutSessionsInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
    phoneNumbers?: phoneNumberUncheckedUpdateManyWithoutUserNestedInput;
    emails?: emailUncheckedUpdateManyWithoutUserNestedInput;
    userProfile?: userProfileUncheckedUpdateOneWithoutUserNestedInput;
    auditLogs?: auditLogUncheckedUpdateManyWithoutUserNestedInput;
    events?: eventUncheckedUpdateManyWithoutUsersNestedInput;
    userRoles?: userRoleUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type eventUpsertWithWhereUniqueWithoutSessionInput = {
    where: eventWhereUniqueInput;
    update: XOR<
      eventUpdateWithoutSessionInput,
      eventUncheckedUpdateWithoutSessionInput
    >;
    create: XOR<
      eventCreateWithoutSessionInput,
      eventUncheckedCreateWithoutSessionInput
    >;
  };

  export type eventUpdateWithWhereUniqueWithoutSessionInput = {
    where: eventWhereUniqueInput;
    data: XOR<
      eventUpdateWithoutSessionInput,
      eventUncheckedUpdateWithoutSessionInput
    >;
  };

  export type eventUpdateManyWithWhereWithoutSessionInput = {
    where: eventScalarWhereInput;
    data: XOR<
      eventUpdateManyMutationInput,
      eventUncheckedUpdateManyWithoutSessionInput
    >;
  };

  export type usersCreateWithoutUserProfileInput = {
    userId?: string;
    username: string;
    password: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    phoneNumbers?: phoneNumberCreateNestedManyWithoutUserInput;
    emails?: emailCreateNestedManyWithoutUserInput;
    sessions?: sessionCreateNestedManyWithoutUserInput;
    auditLogs?: auditLogCreateNestedManyWithoutUserInput;
    events?: eventCreateNestedManyWithoutUsersInput;
    userRoles?: userRoleCreateNestedManyWithoutUserInput;
    status: statusCreateNestedOneWithoutUsersInput;
  };

  export type usersUncheckedCreateWithoutUserProfileInput = {
    userId?: string;
    username: string;
    password: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    statusCode: string;
    phoneNumbers?: phoneNumberUncheckedCreateNestedManyWithoutUserInput;
    emails?: emailUncheckedCreateNestedManyWithoutUserInput;
    sessions?: sessionUncheckedCreateNestedManyWithoutUserInput;
    auditLogs?: auditLogUncheckedCreateNestedManyWithoutUserInput;
    events?: eventUncheckedCreateNestedManyWithoutUsersInput;
    userRoles?: userRoleUncheckedCreateNestedManyWithoutUserInput;
  };

  export type usersCreateOrConnectWithoutUserProfileInput = {
    where: usersWhereUniqueInput;
    create: XOR<
      usersCreateWithoutUserProfileInput,
      usersUncheckedCreateWithoutUserProfileInput
    >;
  };

  export type languageCreateWithoutProfilesInput = {
    languageCode: string;
    languageName: string;
    audios?: audioCreateNestedManyWithoutLanguageInput;
    subtitles?: subtitleCreateNestedManyWithoutLanguageInput;
    status: statusCreateNestedOneWithoutLanguagesInput;
  };

  export type languageUncheckedCreateWithoutProfilesInput = {
    languageCode: string;
    languageName: string;
    statusCode: string;
    audios?: audioUncheckedCreateNestedManyWithoutLanguageInput;
    subtitles?: subtitleUncheckedCreateNestedManyWithoutLanguageInput;
  };

  export type languageCreateOrConnectWithoutProfilesInput = {
    where: languageWhereUniqueInput;
    create: XOR<
      languageCreateWithoutProfilesInput,
      languageUncheckedCreateWithoutProfilesInput
    >;
  };

  export type statusCreateWithoutUserProfilesInput = {
    statusCode: string;
    description: string;
    users?: usersCreateNestedManyWithoutStatusInput;
    audios?: audioCreateNestedManyWithoutStatusInput;
    exhibits?: exhibitCreateNestedManyWithoutStatusInput;
    phoneNumbers?: phoneNumberCreateNestedManyWithoutStatusInput;
    emails?: emailCreateNestedManyWithoutStatusInput;
    roles?: roleCreateNestedManyWithoutStatusInput;
    qrcodes?: qrCodeCreateNestedManyWithoutStatusInput;
    images?: imageCreateNestedManyWithoutStatusInput;
    subtitles?: subtitleCreateNestedManyWithoutStatusInput;
    languages?: languageCreateNestedManyWithoutStatusInput;
    auditLogs?: auditLogCreateNestedManyWithoutStatusInput;
  };

  export type statusUncheckedCreateWithoutUserProfilesInput = {
    statusCode: string;
    description: string;
    users?: usersUncheckedCreateNestedManyWithoutStatusInput;
    audios?: audioUncheckedCreateNestedManyWithoutStatusInput;
    exhibits?: exhibitUncheckedCreateNestedManyWithoutStatusInput;
    phoneNumbers?: phoneNumberUncheckedCreateNestedManyWithoutStatusInput;
    emails?: emailUncheckedCreateNestedManyWithoutStatusInput;
    roles?: roleUncheckedCreateNestedManyWithoutStatusInput;
    qrcodes?: qrCodeUncheckedCreateNestedManyWithoutStatusInput;
    images?: imageUncheckedCreateNestedManyWithoutStatusInput;
    subtitles?: subtitleUncheckedCreateNestedManyWithoutStatusInput;
    languages?: languageUncheckedCreateNestedManyWithoutStatusInput;
    auditLogs?: auditLogUncheckedCreateNestedManyWithoutStatusInput;
  };

  export type statusCreateOrConnectWithoutUserProfilesInput = {
    where: statusWhereUniqueInput;
    create: XOR<
      statusCreateWithoutUserProfilesInput,
      statusUncheckedCreateWithoutUserProfilesInput
    >;
  };

  export type usersUpsertWithoutUserProfileInput = {
    update: XOR<
      usersUpdateWithoutUserProfileInput,
      usersUncheckedUpdateWithoutUserProfileInput
    >;
    create: XOR<
      usersCreateWithoutUserProfileInput,
      usersUncheckedCreateWithoutUserProfileInput
    >;
    where?: usersWhereInput;
  };

  export type usersUpdateToOneWithWhereWithoutUserProfileInput = {
    where?: usersWhereInput;
    data: XOR<
      usersUpdateWithoutUserProfileInput,
      usersUncheckedUpdateWithoutUserProfileInput
    >;
  };

  export type usersUpdateWithoutUserProfileInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    phoneNumbers?: phoneNumberUpdateManyWithoutUserNestedInput;
    emails?: emailUpdateManyWithoutUserNestedInput;
    sessions?: sessionUpdateManyWithoutUserNestedInput;
    auditLogs?: auditLogUpdateManyWithoutUserNestedInput;
    events?: eventUpdateManyWithoutUsersNestedInput;
    userRoles?: userRoleUpdateManyWithoutUserNestedInput;
    status?: statusUpdateOneRequiredWithoutUsersNestedInput;
  };

  export type usersUncheckedUpdateWithoutUserProfileInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
    phoneNumbers?: phoneNumberUncheckedUpdateManyWithoutUserNestedInput;
    emails?: emailUncheckedUpdateManyWithoutUserNestedInput;
    sessions?: sessionUncheckedUpdateManyWithoutUserNestedInput;
    auditLogs?: auditLogUncheckedUpdateManyWithoutUserNestedInput;
    events?: eventUncheckedUpdateManyWithoutUsersNestedInput;
    userRoles?: userRoleUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type languageUpsertWithoutProfilesInput = {
    update: XOR<
      languageUpdateWithoutProfilesInput,
      languageUncheckedUpdateWithoutProfilesInput
    >;
    create: XOR<
      languageCreateWithoutProfilesInput,
      languageUncheckedCreateWithoutProfilesInput
    >;
    where?: languageWhereInput;
  };

  export type languageUpdateToOneWithWhereWithoutProfilesInput = {
    where?: languageWhereInput;
    data: XOR<
      languageUpdateWithoutProfilesInput,
      languageUncheckedUpdateWithoutProfilesInput
    >;
  };

  export type languageUpdateWithoutProfilesInput = {
    languageCode?: StringFieldUpdateOperationsInput | string;
    languageName?: StringFieldUpdateOperationsInput | string;
    audios?: audioUpdateManyWithoutLanguageNestedInput;
    subtitles?: subtitleUpdateManyWithoutLanguageNestedInput;
    status?: statusUpdateOneRequiredWithoutLanguagesNestedInput;
  };

  export type languageUncheckedUpdateWithoutProfilesInput = {
    languageCode?: StringFieldUpdateOperationsInput | string;
    languageName?: StringFieldUpdateOperationsInput | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
    audios?: audioUncheckedUpdateManyWithoutLanguageNestedInput;
    subtitles?: subtitleUncheckedUpdateManyWithoutLanguageNestedInput;
  };

  export type statusUpsertWithoutUserProfilesInput = {
    update: XOR<
      statusUpdateWithoutUserProfilesInput,
      statusUncheckedUpdateWithoutUserProfilesInput
    >;
    create: XOR<
      statusCreateWithoutUserProfilesInput,
      statusUncheckedCreateWithoutUserProfilesInput
    >;
    where?: statusWhereInput;
  };

  export type statusUpdateToOneWithWhereWithoutUserProfilesInput = {
    where?: statusWhereInput;
    data: XOR<
      statusUpdateWithoutUserProfilesInput,
      statusUncheckedUpdateWithoutUserProfilesInput
    >;
  };

  export type statusUpdateWithoutUserProfilesInput = {
    statusCode?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    users?: usersUpdateManyWithoutStatusNestedInput;
    audios?: audioUpdateManyWithoutStatusNestedInput;
    exhibits?: exhibitUpdateManyWithoutStatusNestedInput;
    phoneNumbers?: phoneNumberUpdateManyWithoutStatusNestedInput;
    emails?: emailUpdateManyWithoutStatusNestedInput;
    roles?: roleUpdateManyWithoutStatusNestedInput;
    qrcodes?: qrCodeUpdateManyWithoutStatusNestedInput;
    images?: imageUpdateManyWithoutStatusNestedInput;
    subtitles?: subtitleUpdateManyWithoutStatusNestedInput;
    languages?: languageUpdateManyWithoutStatusNestedInput;
    auditLogs?: auditLogUpdateManyWithoutStatusNestedInput;
  };

  export type statusUncheckedUpdateWithoutUserProfilesInput = {
    statusCode?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    users?: usersUncheckedUpdateManyWithoutStatusNestedInput;
    audios?: audioUncheckedUpdateManyWithoutStatusNestedInput;
    exhibits?: exhibitUncheckedUpdateManyWithoutStatusNestedInput;
    phoneNumbers?: phoneNumberUncheckedUpdateManyWithoutStatusNestedInput;
    emails?: emailUncheckedUpdateManyWithoutStatusNestedInput;
    roles?: roleUncheckedUpdateManyWithoutStatusNestedInput;
    qrcodes?: qrCodeUncheckedUpdateManyWithoutStatusNestedInput;
    images?: imageUncheckedUpdateManyWithoutStatusNestedInput;
    subtitles?: subtitleUncheckedUpdateManyWithoutStatusNestedInput;
    languages?: languageUncheckedUpdateManyWithoutStatusNestedInput;
    auditLogs?: auditLogUncheckedUpdateManyWithoutStatusNestedInput;
  };

  export type audioCreateWithoutLanguageInput = {
    audioId?: string;
    fileUrl: string;
    description: string;
    createdBy: string;
    createdAt: Date | string;
    status: statusCreateNestedOneWithoutAudiosInput;
    exhibits?: exhibitAudioRelationCreateNestedManyWithoutAudioInput;
    exhibit?: exhibitCreateNestedManyWithoutAudioInput;
  };

  export type audioUncheckedCreateWithoutLanguageInput = {
    audioId?: string;
    fileUrl: string;
    description: string;
    createdBy: string;
    createdAt: Date | string;
    statusCode: string;
    exhibits?: exhibitAudioRelationUncheckedCreateNestedManyWithoutAudioInput;
    exhibit?: exhibitUncheckedCreateNestedManyWithoutAudioInput;
  };

  export type audioCreateOrConnectWithoutLanguageInput = {
    where: audioWhereUniqueInput;
    create: XOR<
      audioCreateWithoutLanguageInput,
      audioUncheckedCreateWithoutLanguageInput
    >;
  };

  export type audioCreateManyLanguageInputEnvelope = {
    data: audioCreateManyLanguageInput | audioCreateManyLanguageInput[];
    skipDuplicates?: boolean;
  };

  export type userProfileCreateWithoutLanguageInput = {
    userProfileId?: string;
    fName: string;
    lName: string;
    gender: string;
    dob: Date | string;
    modifiedBy: string;
    createdBy: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    user: usersCreateNestedOneWithoutUserProfileInput;
    status: statusCreateNestedOneWithoutUserProfilesInput;
  };

  export type userProfileUncheckedCreateWithoutLanguageInput = {
    userProfileId?: string;
    userId: string;
    fName: string;
    lName: string;
    gender: string;
    dob: Date | string;
    modifiedBy: string;
    createdBy: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    statusCode: string;
  };

  export type userProfileCreateOrConnectWithoutLanguageInput = {
    where: userProfileWhereUniqueInput;
    create: XOR<
      userProfileCreateWithoutLanguageInput,
      userProfileUncheckedCreateWithoutLanguageInput
    >;
  };

  export type userProfileCreateManyLanguageInputEnvelope = {
    data:
      | userProfileCreateManyLanguageInput
      | userProfileCreateManyLanguageInput[];
    skipDuplicates?: boolean;
  };

  export type subtitleCreateWithoutLanguageInput = {
    subtitleId?: string;
    subtitleText: string;
    createdBy: string;
    modifiedBy: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    status: statusCreateNestedOneWithoutSubtitlesInput;
    exhibits?: exhibitSubtitleCreateNestedManyWithoutSubtitleInput;
  };

  export type subtitleUncheckedCreateWithoutLanguageInput = {
    subtitleId?: string;
    subtitleText: string;
    createdBy: string;
    modifiedBy: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    statusCode: string;
    exhibits?: exhibitSubtitleUncheckedCreateNestedManyWithoutSubtitleInput;
  };

  export type subtitleCreateOrConnectWithoutLanguageInput = {
    where: subtitleWhereUniqueInput;
    create: XOR<
      subtitleCreateWithoutLanguageInput,
      subtitleUncheckedCreateWithoutLanguageInput
    >;
  };

  export type subtitleCreateManyLanguageInputEnvelope = {
    data: subtitleCreateManyLanguageInput | subtitleCreateManyLanguageInput[];
    skipDuplicates?: boolean;
  };

  export type statusCreateWithoutLanguagesInput = {
    statusCode: string;
    description: string;
    users?: usersCreateNestedManyWithoutStatusInput;
    audios?: audioCreateNestedManyWithoutStatusInput;
    exhibits?: exhibitCreateNestedManyWithoutStatusInput;
    phoneNumbers?: phoneNumberCreateNestedManyWithoutStatusInput;
    emails?: emailCreateNestedManyWithoutStatusInput;
    roles?: roleCreateNestedManyWithoutStatusInput;
    qrcodes?: qrCodeCreateNestedManyWithoutStatusInput;
    images?: imageCreateNestedManyWithoutStatusInput;
    subtitles?: subtitleCreateNestedManyWithoutStatusInput;
    auditLogs?: auditLogCreateNestedManyWithoutStatusInput;
    userProfiles?: userProfileCreateNestedManyWithoutStatusInput;
  };

  export type statusUncheckedCreateWithoutLanguagesInput = {
    statusCode: string;
    description: string;
    users?: usersUncheckedCreateNestedManyWithoutStatusInput;
    audios?: audioUncheckedCreateNestedManyWithoutStatusInput;
    exhibits?: exhibitUncheckedCreateNestedManyWithoutStatusInput;
    phoneNumbers?: phoneNumberUncheckedCreateNestedManyWithoutStatusInput;
    emails?: emailUncheckedCreateNestedManyWithoutStatusInput;
    roles?: roleUncheckedCreateNestedManyWithoutStatusInput;
    qrcodes?: qrCodeUncheckedCreateNestedManyWithoutStatusInput;
    images?: imageUncheckedCreateNestedManyWithoutStatusInput;
    subtitles?: subtitleUncheckedCreateNestedManyWithoutStatusInput;
    auditLogs?: auditLogUncheckedCreateNestedManyWithoutStatusInput;
    userProfiles?: userProfileUncheckedCreateNestedManyWithoutStatusInput;
  };

  export type statusCreateOrConnectWithoutLanguagesInput = {
    where: statusWhereUniqueInput;
    create: XOR<
      statusCreateWithoutLanguagesInput,
      statusUncheckedCreateWithoutLanguagesInput
    >;
  };

  export type audioUpsertWithWhereUniqueWithoutLanguageInput = {
    where: audioWhereUniqueInput;
    update: XOR<
      audioUpdateWithoutLanguageInput,
      audioUncheckedUpdateWithoutLanguageInput
    >;
    create: XOR<
      audioCreateWithoutLanguageInput,
      audioUncheckedCreateWithoutLanguageInput
    >;
  };

  export type audioUpdateWithWhereUniqueWithoutLanguageInput = {
    where: audioWhereUniqueInput;
    data: XOR<
      audioUpdateWithoutLanguageInput,
      audioUncheckedUpdateWithoutLanguageInput
    >;
  };

  export type audioUpdateManyWithWhereWithoutLanguageInput = {
    where: audioScalarWhereInput;
    data: XOR<
      audioUpdateManyMutationInput,
      audioUncheckedUpdateManyWithoutLanguageInput
    >;
  };

  export type userProfileUpsertWithWhereUniqueWithoutLanguageInput = {
    where: userProfileWhereUniqueInput;
    update: XOR<
      userProfileUpdateWithoutLanguageInput,
      userProfileUncheckedUpdateWithoutLanguageInput
    >;
    create: XOR<
      userProfileCreateWithoutLanguageInput,
      userProfileUncheckedCreateWithoutLanguageInput
    >;
  };

  export type userProfileUpdateWithWhereUniqueWithoutLanguageInput = {
    where: userProfileWhereUniqueInput;
    data: XOR<
      userProfileUpdateWithoutLanguageInput,
      userProfileUncheckedUpdateWithoutLanguageInput
    >;
  };

  export type userProfileUpdateManyWithWhereWithoutLanguageInput = {
    where: userProfileScalarWhereInput;
    data: XOR<
      userProfileUpdateManyMutationInput,
      userProfileUncheckedUpdateManyWithoutLanguageInput
    >;
  };

  export type subtitleUpsertWithWhereUniqueWithoutLanguageInput = {
    where: subtitleWhereUniqueInput;
    update: XOR<
      subtitleUpdateWithoutLanguageInput,
      subtitleUncheckedUpdateWithoutLanguageInput
    >;
    create: XOR<
      subtitleCreateWithoutLanguageInput,
      subtitleUncheckedCreateWithoutLanguageInput
    >;
  };

  export type subtitleUpdateWithWhereUniqueWithoutLanguageInput = {
    where: subtitleWhereUniqueInput;
    data: XOR<
      subtitleUpdateWithoutLanguageInput,
      subtitleUncheckedUpdateWithoutLanguageInput
    >;
  };

  export type subtitleUpdateManyWithWhereWithoutLanguageInput = {
    where: subtitleScalarWhereInput;
    data: XOR<
      subtitleUpdateManyMutationInput,
      subtitleUncheckedUpdateManyWithoutLanguageInput
    >;
  };

  export type statusUpsertWithoutLanguagesInput = {
    update: XOR<
      statusUpdateWithoutLanguagesInput,
      statusUncheckedUpdateWithoutLanguagesInput
    >;
    create: XOR<
      statusCreateWithoutLanguagesInput,
      statusUncheckedCreateWithoutLanguagesInput
    >;
    where?: statusWhereInput;
  };

  export type statusUpdateToOneWithWhereWithoutLanguagesInput = {
    where?: statusWhereInput;
    data: XOR<
      statusUpdateWithoutLanguagesInput,
      statusUncheckedUpdateWithoutLanguagesInput
    >;
  };

  export type statusUpdateWithoutLanguagesInput = {
    statusCode?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    users?: usersUpdateManyWithoutStatusNestedInput;
    audios?: audioUpdateManyWithoutStatusNestedInput;
    exhibits?: exhibitUpdateManyWithoutStatusNestedInput;
    phoneNumbers?: phoneNumberUpdateManyWithoutStatusNestedInput;
    emails?: emailUpdateManyWithoutStatusNestedInput;
    roles?: roleUpdateManyWithoutStatusNestedInput;
    qrcodes?: qrCodeUpdateManyWithoutStatusNestedInput;
    images?: imageUpdateManyWithoutStatusNestedInput;
    subtitles?: subtitleUpdateManyWithoutStatusNestedInput;
    auditLogs?: auditLogUpdateManyWithoutStatusNestedInput;
    userProfiles?: userProfileUpdateManyWithoutStatusNestedInput;
  };

  export type statusUncheckedUpdateWithoutLanguagesInput = {
    statusCode?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    users?: usersUncheckedUpdateManyWithoutStatusNestedInput;
    audios?: audioUncheckedUpdateManyWithoutStatusNestedInput;
    exhibits?: exhibitUncheckedUpdateManyWithoutStatusNestedInput;
    phoneNumbers?: phoneNumberUncheckedUpdateManyWithoutStatusNestedInput;
    emails?: emailUncheckedUpdateManyWithoutStatusNestedInput;
    roles?: roleUncheckedUpdateManyWithoutStatusNestedInput;
    qrcodes?: qrCodeUncheckedUpdateManyWithoutStatusNestedInput;
    images?: imageUncheckedUpdateManyWithoutStatusNestedInput;
    subtitles?: subtitleUncheckedUpdateManyWithoutStatusNestedInput;
    auditLogs?: auditLogUncheckedUpdateManyWithoutStatusNestedInput;
    userProfiles?: userProfileUncheckedUpdateManyWithoutStatusNestedInput;
  };

  export type languageCreateWithoutSubtitlesInput = {
    languageCode: string;
    languageName: string;
    audios?: audioCreateNestedManyWithoutLanguageInput;
    profiles?: userProfileCreateNestedManyWithoutLanguageInput;
    status: statusCreateNestedOneWithoutLanguagesInput;
  };

  export type languageUncheckedCreateWithoutSubtitlesInput = {
    languageCode: string;
    languageName: string;
    statusCode: string;
    audios?: audioUncheckedCreateNestedManyWithoutLanguageInput;
    profiles?: userProfileUncheckedCreateNestedManyWithoutLanguageInput;
  };

  export type languageCreateOrConnectWithoutSubtitlesInput = {
    where: languageWhereUniqueInput;
    create: XOR<
      languageCreateWithoutSubtitlesInput,
      languageUncheckedCreateWithoutSubtitlesInput
    >;
  };

  export type statusCreateWithoutSubtitlesInput = {
    statusCode: string;
    description: string;
    users?: usersCreateNestedManyWithoutStatusInput;
    audios?: audioCreateNestedManyWithoutStatusInput;
    exhibits?: exhibitCreateNestedManyWithoutStatusInput;
    phoneNumbers?: phoneNumberCreateNestedManyWithoutStatusInput;
    emails?: emailCreateNestedManyWithoutStatusInput;
    roles?: roleCreateNestedManyWithoutStatusInput;
    qrcodes?: qrCodeCreateNestedManyWithoutStatusInput;
    images?: imageCreateNestedManyWithoutStatusInput;
    languages?: languageCreateNestedManyWithoutStatusInput;
    auditLogs?: auditLogCreateNestedManyWithoutStatusInput;
    userProfiles?: userProfileCreateNestedManyWithoutStatusInput;
  };

  export type statusUncheckedCreateWithoutSubtitlesInput = {
    statusCode: string;
    description: string;
    users?: usersUncheckedCreateNestedManyWithoutStatusInput;
    audios?: audioUncheckedCreateNestedManyWithoutStatusInput;
    exhibits?: exhibitUncheckedCreateNestedManyWithoutStatusInput;
    phoneNumbers?: phoneNumberUncheckedCreateNestedManyWithoutStatusInput;
    emails?: emailUncheckedCreateNestedManyWithoutStatusInput;
    roles?: roleUncheckedCreateNestedManyWithoutStatusInput;
    qrcodes?: qrCodeUncheckedCreateNestedManyWithoutStatusInput;
    images?: imageUncheckedCreateNestedManyWithoutStatusInput;
    languages?: languageUncheckedCreateNestedManyWithoutStatusInput;
    auditLogs?: auditLogUncheckedCreateNestedManyWithoutStatusInput;
    userProfiles?: userProfileUncheckedCreateNestedManyWithoutStatusInput;
  };

  export type statusCreateOrConnectWithoutSubtitlesInput = {
    where: statusWhereUniqueInput;
    create: XOR<
      statusCreateWithoutSubtitlesInput,
      statusUncheckedCreateWithoutSubtitlesInput
    >;
  };

  export type exhibitSubtitleCreateWithoutSubtitleInput = {
    createdAt: Date | string;
    exhibit: exhibitCreateNestedOneWithoutSubtitlesInput;
  };

  export type exhibitSubtitleUncheckedCreateWithoutSubtitleInput = {
    exhibitId: string;
    createdAt: Date | string;
  };

  export type exhibitSubtitleCreateOrConnectWithoutSubtitleInput = {
    where: exhibitSubtitleWhereUniqueInput;
    create: XOR<
      exhibitSubtitleCreateWithoutSubtitleInput,
      exhibitSubtitleUncheckedCreateWithoutSubtitleInput
    >;
  };

  export type exhibitSubtitleCreateManySubtitleInputEnvelope = {
    data:
      | exhibitSubtitleCreateManySubtitleInput
      | exhibitSubtitleCreateManySubtitleInput[];
    skipDuplicates?: boolean;
  };

  export type languageUpsertWithoutSubtitlesInput = {
    update: XOR<
      languageUpdateWithoutSubtitlesInput,
      languageUncheckedUpdateWithoutSubtitlesInput
    >;
    create: XOR<
      languageCreateWithoutSubtitlesInput,
      languageUncheckedCreateWithoutSubtitlesInput
    >;
    where?: languageWhereInput;
  };

  export type languageUpdateToOneWithWhereWithoutSubtitlesInput = {
    where?: languageWhereInput;
    data: XOR<
      languageUpdateWithoutSubtitlesInput,
      languageUncheckedUpdateWithoutSubtitlesInput
    >;
  };

  export type languageUpdateWithoutSubtitlesInput = {
    languageCode?: StringFieldUpdateOperationsInput | string;
    languageName?: StringFieldUpdateOperationsInput | string;
    audios?: audioUpdateManyWithoutLanguageNestedInput;
    profiles?: userProfileUpdateManyWithoutLanguageNestedInput;
    status?: statusUpdateOneRequiredWithoutLanguagesNestedInput;
  };

  export type languageUncheckedUpdateWithoutSubtitlesInput = {
    languageCode?: StringFieldUpdateOperationsInput | string;
    languageName?: StringFieldUpdateOperationsInput | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
    audios?: audioUncheckedUpdateManyWithoutLanguageNestedInput;
    profiles?: userProfileUncheckedUpdateManyWithoutLanguageNestedInput;
  };

  export type statusUpsertWithoutSubtitlesInput = {
    update: XOR<
      statusUpdateWithoutSubtitlesInput,
      statusUncheckedUpdateWithoutSubtitlesInput
    >;
    create: XOR<
      statusCreateWithoutSubtitlesInput,
      statusUncheckedCreateWithoutSubtitlesInput
    >;
    where?: statusWhereInput;
  };

  export type statusUpdateToOneWithWhereWithoutSubtitlesInput = {
    where?: statusWhereInput;
    data: XOR<
      statusUpdateWithoutSubtitlesInput,
      statusUncheckedUpdateWithoutSubtitlesInput
    >;
  };

  export type statusUpdateWithoutSubtitlesInput = {
    statusCode?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    users?: usersUpdateManyWithoutStatusNestedInput;
    audios?: audioUpdateManyWithoutStatusNestedInput;
    exhibits?: exhibitUpdateManyWithoutStatusNestedInput;
    phoneNumbers?: phoneNumberUpdateManyWithoutStatusNestedInput;
    emails?: emailUpdateManyWithoutStatusNestedInput;
    roles?: roleUpdateManyWithoutStatusNestedInput;
    qrcodes?: qrCodeUpdateManyWithoutStatusNestedInput;
    images?: imageUpdateManyWithoutStatusNestedInput;
    languages?: languageUpdateManyWithoutStatusNestedInput;
    auditLogs?: auditLogUpdateManyWithoutStatusNestedInput;
    userProfiles?: userProfileUpdateManyWithoutStatusNestedInput;
  };

  export type statusUncheckedUpdateWithoutSubtitlesInput = {
    statusCode?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    users?: usersUncheckedUpdateManyWithoutStatusNestedInput;
    audios?: audioUncheckedUpdateManyWithoutStatusNestedInput;
    exhibits?: exhibitUncheckedUpdateManyWithoutStatusNestedInput;
    phoneNumbers?: phoneNumberUncheckedUpdateManyWithoutStatusNestedInput;
    emails?: emailUncheckedUpdateManyWithoutStatusNestedInput;
    roles?: roleUncheckedUpdateManyWithoutStatusNestedInput;
    qrcodes?: qrCodeUncheckedUpdateManyWithoutStatusNestedInput;
    images?: imageUncheckedUpdateManyWithoutStatusNestedInput;
    languages?: languageUncheckedUpdateManyWithoutStatusNestedInput;
    auditLogs?: auditLogUncheckedUpdateManyWithoutStatusNestedInput;
    userProfiles?: userProfileUncheckedUpdateManyWithoutStatusNestedInput;
  };

  export type exhibitSubtitleUpsertWithWhereUniqueWithoutSubtitleInput = {
    where: exhibitSubtitleWhereUniqueInput;
    update: XOR<
      exhibitSubtitleUpdateWithoutSubtitleInput,
      exhibitSubtitleUncheckedUpdateWithoutSubtitleInput
    >;
    create: XOR<
      exhibitSubtitleCreateWithoutSubtitleInput,
      exhibitSubtitleUncheckedCreateWithoutSubtitleInput
    >;
  };

  export type exhibitSubtitleUpdateWithWhereUniqueWithoutSubtitleInput = {
    where: exhibitSubtitleWhereUniqueInput;
    data: XOR<
      exhibitSubtitleUpdateWithoutSubtitleInput,
      exhibitSubtitleUncheckedUpdateWithoutSubtitleInput
    >;
  };

  export type exhibitSubtitleUpdateManyWithWhereWithoutSubtitleInput = {
    where: exhibitSubtitleScalarWhereInput;
    data: XOR<
      exhibitSubtitleUpdateManyMutationInput,
      exhibitSubtitleUncheckedUpdateManyWithoutSubtitleInput
    >;
  };

  export type exhibitCreateWithoutSubtitlesInput = {
    exhibitId?: string;
    title: string;
    description: string;
    createdBy: string;
    modifiedBy: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    audio: audioCreateNestedOneWithoutExhibitInput;
    qrCode: qrCodeCreateNestedOneWithoutExhibitInput;
    image: imageCreateNestedOneWithoutExhibitInput;
    status: statusCreateNestedOneWithoutExhibitsInput;
    exhibitAudioRelation?: exhibitAudioRelationCreateNestedManyWithoutExhibitInput;
  };

  export type exhibitUncheckedCreateWithoutSubtitlesInput = {
    exhibitId?: string;
    title: string;
    description: string;
    audioId: string;
    createdBy: string;
    modifiedBy: string;
    qrCodeId: string;
    imageId: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    statusCode: string;
    exhibitAudioRelation?: exhibitAudioRelationUncheckedCreateNestedManyWithoutExhibitInput;
  };

  export type exhibitCreateOrConnectWithoutSubtitlesInput = {
    where: exhibitWhereUniqueInput;
    create: XOR<
      exhibitCreateWithoutSubtitlesInput,
      exhibitUncheckedCreateWithoutSubtitlesInput
    >;
  };

  export type subtitleCreateWithoutExhibitsInput = {
    subtitleId?: string;
    subtitleText: string;
    createdBy: string;
    modifiedBy: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    language: languageCreateNestedOneWithoutSubtitlesInput;
    status: statusCreateNestedOneWithoutSubtitlesInput;
  };

  export type subtitleUncheckedCreateWithoutExhibitsInput = {
    subtitleId?: string;
    subtitleText: string;
    languageCode: string;
    createdBy: string;
    modifiedBy: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    statusCode: string;
  };

  export type subtitleCreateOrConnectWithoutExhibitsInput = {
    where: subtitleWhereUniqueInput;
    create: XOR<
      subtitleCreateWithoutExhibitsInput,
      subtitleUncheckedCreateWithoutExhibitsInput
    >;
  };

  export type exhibitUpsertWithoutSubtitlesInput = {
    update: XOR<
      exhibitUpdateWithoutSubtitlesInput,
      exhibitUncheckedUpdateWithoutSubtitlesInput
    >;
    create: XOR<
      exhibitCreateWithoutSubtitlesInput,
      exhibitUncheckedCreateWithoutSubtitlesInput
    >;
    where?: exhibitWhereInput;
  };

  export type exhibitUpdateToOneWithWhereWithoutSubtitlesInput = {
    where?: exhibitWhereInput;
    data: XOR<
      exhibitUpdateWithoutSubtitlesInput,
      exhibitUncheckedUpdateWithoutSubtitlesInput
    >;
  };

  export type exhibitUpdateWithoutSubtitlesInput = {
    exhibitId?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    modifiedBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    audio?: audioUpdateOneRequiredWithoutExhibitNestedInput;
    qrCode?: qrCodeUpdateOneRequiredWithoutExhibitNestedInput;
    image?: imageUpdateOneRequiredWithoutExhibitNestedInput;
    status?: statusUpdateOneRequiredWithoutExhibitsNestedInput;
    exhibitAudioRelation?: exhibitAudioRelationUpdateManyWithoutExhibitNestedInput;
  };

  export type exhibitUncheckedUpdateWithoutSubtitlesInput = {
    exhibitId?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    audioId?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    modifiedBy?: StringFieldUpdateOperationsInput | string;
    qrCodeId?: StringFieldUpdateOperationsInput | string;
    imageId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
    exhibitAudioRelation?: exhibitAudioRelationUncheckedUpdateManyWithoutExhibitNestedInput;
  };

  export type subtitleUpsertWithoutExhibitsInput = {
    update: XOR<
      subtitleUpdateWithoutExhibitsInput,
      subtitleUncheckedUpdateWithoutExhibitsInput
    >;
    create: XOR<
      subtitleCreateWithoutExhibitsInput,
      subtitleUncheckedCreateWithoutExhibitsInput
    >;
    where?: subtitleWhereInput;
  };

  export type subtitleUpdateToOneWithWhereWithoutExhibitsInput = {
    where?: subtitleWhereInput;
    data: XOR<
      subtitleUpdateWithoutExhibitsInput,
      subtitleUncheckedUpdateWithoutExhibitsInput
    >;
  };

  export type subtitleUpdateWithoutExhibitsInput = {
    subtitleId?: StringFieldUpdateOperationsInput | string;
    subtitleText?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    modifiedBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    language?: languageUpdateOneRequiredWithoutSubtitlesNestedInput;
    status?: statusUpdateOneRequiredWithoutSubtitlesNestedInput;
  };

  export type subtitleUncheckedUpdateWithoutExhibitsInput = {
    subtitleId?: StringFieldUpdateOperationsInput | string;
    subtitleText?: StringFieldUpdateOperationsInput | string;
    languageCode?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    modifiedBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
  };

  export type phoneNumberCreateManyUserInput = {
    phoneNumberId?: string;
    phoneNumber: string;
    verified: boolean;
    isPrimary: boolean;
    createdAt: Date | string;
    statusCode: string;
  };

  export type emailCreateManyUserInput = {
    emailId?: string;
    email: string;
    verified: boolean;
    isPrimary: boolean;
    createdAt: Date | string;
    statusCode: string;
  };

  export type sessionCreateManyUserInput = {
    sessionId?: string;
    deviceInfo: string;
    isActive: boolean;
    createdAt: Date | string;
  };

  export type auditLogCreateManyUserInput = {
    auditLogId?: string;
    ipAddress: string;
    entityName: string;
    entityId: string;
    actionType: string;
    oldValue: string;
    newValue: string;
    timestamp: Date | string;
    statusCode: string;
  };

  export type eventCreateManyUsersInput = {
    eventId?: string;
    sessionId: string;
    entityId: number;
    entityName: string;
    timestamp: Date | string;
  };

  export type userRoleCreateManyUserInput = {
    roleId: number;
  };

  export type phoneNumberUpdateWithoutUserInput = {
    phoneNumberId?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: StringFieldUpdateOperationsInput | string;
    verified?: BoolFieldUpdateOperationsInput | boolean;
    isPrimary?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    status?: statusUpdateOneRequiredWithoutPhoneNumbersNestedInput;
  };

  export type phoneNumberUncheckedUpdateWithoutUserInput = {
    phoneNumberId?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: StringFieldUpdateOperationsInput | string;
    verified?: BoolFieldUpdateOperationsInput | boolean;
    isPrimary?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
  };

  export type phoneNumberUncheckedUpdateManyWithoutUserInput = {
    phoneNumberId?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: StringFieldUpdateOperationsInput | string;
    verified?: BoolFieldUpdateOperationsInput | boolean;
    isPrimary?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
  };

  export type emailUpdateWithoutUserInput = {
    emailId?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    verified?: BoolFieldUpdateOperationsInput | boolean;
    isPrimary?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    status?: statusUpdateOneRequiredWithoutEmailsNestedInput;
  };

  export type emailUncheckedUpdateWithoutUserInput = {
    emailId?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    verified?: BoolFieldUpdateOperationsInput | boolean;
    isPrimary?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
  };

  export type emailUncheckedUpdateManyWithoutUserInput = {
    emailId?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    verified?: BoolFieldUpdateOperationsInput | boolean;
    isPrimary?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
  };

  export type sessionUpdateWithoutUserInput = {
    sessionId?: StringFieldUpdateOperationsInput | string;
    deviceInfo?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    events?: eventUpdateManyWithoutSessionNestedInput;
  };

  export type sessionUncheckedUpdateWithoutUserInput = {
    sessionId?: StringFieldUpdateOperationsInput | string;
    deviceInfo?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    events?: eventUncheckedUpdateManyWithoutSessionNestedInput;
  };

  export type sessionUncheckedUpdateManyWithoutUserInput = {
    sessionId?: StringFieldUpdateOperationsInput | string;
    deviceInfo?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type auditLogUpdateWithoutUserInput = {
    auditLogId?: StringFieldUpdateOperationsInput | string;
    ipAddress?: StringFieldUpdateOperationsInput | string;
    entityName?: StringFieldUpdateOperationsInput | string;
    entityId?: StringFieldUpdateOperationsInput | string;
    actionType?: StringFieldUpdateOperationsInput | string;
    oldValue?: StringFieldUpdateOperationsInput | string;
    newValue?: StringFieldUpdateOperationsInput | string;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
    status?: statusUpdateOneRequiredWithoutAuditLogsNestedInput;
  };

  export type auditLogUncheckedUpdateWithoutUserInput = {
    auditLogId?: StringFieldUpdateOperationsInput | string;
    ipAddress?: StringFieldUpdateOperationsInput | string;
    entityName?: StringFieldUpdateOperationsInput | string;
    entityId?: StringFieldUpdateOperationsInput | string;
    actionType?: StringFieldUpdateOperationsInput | string;
    oldValue?: StringFieldUpdateOperationsInput | string;
    newValue?: StringFieldUpdateOperationsInput | string;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
  };

  export type auditLogUncheckedUpdateManyWithoutUserInput = {
    auditLogId?: StringFieldUpdateOperationsInput | string;
    ipAddress?: StringFieldUpdateOperationsInput | string;
    entityName?: StringFieldUpdateOperationsInput | string;
    entityId?: StringFieldUpdateOperationsInput | string;
    actionType?: StringFieldUpdateOperationsInput | string;
    oldValue?: StringFieldUpdateOperationsInput | string;
    newValue?: StringFieldUpdateOperationsInput | string;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
  };

  export type eventUpdateWithoutUsersInput = {
    eventId?: StringFieldUpdateOperationsInput | string;
    entityId?: IntFieldUpdateOperationsInput | number;
    entityName?: StringFieldUpdateOperationsInput | string;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
    session?: sessionUpdateOneRequiredWithoutEventsNestedInput;
  };

  export type eventUncheckedUpdateWithoutUsersInput = {
    eventId?: StringFieldUpdateOperationsInput | string;
    sessionId?: StringFieldUpdateOperationsInput | string;
    entityId?: IntFieldUpdateOperationsInput | number;
    entityName?: StringFieldUpdateOperationsInput | string;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type eventUncheckedUpdateManyWithoutUsersInput = {
    eventId?: StringFieldUpdateOperationsInput | string;
    sessionId?: StringFieldUpdateOperationsInput | string;
    entityId?: IntFieldUpdateOperationsInput | number;
    entityName?: StringFieldUpdateOperationsInput | string;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type userRoleUpdateWithoutUserInput = {
    role?: roleUpdateOneRequiredWithoutUserRolesNestedInput;
  };

  export type userRoleUncheckedUpdateWithoutUserInput = {
    roleId?: IntFieldUpdateOperationsInput | number;
  };

  export type userRoleUncheckedUpdateManyWithoutUserInput = {
    roleId?: IntFieldUpdateOperationsInput | number;
  };

  export type usersCreateManyStatusInput = {
    userId?: string;
    username: string;
    password: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
  };

  export type audioCreateManyStatusInput = {
    audioId?: string;
    fileUrl: string;
    description: string;
    createdBy: string;
    languageId: string;
    createdAt: Date | string;
  };

  export type exhibitCreateManyStatusInput = {
    exhibitId?: string;
    title: string;
    description: string;
    audioId: string;
    createdBy: string;
    modifiedBy: string;
    qrCodeId: string;
    imageId: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
  };

  export type phoneNumberCreateManyStatusInput = {
    phoneNumberId?: string;
    userId: string;
    phoneNumber: string;
    verified: boolean;
    isPrimary: boolean;
    createdAt: Date | string;
  };

  export type emailCreateManyStatusInput = {
    emailId?: string;
    userId: string;
    email: string;
    verified: boolean;
    isPrimary: boolean;
    createdAt: Date | string;
  };

  export type roleCreateManyStatusInput = {
    roleId?: number;
    roleName: string;
    description: string;
  };

  export type qrCodeCreateManyStatusInput = {
    qrCodeId?: string;
    qrLink: string;
    createdBy: string;
    createdAt: Date | string;
  };

  export type imageCreateManyStatusInput = {
    imageId?: string;
    description: string;
    createdBy: string;
    createdAt: Date | string;
  };

  export type subtitleCreateManyStatusInput = {
    subtitleId?: string;
    subtitleText: string;
    languageCode: string;
    createdBy: string;
    modifiedBy: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
  };

  export type languageCreateManyStatusInput = {
    languageCode: string;
    languageName: string;
  };

  export type auditLogCreateManyStatusInput = {
    auditLogId?: string;
    userId: string;
    ipAddress: string;
    entityName: string;
    entityId: string;
    actionType: string;
    oldValue: string;
    newValue: string;
    timestamp: Date | string;
  };

  export type userProfileCreateManyStatusInput = {
    userProfileId?: string;
    userId: string;
    fName: string;
    lName: string;
    languageCode: string;
    gender: string;
    dob: Date | string;
    modifiedBy: string;
    createdBy: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
  };

  export type usersUpdateWithoutStatusInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    phoneNumbers?: phoneNumberUpdateManyWithoutUserNestedInput;
    emails?: emailUpdateManyWithoutUserNestedInput;
    userProfile?: userProfileUpdateOneWithoutUserNestedInput;
    sessions?: sessionUpdateManyWithoutUserNestedInput;
    auditLogs?: auditLogUpdateManyWithoutUserNestedInput;
    events?: eventUpdateManyWithoutUsersNestedInput;
    userRoles?: userRoleUpdateManyWithoutUserNestedInput;
  };

  export type usersUncheckedUpdateWithoutStatusInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    phoneNumbers?: phoneNumberUncheckedUpdateManyWithoutUserNestedInput;
    emails?: emailUncheckedUpdateManyWithoutUserNestedInput;
    userProfile?: userProfileUncheckedUpdateOneWithoutUserNestedInput;
    sessions?: sessionUncheckedUpdateManyWithoutUserNestedInput;
    auditLogs?: auditLogUncheckedUpdateManyWithoutUserNestedInput;
    events?: eventUncheckedUpdateManyWithoutUsersNestedInput;
    userRoles?: userRoleUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type usersUncheckedUpdateManyWithoutStatusInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    password?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type audioUpdateWithoutStatusInput = {
    audioId?: StringFieldUpdateOperationsInput | string;
    fileUrl?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    language?: languageUpdateOneRequiredWithoutAudiosNestedInput;
    exhibits?: exhibitAudioRelationUpdateManyWithoutAudioNestedInput;
    exhibit?: exhibitUpdateManyWithoutAudioNestedInput;
  };

  export type audioUncheckedUpdateWithoutStatusInput = {
    audioId?: StringFieldUpdateOperationsInput | string;
    fileUrl?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    languageId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    exhibits?: exhibitAudioRelationUncheckedUpdateManyWithoutAudioNestedInput;
    exhibit?: exhibitUncheckedUpdateManyWithoutAudioNestedInput;
  };

  export type audioUncheckedUpdateManyWithoutStatusInput = {
    audioId?: StringFieldUpdateOperationsInput | string;
    fileUrl?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    languageId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type exhibitUpdateWithoutStatusInput = {
    exhibitId?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    modifiedBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    audio?: audioUpdateOneRequiredWithoutExhibitNestedInput;
    qrCode?: qrCodeUpdateOneRequiredWithoutExhibitNestedInput;
    image?: imageUpdateOneRequiredWithoutExhibitNestedInput;
    subtitles?: exhibitSubtitleUpdateManyWithoutExhibitNestedInput;
    exhibitAudioRelation?: exhibitAudioRelationUpdateManyWithoutExhibitNestedInput;
  };

  export type exhibitUncheckedUpdateWithoutStatusInput = {
    exhibitId?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    audioId?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    modifiedBy?: StringFieldUpdateOperationsInput | string;
    qrCodeId?: StringFieldUpdateOperationsInput | string;
    imageId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    subtitles?: exhibitSubtitleUncheckedUpdateManyWithoutExhibitNestedInput;
    exhibitAudioRelation?: exhibitAudioRelationUncheckedUpdateManyWithoutExhibitNestedInput;
  };

  export type exhibitUncheckedUpdateManyWithoutStatusInput = {
    exhibitId?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    audioId?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    modifiedBy?: StringFieldUpdateOperationsInput | string;
    qrCodeId?: StringFieldUpdateOperationsInput | string;
    imageId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type phoneNumberUpdateWithoutStatusInput = {
    phoneNumberId?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: StringFieldUpdateOperationsInput | string;
    verified?: BoolFieldUpdateOperationsInput | boolean;
    isPrimary?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: usersUpdateOneRequiredWithoutPhoneNumbersNestedInput;
  };

  export type phoneNumberUncheckedUpdateWithoutStatusInput = {
    phoneNumberId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: StringFieldUpdateOperationsInput | string;
    verified?: BoolFieldUpdateOperationsInput | boolean;
    isPrimary?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type phoneNumberUncheckedUpdateManyWithoutStatusInput = {
    phoneNumberId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: StringFieldUpdateOperationsInput | string;
    verified?: BoolFieldUpdateOperationsInput | boolean;
    isPrimary?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type emailUpdateWithoutStatusInput = {
    emailId?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    verified?: BoolFieldUpdateOperationsInput | boolean;
    isPrimary?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: usersUpdateOneRequiredWithoutEmailsNestedInput;
  };

  export type emailUncheckedUpdateWithoutStatusInput = {
    emailId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    verified?: BoolFieldUpdateOperationsInput | boolean;
    isPrimary?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type emailUncheckedUpdateManyWithoutStatusInput = {
    emailId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    verified?: BoolFieldUpdateOperationsInput | boolean;
    isPrimary?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type roleUpdateWithoutStatusInput = {
    roleName?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    userRoles?: userRoleUpdateManyWithoutRoleNestedInput;
  };

  export type roleUncheckedUpdateWithoutStatusInput = {
    roleId?: IntFieldUpdateOperationsInput | number;
    roleName?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    userRoles?: userRoleUncheckedUpdateManyWithoutRoleNestedInput;
  };

  export type roleUncheckedUpdateManyWithoutStatusInput = {
    roleId?: IntFieldUpdateOperationsInput | number;
    roleName?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
  };

  export type qrCodeUpdateWithoutStatusInput = {
    qrCodeId?: StringFieldUpdateOperationsInput | string;
    qrLink?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    exhibit?: exhibitUpdateManyWithoutQrCodeNestedInput;
  };

  export type qrCodeUncheckedUpdateWithoutStatusInput = {
    qrCodeId?: StringFieldUpdateOperationsInput | string;
    qrLink?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    exhibit?: exhibitUncheckedUpdateManyWithoutQrCodeNestedInput;
  };

  export type qrCodeUncheckedUpdateManyWithoutStatusInput = {
    qrCodeId?: StringFieldUpdateOperationsInput | string;
    qrLink?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type imageUpdateWithoutStatusInput = {
    imageId?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    exhibit?: exhibitUpdateManyWithoutImageNestedInput;
  };

  export type imageUncheckedUpdateWithoutStatusInput = {
    imageId?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    exhibit?: exhibitUncheckedUpdateManyWithoutImageNestedInput;
  };

  export type imageUncheckedUpdateManyWithoutStatusInput = {
    imageId?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type subtitleUpdateWithoutStatusInput = {
    subtitleId?: StringFieldUpdateOperationsInput | string;
    subtitleText?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    modifiedBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    language?: languageUpdateOneRequiredWithoutSubtitlesNestedInput;
    exhibits?: exhibitSubtitleUpdateManyWithoutSubtitleNestedInput;
  };

  export type subtitleUncheckedUpdateWithoutStatusInput = {
    subtitleId?: StringFieldUpdateOperationsInput | string;
    subtitleText?: StringFieldUpdateOperationsInput | string;
    languageCode?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    modifiedBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    exhibits?: exhibitSubtitleUncheckedUpdateManyWithoutSubtitleNestedInput;
  };

  export type subtitleUncheckedUpdateManyWithoutStatusInput = {
    subtitleId?: StringFieldUpdateOperationsInput | string;
    subtitleText?: StringFieldUpdateOperationsInput | string;
    languageCode?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    modifiedBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type languageUpdateWithoutStatusInput = {
    languageCode?: StringFieldUpdateOperationsInput | string;
    languageName?: StringFieldUpdateOperationsInput | string;
    audios?: audioUpdateManyWithoutLanguageNestedInput;
    profiles?: userProfileUpdateManyWithoutLanguageNestedInput;
    subtitles?: subtitleUpdateManyWithoutLanguageNestedInput;
  };

  export type languageUncheckedUpdateWithoutStatusInput = {
    languageCode?: StringFieldUpdateOperationsInput | string;
    languageName?: StringFieldUpdateOperationsInput | string;
    audios?: audioUncheckedUpdateManyWithoutLanguageNestedInput;
    profiles?: userProfileUncheckedUpdateManyWithoutLanguageNestedInput;
    subtitles?: subtitleUncheckedUpdateManyWithoutLanguageNestedInput;
  };

  export type languageUncheckedUpdateManyWithoutStatusInput = {
    languageCode?: StringFieldUpdateOperationsInput | string;
    languageName?: StringFieldUpdateOperationsInput | string;
  };

  export type auditLogUpdateWithoutStatusInput = {
    auditLogId?: StringFieldUpdateOperationsInput | string;
    ipAddress?: StringFieldUpdateOperationsInput | string;
    entityName?: StringFieldUpdateOperationsInput | string;
    entityId?: StringFieldUpdateOperationsInput | string;
    actionType?: StringFieldUpdateOperationsInput | string;
    oldValue?: StringFieldUpdateOperationsInput | string;
    newValue?: StringFieldUpdateOperationsInput | string;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: usersUpdateOneRequiredWithoutAuditLogsNestedInput;
  };

  export type auditLogUncheckedUpdateWithoutStatusInput = {
    auditLogId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    ipAddress?: StringFieldUpdateOperationsInput | string;
    entityName?: StringFieldUpdateOperationsInput | string;
    entityId?: StringFieldUpdateOperationsInput | string;
    actionType?: StringFieldUpdateOperationsInput | string;
    oldValue?: StringFieldUpdateOperationsInput | string;
    newValue?: StringFieldUpdateOperationsInput | string;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type auditLogUncheckedUpdateManyWithoutStatusInput = {
    auditLogId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    ipAddress?: StringFieldUpdateOperationsInput | string;
    entityName?: StringFieldUpdateOperationsInput | string;
    entityId?: StringFieldUpdateOperationsInput | string;
    actionType?: StringFieldUpdateOperationsInput | string;
    oldValue?: StringFieldUpdateOperationsInput | string;
    newValue?: StringFieldUpdateOperationsInput | string;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type userProfileUpdateWithoutStatusInput = {
    userProfileId?: StringFieldUpdateOperationsInput | string;
    fName?: StringFieldUpdateOperationsInput | string;
    lName?: StringFieldUpdateOperationsInput | string;
    gender?: StringFieldUpdateOperationsInput | string;
    dob?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedBy?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: usersUpdateOneRequiredWithoutUserProfileNestedInput;
    language?: languageUpdateOneRequiredWithoutProfilesNestedInput;
  };

  export type userProfileUncheckedUpdateWithoutStatusInput = {
    userProfileId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    fName?: StringFieldUpdateOperationsInput | string;
    lName?: StringFieldUpdateOperationsInput | string;
    languageCode?: StringFieldUpdateOperationsInput | string;
    gender?: StringFieldUpdateOperationsInput | string;
    dob?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedBy?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type userProfileUncheckedUpdateManyWithoutStatusInput = {
    userProfileId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    fName?: StringFieldUpdateOperationsInput | string;
    lName?: StringFieldUpdateOperationsInput | string;
    languageCode?: StringFieldUpdateOperationsInput | string;
    gender?: StringFieldUpdateOperationsInput | string;
    dob?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedBy?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type exhibitAudioRelationCreateManyAudioInput = {
    exhibitId: string;
  };

  export type exhibitCreateManyAudioInput = {
    exhibitId?: string;
    title: string;
    description: string;
    createdBy: string;
    modifiedBy: string;
    qrCodeId: string;
    imageId: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    statusCode: string;
  };

  export type exhibitAudioRelationUpdateWithoutAudioInput = {
    exhibit?: exhibitUpdateOneRequiredWithoutExhibitAudioRelationNestedInput;
  };

  export type exhibitAudioRelationUncheckedUpdateWithoutAudioInput = {
    exhibitId?: StringFieldUpdateOperationsInput | string;
  };

  export type exhibitAudioRelationUncheckedUpdateManyWithoutAudioInput = {
    exhibitId?: StringFieldUpdateOperationsInput | string;
  };

  export type exhibitUpdateWithoutAudioInput = {
    exhibitId?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    modifiedBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    qrCode?: qrCodeUpdateOneRequiredWithoutExhibitNestedInput;
    image?: imageUpdateOneRequiredWithoutExhibitNestedInput;
    subtitles?: exhibitSubtitleUpdateManyWithoutExhibitNestedInput;
    status?: statusUpdateOneRequiredWithoutExhibitsNestedInput;
    exhibitAudioRelation?: exhibitAudioRelationUpdateManyWithoutExhibitNestedInput;
  };

  export type exhibitUncheckedUpdateWithoutAudioInput = {
    exhibitId?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    modifiedBy?: StringFieldUpdateOperationsInput | string;
    qrCodeId?: StringFieldUpdateOperationsInput | string;
    imageId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
    subtitles?: exhibitSubtitleUncheckedUpdateManyWithoutExhibitNestedInput;
    exhibitAudioRelation?: exhibitAudioRelationUncheckedUpdateManyWithoutExhibitNestedInput;
  };

  export type exhibitUncheckedUpdateManyWithoutAudioInput = {
    exhibitId?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    modifiedBy?: StringFieldUpdateOperationsInput | string;
    qrCodeId?: StringFieldUpdateOperationsInput | string;
    imageId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
  };

  export type exhibitSubtitleCreateManyExhibitInput = {
    subtitleId: string;
    createdAt: Date | string;
  };

  export type exhibitAudioRelationCreateManyExhibitInput = {
    audioId: string;
  };

  export type exhibitSubtitleUpdateWithoutExhibitInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    subtitle?: subtitleUpdateOneRequiredWithoutExhibitsNestedInput;
  };

  export type exhibitSubtitleUncheckedUpdateWithoutExhibitInput = {
    subtitleId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type exhibitSubtitleUncheckedUpdateManyWithoutExhibitInput = {
    subtitleId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type exhibitAudioRelationUpdateWithoutExhibitInput = {
    audio?: audioUpdateOneRequiredWithoutExhibitsNestedInput;
  };

  export type exhibitAudioRelationUncheckedUpdateWithoutExhibitInput = {
    audioId?: StringFieldUpdateOperationsInput | string;
  };

  export type exhibitAudioRelationUncheckedUpdateManyWithoutExhibitInput = {
    audioId?: StringFieldUpdateOperationsInput | string;
  };

  export type userRoleCreateManyRoleInput = {
    userId: string;
  };

  export type userRoleUpdateWithoutRoleInput = {
    user?: usersUpdateOneRequiredWithoutUserRolesNestedInput;
  };

  export type userRoleUncheckedUpdateWithoutRoleInput = {
    userId?: StringFieldUpdateOperationsInput | string;
  };

  export type userRoleUncheckedUpdateManyWithoutRoleInput = {
    userId?: StringFieldUpdateOperationsInput | string;
  };

  export type exhibitCreateManyQrCodeInput = {
    exhibitId?: string;
    title: string;
    description: string;
    audioId: string;
    createdBy: string;
    modifiedBy: string;
    imageId: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    statusCode: string;
  };

  export type exhibitUpdateWithoutQrCodeInput = {
    exhibitId?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    modifiedBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    audio?: audioUpdateOneRequiredWithoutExhibitNestedInput;
    image?: imageUpdateOneRequiredWithoutExhibitNestedInput;
    subtitles?: exhibitSubtitleUpdateManyWithoutExhibitNestedInput;
    status?: statusUpdateOneRequiredWithoutExhibitsNestedInput;
    exhibitAudioRelation?: exhibitAudioRelationUpdateManyWithoutExhibitNestedInput;
  };

  export type exhibitUncheckedUpdateWithoutQrCodeInput = {
    exhibitId?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    audioId?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    modifiedBy?: StringFieldUpdateOperationsInput | string;
    imageId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
    subtitles?: exhibitSubtitleUncheckedUpdateManyWithoutExhibitNestedInput;
    exhibitAudioRelation?: exhibitAudioRelationUncheckedUpdateManyWithoutExhibitNestedInput;
  };

  export type exhibitUncheckedUpdateManyWithoutQrCodeInput = {
    exhibitId?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    audioId?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    modifiedBy?: StringFieldUpdateOperationsInput | string;
    imageId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
  };

  export type exhibitCreateManyImageInput = {
    exhibitId?: string;
    title: string;
    description: string;
    audioId: string;
    createdBy: string;
    modifiedBy: string;
    qrCodeId: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    statusCode: string;
  };

  export type exhibitUpdateWithoutImageInput = {
    exhibitId?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    modifiedBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    audio?: audioUpdateOneRequiredWithoutExhibitNestedInput;
    qrCode?: qrCodeUpdateOneRequiredWithoutExhibitNestedInput;
    subtitles?: exhibitSubtitleUpdateManyWithoutExhibitNestedInput;
    status?: statusUpdateOneRequiredWithoutExhibitsNestedInput;
    exhibitAudioRelation?: exhibitAudioRelationUpdateManyWithoutExhibitNestedInput;
  };

  export type exhibitUncheckedUpdateWithoutImageInput = {
    exhibitId?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    audioId?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    modifiedBy?: StringFieldUpdateOperationsInput | string;
    qrCodeId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
    subtitles?: exhibitSubtitleUncheckedUpdateManyWithoutExhibitNestedInput;
    exhibitAudioRelation?: exhibitAudioRelationUncheckedUpdateManyWithoutExhibitNestedInput;
  };

  export type exhibitUncheckedUpdateManyWithoutImageInput = {
    exhibitId?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    audioId?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    modifiedBy?: StringFieldUpdateOperationsInput | string;
    qrCodeId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
  };

  export type eventCreateManySessionInput = {
    eventId?: string;
    entityId: number;
    entityName: string;
    timestamp: Date | string;
    usersUserId?: string | null;
  };

  export type eventUpdateWithoutSessionInput = {
    eventId?: StringFieldUpdateOperationsInput | string;
    entityId?: IntFieldUpdateOperationsInput | number;
    entityName?: StringFieldUpdateOperationsInput | string;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
    users?: usersUpdateOneWithoutEventsNestedInput;
  };

  export type eventUncheckedUpdateWithoutSessionInput = {
    eventId?: StringFieldUpdateOperationsInput | string;
    entityId?: IntFieldUpdateOperationsInput | number;
    entityName?: StringFieldUpdateOperationsInput | string;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
    usersUserId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type eventUncheckedUpdateManyWithoutSessionInput = {
    eventId?: StringFieldUpdateOperationsInput | string;
    entityId?: IntFieldUpdateOperationsInput | number;
    entityName?: StringFieldUpdateOperationsInput | string;
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
    usersUserId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type audioCreateManyLanguageInput = {
    audioId?: string;
    fileUrl: string;
    description: string;
    createdBy: string;
    createdAt: Date | string;
    statusCode: string;
  };

  export type userProfileCreateManyLanguageInput = {
    userProfileId?: string;
    userId: string;
    fName: string;
    lName: string;
    gender: string;
    dob: Date | string;
    modifiedBy: string;
    createdBy: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    statusCode: string;
  };

  export type subtitleCreateManyLanguageInput = {
    subtitleId?: string;
    subtitleText: string;
    createdBy: string;
    modifiedBy: string;
    createdAt: Date | string;
    modifiedAt: Date | string;
    statusCode: string;
  };

  export type audioUpdateWithoutLanguageInput = {
    audioId?: StringFieldUpdateOperationsInput | string;
    fileUrl?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    status?: statusUpdateOneRequiredWithoutAudiosNestedInput;
    exhibits?: exhibitAudioRelationUpdateManyWithoutAudioNestedInput;
    exhibit?: exhibitUpdateManyWithoutAudioNestedInput;
  };

  export type audioUncheckedUpdateWithoutLanguageInput = {
    audioId?: StringFieldUpdateOperationsInput | string;
    fileUrl?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
    exhibits?: exhibitAudioRelationUncheckedUpdateManyWithoutAudioNestedInput;
    exhibit?: exhibitUncheckedUpdateManyWithoutAudioNestedInput;
  };

  export type audioUncheckedUpdateManyWithoutLanguageInput = {
    audioId?: StringFieldUpdateOperationsInput | string;
    fileUrl?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
  };

  export type userProfileUpdateWithoutLanguageInput = {
    userProfileId?: StringFieldUpdateOperationsInput | string;
    fName?: StringFieldUpdateOperationsInput | string;
    lName?: StringFieldUpdateOperationsInput | string;
    gender?: StringFieldUpdateOperationsInput | string;
    dob?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedBy?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: usersUpdateOneRequiredWithoutUserProfileNestedInput;
    status?: statusUpdateOneRequiredWithoutUserProfilesNestedInput;
  };

  export type userProfileUncheckedUpdateWithoutLanguageInput = {
    userProfileId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    fName?: StringFieldUpdateOperationsInput | string;
    lName?: StringFieldUpdateOperationsInput | string;
    gender?: StringFieldUpdateOperationsInput | string;
    dob?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedBy?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
  };

  export type userProfileUncheckedUpdateManyWithoutLanguageInput = {
    userProfileId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    fName?: StringFieldUpdateOperationsInput | string;
    lName?: StringFieldUpdateOperationsInput | string;
    gender?: StringFieldUpdateOperationsInput | string;
    dob?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedBy?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
  };

  export type subtitleUpdateWithoutLanguageInput = {
    subtitleId?: StringFieldUpdateOperationsInput | string;
    subtitleText?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    modifiedBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    status?: statusUpdateOneRequiredWithoutSubtitlesNestedInput;
    exhibits?: exhibitSubtitleUpdateManyWithoutSubtitleNestedInput;
  };

  export type subtitleUncheckedUpdateWithoutLanguageInput = {
    subtitleId?: StringFieldUpdateOperationsInput | string;
    subtitleText?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    modifiedBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
    exhibits?: exhibitSubtitleUncheckedUpdateManyWithoutSubtitleNestedInput;
  };

  export type subtitleUncheckedUpdateManyWithoutLanguageInput = {
    subtitleId?: StringFieldUpdateOperationsInput | string;
    subtitleText?: StringFieldUpdateOperationsInput | string;
    createdBy?: StringFieldUpdateOperationsInput | string;
    modifiedBy?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    modifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    statusCode?: StringFieldUpdateOperationsInput | string;
  };

  export type exhibitSubtitleCreateManySubtitleInput = {
    exhibitId: string;
    createdAt: Date | string;
  };

  export type exhibitSubtitleUpdateWithoutSubtitleInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    exhibit?: exhibitUpdateOneRequiredWithoutSubtitlesNestedInput;
  };

  export type exhibitSubtitleUncheckedUpdateWithoutSubtitleInput = {
    exhibitId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type exhibitSubtitleUncheckedUpdateManyWithoutSubtitleInput = {
    exhibitId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number;
  };

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF;
}
